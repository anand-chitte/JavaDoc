{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Java Spring Boot Microservice Documentation Welcome to the Java Spring Boot Microservices quick reference guide. This document provides a brief overview of the essential concepts and practices for building microservices using Spring Boot.","title":"Home"},{"location":"#java-spring-boot-microservice-documentation","text":"Welcome to the Java Spring Boot Microservices quick reference guide. This document provides a brief overview of the essential concepts and practices for building microservices using Spring Boot.","title":"Java Spring Boot Microservice Documentation"},{"location":"java/Casting/","text":"Type Casting in Java In Java, type casting is the process of converting one data type into another. There are two types of casting: 1. Implicit Casting (Widening) This occurs automatically when a smaller data type is converted to a larger data type. No data loss occurs because the target type can accommodate the value of the source type. Example: int num = 100; double doubleNum = num; // int to double (widening) System.out.println(doubleNum); // Output: 100.0 2. Explicit Casting (Narrowing) This occurs when you convert a larger data type into a smaller data type. Since there may be data loss, it requires explicit casting using parentheses. Example: double num = 100.99; int intNum = (int) num; // double to int (narrowing) System.out.println(intNum); // Output: 100 (decimal part is truncated) Key Points: Widening casting : Automatically happens when you assign a smaller type to a larger one. Narrowing casting : You must manually specify it with parentheses to avoid potential data loss. Casting with Objects : For object references, casting is done with instanceof to ensure safe conversion, such as casting one class type to another within an inheritance hierarchy. Example with Objects : class Animal {} class Dog extends Animal {} public class Main { public static void main(String[] args) { Animal animal = new Dog(); // Implicit casting (upcasting) Dog dog = (Dog) animal; // Explicit casting (downcasting) } }","title":"Casting"},{"location":"java/Casting/#type-casting-in-java","text":"In Java, type casting is the process of converting one data type into another. There are two types of casting:","title":"Type Casting in Java"},{"location":"java/Casting/#1-implicit-casting-widening","text":"This occurs automatically when a smaller data type is converted to a larger data type. No data loss occurs because the target type can accommodate the value of the source type. Example: int num = 100; double doubleNum = num; // int to double (widening) System.out.println(doubleNum); // Output: 100.0","title":"1. Implicit Casting (Widening)"},{"location":"java/Casting/#2-explicit-casting-narrowing","text":"This occurs when you convert a larger data type into a smaller data type. Since there may be data loss, it requires explicit casting using parentheses. Example: double num = 100.99; int intNum = (int) num; // double to int (narrowing) System.out.println(intNum); // Output: 100 (decimal part is truncated)","title":"2. Explicit Casting (Narrowing)"},{"location":"java/Casting/#key-points","text":"Widening casting : Automatically happens when you assign a smaller type to a larger one. Narrowing casting : You must manually specify it with parentheses to avoid potential data loss. Casting with Objects : For object references, casting is done with instanceof to ensure safe conversion, such as casting one class type to another within an inheritance hierarchy. Example with Objects : class Animal {} class Dog extends Animal {} public class Main { public static void main(String[] args) { Animal animal = new Dog(); // Implicit casting (upcasting) Dog dog = (Dog) animal; // Explicit casting (downcasting) } }","title":"Key Points:"},{"location":"java/Collection%20Framework/","text":"Collection Framework in Java The Java Collection Framework is a unified architecture for representing and manipulating collections (groups of objects). It provides pre-built data structures like List, Set, Queue, and Map, making it easier to handle data in a structured way. Core Interfaces in the Collection Framework 1. Collection Interface The root interface of the framework. It defines basic methods for adding, removing, and querying elements. Subinterfaces : List : An ordered collection that can contain duplicate elements. Set : A collection that cannot contain duplicate elements. Queue : A collection designed for holding elements before processing, typically in a FIFO (First-In-First-Out) order. Deque : A double-ended queue, supports adding/removing elements from both ends. 2. Map Interface Represents a collection of key-value pairs (entries). Each key maps to exactly one value. Maps do not extend Collection . Major Implementations 1. List Implementations ArrayList : Resizable array, allows fast random access and slower insertions/removals in the middle. LinkedList : Doubly linked list, slower access but faster insertions/removals. Vector : Synchronized version of ArrayList (rarely used in modern applications). Stack : A subclass of Vector, representing a stack data structure. 2. Set Implementations HashSet : Does not allow duplicates and does not maintain any specific order of elements. LinkedHashSet : Maintains the insertion order of elements. TreeSet : Implements a NavigableSet and orders elements based on their natural ordering or by a Comparator. 3. Queue Implementations PriorityQueue : A queue where elements are processed based on their priority, not the order they were added. LinkedList : Can also be used as a Queue, supports FIFO operations. 4. Deque Implementations ArrayDeque : A resizable array implementation of the Deque interface. LinkedList : Can also be used as a Deque. 5. Map Implementations HashMap : A map based on hashing, does not maintain any order of elements. LinkedHashMap : Maintains the insertion order of keys. TreeMap : Implements a NavigableMap and orders keys based on their natural ordering or a Comparator. Useful Collection Classes Collections : A utility class providing static methods to operate on collections (like sorting, reversing, etc.). Arrays : Provides static methods to manipulate arrays, like converting an array to a list. Algorithms Java Collection Framework provides several useful algorithms (like sorting, binary search) implemented in the Collections utility class: Sorting : Collections.sort(list) Shuffling : Collections.shuffle(list) Reversing : Collections.reverse(list) Binary Search : Collections.binarySearch(list, key) Key Concepts Generics : Most collection classes use generics to ensure type safety (e.g., List<String> , Map<Integer, String> ). Iterator : An interface for iterating over elements in a collection. Common methods are hasNext() and next() . Autoboxing : Automatic conversion between primitive types and their corresponding wrapper classes when using collections (e.g., int to Integer ). Example Usage import java.util.*; public class CollectionExample { public static void main(String[] args) { // List Example List<String> list = new ArrayList<>(); list.add(\"Java\"); list.add(\"Python\"); list.add(\"JavaScript\"); // Iterating over List for (String lang : list) { System.out.println(lang); } // Set Example (no duplicates) Set<String> set = new HashSet<>(); set.add(\"Apple\"); set.add(\"Banana\"); set.add(\"Apple\"); // Duplicate, won't be added // Iterating over Set for (String fruit : set) { System.out.println(fruit); } // Map Example (key-value pairs) Map<String, Integer> map = new HashMap<>(); map.put(\"Apple\", 1); map.put(\"Banana\", 2); // Iterating over Map for (Map.Entry<String, Integer> entry : map.entrySet()) { System.out.println(entry.getKey() + \": \" + entry.getValue()); } } }","title":"Collection Framework"},{"location":"java/Collection%20Framework/#collection-framework-in-java","text":"The Java Collection Framework is a unified architecture for representing and manipulating collections (groups of objects). It provides pre-built data structures like List, Set, Queue, and Map, making it easier to handle data in a structured way.","title":"Collection Framework in Java"},{"location":"java/Collection%20Framework/#core-interfaces-in-the-collection-framework","text":"","title":"Core Interfaces in the Collection Framework"},{"location":"java/Collection%20Framework/#1-collection-interface","text":"The root interface of the framework. It defines basic methods for adding, removing, and querying elements. Subinterfaces : List : An ordered collection that can contain duplicate elements. Set : A collection that cannot contain duplicate elements. Queue : A collection designed for holding elements before processing, typically in a FIFO (First-In-First-Out) order. Deque : A double-ended queue, supports adding/removing elements from both ends.","title":"1. Collection Interface"},{"location":"java/Collection%20Framework/#2-map-interface","text":"Represents a collection of key-value pairs (entries). Each key maps to exactly one value. Maps do not extend Collection .","title":"2. Map Interface"},{"location":"java/Collection%20Framework/#major-implementations","text":"","title":"Major Implementations"},{"location":"java/Collection%20Framework/#1-list-implementations","text":"ArrayList : Resizable array, allows fast random access and slower insertions/removals in the middle. LinkedList : Doubly linked list, slower access but faster insertions/removals. Vector : Synchronized version of ArrayList (rarely used in modern applications). Stack : A subclass of Vector, representing a stack data structure.","title":"1. List Implementations"},{"location":"java/Collection%20Framework/#2-set-implementations","text":"HashSet : Does not allow duplicates and does not maintain any specific order of elements. LinkedHashSet : Maintains the insertion order of elements. TreeSet : Implements a NavigableSet and orders elements based on their natural ordering or by a Comparator.","title":"2. Set Implementations"},{"location":"java/Collection%20Framework/#3-queue-implementations","text":"PriorityQueue : A queue where elements are processed based on their priority, not the order they were added. LinkedList : Can also be used as a Queue, supports FIFO operations.","title":"3. Queue Implementations"},{"location":"java/Collection%20Framework/#4-deque-implementations","text":"ArrayDeque : A resizable array implementation of the Deque interface. LinkedList : Can also be used as a Deque.","title":"4. Deque Implementations"},{"location":"java/Collection%20Framework/#5-map-implementations","text":"HashMap : A map based on hashing, does not maintain any order of elements. LinkedHashMap : Maintains the insertion order of keys. TreeMap : Implements a NavigableMap and orders keys based on their natural ordering or a Comparator.","title":"5. Map Implementations"},{"location":"java/Collection%20Framework/#useful-collection-classes","text":"Collections : A utility class providing static methods to operate on collections (like sorting, reversing, etc.). Arrays : Provides static methods to manipulate arrays, like converting an array to a list.","title":"Useful Collection Classes"},{"location":"java/Collection%20Framework/#algorithms","text":"Java Collection Framework provides several useful algorithms (like sorting, binary search) implemented in the Collections utility class: Sorting : Collections.sort(list) Shuffling : Collections.shuffle(list) Reversing : Collections.reverse(list) Binary Search : Collections.binarySearch(list, key)","title":"Algorithms"},{"location":"java/Collection%20Framework/#key-concepts","text":"Generics : Most collection classes use generics to ensure type safety (e.g., List<String> , Map<Integer, String> ). Iterator : An interface for iterating over elements in a collection. Common methods are hasNext() and next() . Autoboxing : Automatic conversion between primitive types and their corresponding wrapper classes when using collections (e.g., int to Integer ).","title":"Key Concepts"},{"location":"java/Collection%20Framework/#example-usage","text":"import java.util.*; public class CollectionExample { public static void main(String[] args) { // List Example List<String> list = new ArrayList<>(); list.add(\"Java\"); list.add(\"Python\"); list.add(\"JavaScript\"); // Iterating over List for (String lang : list) { System.out.println(lang); } // Set Example (no duplicates) Set<String> set = new HashSet<>(); set.add(\"Apple\"); set.add(\"Banana\"); set.add(\"Apple\"); // Duplicate, won't be added // Iterating over Set for (String fruit : set) { System.out.println(fruit); } // Map Example (key-value pairs) Map<String, Integer> map = new HashMap<>(); map.put(\"Apple\", 1); map.put(\"Banana\", 2); // Iterating over Map for (Map.Entry<String, Integer> entry : map.entrySet()) { System.out.println(entry.getKey() + \": \" + entry.getValue()); } } }","title":"Example Usage"},{"location":"java/Comparable%20vs%20Compartor/","text":"Comparator vs Comparable in Java 1. Comparable Interface The Comparable interface is used for defining the natural ordering of objects. It contains the method compareTo(T o) that compares the current object with another object of the same type. int compareTo(T o); The return value indicates the relative order: Negative value : Current object is less than the other. Zero : Both objects are equal. Positive value : Current object is greater than the other. Use Case : Implement this when you want the class to define its own sorting (for example, sorting by age or alphabetical order). class Person implements Comparable<Person> { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } @Override public int compareTo(Person other) { return this.age - other.age; // Sort by age } } // Usage: List<Person> people = new ArrayList<>(); people.add(new Person(\"Alice\", 30)); people.add(new Person(\"Bob\", 25)); Collections.sort(people); // Sorts by age 2. Comparator Interface The Comparator interface allows defining an external strategy for comparing two objects. It contains the method compare(T o1, T o2) for comparing two objects. int compare(T o1, T o2); // Compare two objects boolean equals(Object obj); // (Optional) Default method for equality Use Case : Implement this when you want to define multiple ways to compare objects (for example, sorting by name or by age), or when the class doesn't implement Comparable . class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } } // Comparator to sort by name class NameComparator implements Comparator<Person> { @Override public int compare(Person p1, Person p2) { return p1.getName().compareTo(p2.getName()); // Sort alphabetically by name } } // Usage: List<Person> people = new ArrayList<>(); people.add(new Person(\"Alice\", 30)); people.add(new Person(\"Bob\", 25)); // Sort by name using comparator Collections.sort(people, new NameComparator()); Key Differences: Feature Comparable Comparator Purpose Defines natural ordering of objects within the class. Defines custom ordering of objects externally. Method compareTo(T o) compare(T o1, T o2) Implementation Implemented within the class to compare objects of the same type. Implemented in a separate class or as an anonymous class. Use Case Used when there's a single way to sort objects (like sorting by age). Used when there are multiple ways to sort objects (like sorting by name or age). When to Use Which? Use Comparable for a natural, single way to sort objects. Use Comparator for defining multiple sorting strategies or when the class does not implement Comparable .","title":"Comparable vs Compartor"},{"location":"java/Comparable%20vs%20Compartor/#comparator-vs-comparable-in-java","text":"","title":"Comparator vs Comparable in Java"},{"location":"java/Comparable%20vs%20Compartor/#1-comparable-interface","text":"The Comparable interface is used for defining the natural ordering of objects. It contains the method compareTo(T o) that compares the current object with another object of the same type. int compareTo(T o); The return value indicates the relative order: Negative value : Current object is less than the other. Zero : Both objects are equal. Positive value : Current object is greater than the other. Use Case : Implement this when you want the class to define its own sorting (for example, sorting by age or alphabetical order). class Person implements Comparable<Person> { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } @Override public int compareTo(Person other) { return this.age - other.age; // Sort by age } } // Usage: List<Person> people = new ArrayList<>(); people.add(new Person(\"Alice\", 30)); people.add(new Person(\"Bob\", 25)); Collections.sort(people); // Sorts by age","title":"1. Comparable Interface"},{"location":"java/Comparable%20vs%20Compartor/#2-comparator-interface","text":"The Comparator interface allows defining an external strategy for comparing two objects. It contains the method compare(T o1, T o2) for comparing two objects. int compare(T o1, T o2); // Compare two objects boolean equals(Object obj); // (Optional) Default method for equality Use Case : Implement this when you want to define multiple ways to compare objects (for example, sorting by name or by age), or when the class doesn't implement Comparable . class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } } // Comparator to sort by name class NameComparator implements Comparator<Person> { @Override public int compare(Person p1, Person p2) { return p1.getName().compareTo(p2.getName()); // Sort alphabetically by name } } // Usage: List<Person> people = new ArrayList<>(); people.add(new Person(\"Alice\", 30)); people.add(new Person(\"Bob\", 25)); // Sort by name using comparator Collections.sort(people, new NameComparator());","title":"2. Comparator Interface"},{"location":"java/Comparable%20vs%20Compartor/#key-differences","text":"Feature Comparable Comparator Purpose Defines natural ordering of objects within the class. Defines custom ordering of objects externally. Method compareTo(T o) compare(T o1, T o2) Implementation Implemented within the class to compare objects of the same type. Implemented in a separate class or as an anonymous class. Use Case Used when there's a single way to sort objects (like sorting by age). Used when there are multiple ways to sort objects (like sorting by name or age).","title":"Key Differences:"},{"location":"java/Comparable%20vs%20Compartor/#when-to-use-which","text":"Use Comparable for a natural, single way to sort objects. Use Comparator for defining multiple sorting strategies or when the class does not implement Comparable .","title":"When to Use Which?"},{"location":"java/Constructor/","text":"Constructor in Java A constructor in Java is a special method used to initialize objects. It is called when an object of a class is created. A constructor has the same name as the class and does not have a return type. Syntax: class ClassName { // Constructor ClassName() { // Initialization code } } Example: class Person { String name; int age; // Constructor Person(String name, int age) { this.name = name; this.age = age; } // Method to display values void display() { System.out.println(\"Name: \" + name + \", Age: \" + age); } } public class Main { public static void main(String[] args) { // Creating an object of Person class using the constructor Person p1 = new Person(\"John\", 25); p1.display(); } } Types of Constructors: 1. Default Constructor A constructor with no parameters. If no constructor is defined, Java provides a default constructor. class Person { String name; int age; // Default Constructor Person() { name = \"Unknown\"; age = 0; } void display() { System.out.println(\"Name: \" + name + \", Age: \" + age); } } 2. Parameterized Constructor A constructor that accepts parameters to initialize object properties with specific values. class Person { String name; int age; // Parameterized Constructor Person(String name, int age) { this.name = name; this.age = age; } void display() { System.out.println(\"Name: \" + name + \", Age: \" + age); } } 3. No-Argument Constructor A constructor with no arguments. This is the same as the default constructor and is automatically provided by Java if no constructor is defined. class Car { String brand; // No-argument constructor Car() { brand = \"Unknown\"; } void display() { System.out.println(\"Brand: \" + brand); } } public class Main { public static void main(String[] args) { Car car = new Car(); car.display(); // Output: Brand: Unknown } } 4. Copy Constructor A constructor that creates a new object by copying the properties of an existing object of the same class. It is used for cloning an object. class Book { String title; String author; // Constructor to initialize Book object Book(String title, String author) { this.title = title; this.author = author; } // Copy Constructor Book(Book book) { this.title = book.title; this.author = book.author; } void display() { System.out.println(\"Title: \" + title + \", Author: \" + author); } } public class Main { public static void main(String[] args) { Book originalBook = new Book(\"1984\", \"George Orwell\"); Book copiedBook = new Book(originalBook); // Using copy constructor copiedBook.display(); // Output: Title: 1984, Author: George Orwell } }","title":"Constructor"},{"location":"java/Constructor/#constructor-in-java","text":"A constructor in Java is a special method used to initialize objects. It is called when an object of a class is created. A constructor has the same name as the class and does not have a return type.","title":"Constructor in Java"},{"location":"java/Constructor/#syntax","text":"class ClassName { // Constructor ClassName() { // Initialization code } } Example: class Person { String name; int age; // Constructor Person(String name, int age) { this.name = name; this.age = age; } // Method to display values void display() { System.out.println(\"Name: \" + name + \", Age: \" + age); } } public class Main { public static void main(String[] args) { // Creating an object of Person class using the constructor Person p1 = new Person(\"John\", 25); p1.display(); } }","title":"Syntax:"},{"location":"java/Constructor/#types-of-constructors","text":"","title":"Types of Constructors:"},{"location":"java/Constructor/#1-default-constructor","text":"A constructor with no parameters. If no constructor is defined, Java provides a default constructor. class Person { String name; int age; // Default Constructor Person() { name = \"Unknown\"; age = 0; } void display() { System.out.println(\"Name: \" + name + \", Age: \" + age); } }","title":"1. Default Constructor"},{"location":"java/Constructor/#2-parameterized-constructor","text":"A constructor that accepts parameters to initialize object properties with specific values. class Person { String name; int age; // Parameterized Constructor Person(String name, int age) { this.name = name; this.age = age; } void display() { System.out.println(\"Name: \" + name + \", Age: \" + age); } }","title":"2. Parameterized Constructor"},{"location":"java/Constructor/#3-no-argument-constructor","text":"A constructor with no arguments. This is the same as the default constructor and is automatically provided by Java if no constructor is defined. class Car { String brand; // No-argument constructor Car() { brand = \"Unknown\"; } void display() { System.out.println(\"Brand: \" + brand); } } public class Main { public static void main(String[] args) { Car car = new Car(); car.display(); // Output: Brand: Unknown } }","title":"3. No-Argument Constructor"},{"location":"java/Constructor/#4-copy-constructor","text":"A constructor that creates a new object by copying the properties of an existing object of the same class. It is used for cloning an object. class Book { String title; String author; // Constructor to initialize Book object Book(String title, String author) { this.title = title; this.author = author; } // Copy Constructor Book(Book book) { this.title = book.title; this.author = book.author; } void display() { System.out.println(\"Title: \" + title + \", Author: \" + author); } } public class Main { public static void main(String[] args) { Book originalBook = new Book(\"1984\", \"George Orwell\"); Book copiedBook = new Book(originalBook); // Using copy constructor copiedBook.display(); // Output: Title: 1984, Author: George Orwell } }","title":"4. Copy Constructor"},{"location":"java/DataType/","text":"Data Types in Java In Java, data types are divided into two main categories: Primitive Data Types and Reference Data Types . 1. Primitive Data Types These are the most basic data types in Java, representing simple values. There are 8 primitive data types: byte : 8-bit integer (range: -128 to 127) short : 16-bit integer (range: -32,768 to 32,767) int : 32-bit integer (range: -2^31 to 2^31-1) long : 64-bit integer (range: -2^63 to 2^63-1) float : 32-bit floating-point number (approx. \u00b13.40282347E+38F) double : 64-bit floating-point number (approx. \u00b11.7976931348623157E+308) char : 16-bit Unicode character (range: 0 to 65,535) boolean : Represents true or false values 2. Reference Data Types These refer to objects and arrays. They are not actual values but references to objects in memory. Reference data types include: Classes : Custom data types defined by the user. Interfaces : Abstract types used to define method contracts. Arrays : Homogeneous collections of data (e.g., int[] , String[] ). Strings : A special type that holds sequences of characters (e.g., \"Hello\" ). Example: int num = 100; // Primitive data type (int) String name = \"John\"; // Reference data type (String)","title":"Data Type"},{"location":"java/DataType/#data-types-in-java","text":"In Java, data types are divided into two main categories: Primitive Data Types and Reference Data Types .","title":"Data Types in Java"},{"location":"java/DataType/#1-primitive-data-types","text":"These are the most basic data types in Java, representing simple values. There are 8 primitive data types: byte : 8-bit integer (range: -128 to 127) short : 16-bit integer (range: -32,768 to 32,767) int : 32-bit integer (range: -2^31 to 2^31-1) long : 64-bit integer (range: -2^63 to 2^63-1) float : 32-bit floating-point number (approx. \u00b13.40282347E+38F) double : 64-bit floating-point number (approx. \u00b11.7976931348623157E+308) char : 16-bit Unicode character (range: 0 to 65,535) boolean : Represents true or false values","title":"1. Primitive Data Types"},{"location":"java/DataType/#2-reference-data-types","text":"These refer to objects and arrays. They are not actual values but references to objects in memory. Reference data types include: Classes : Custom data types defined by the user. Interfaces : Abstract types used to define method contracts. Arrays : Homogeneous collections of data (e.g., int[] , String[] ). Strings : A special type that holds sequences of characters (e.g., \"Hello\" ).","title":"2. Reference Data Types"},{"location":"java/DataType/#example","text":"int num = 100; // Primitive data type (int) String name = \"John\"; // Reference data type (String)","title":"Example:"},{"location":"java/Exception%20in%20Java/","text":"Exception in Java An exception in Java is an event that disrupts the normal flow of the program's execution. It can occur due to a variety of reasons, such as invalid input, attempting to divide by zero, file errors, or network issues. When an exception occurs, Java creates an Exception object and throws it. Types of Exceptions 1. Checked Exceptions These are exceptions that must be explicitly handled by the programmer using a try-catch block or declared using the throws keyword. Examples include IOException , SQLException . 2. Unchecked Exceptions These are exceptions that are not required to be caught or declared thrown. They inherit from RuntimeException and include exceptions such as NullPointerException , ArrayIndexOutOfBoundsException , and ArithmeticException . Handling Exceptions 1. Try-Catch Block It allows you to handle exceptions and prevent the program from crashing. try { // Code that might throw an exception int result = 10 / 0; // This will throw ArithmeticException } catch (ArithmeticException e) { // Handle the exception System.out.println(\"Error: \" + e.getMessage()); } 2. Finally Block The finally block is optional and is used for code that must be executed regardless of whether an exception occurred or not, such as closing resources. try { // Code that might throw an exception } catch (Exception e) { // Handle the exception } finally { // Cleanup code System.out.println(\"This will always execute\"); } 3. Throws Clause If a method can throw an exception, you can declare it using the throws keyword. public void readFile() throws IOException { // Code that may throw IOException }","title":"Exception in Java"},{"location":"java/Exception%20in%20Java/#exception-in-java","text":"An exception in Java is an event that disrupts the normal flow of the program's execution. It can occur due to a variety of reasons, such as invalid input, attempting to divide by zero, file errors, or network issues. When an exception occurs, Java creates an Exception object and throws it.","title":"Exception in Java"},{"location":"java/Exception%20in%20Java/#types-of-exceptions","text":"","title":"Types of Exceptions"},{"location":"java/Exception%20in%20Java/#1-checked-exceptions","text":"These are exceptions that must be explicitly handled by the programmer using a try-catch block or declared using the throws keyword. Examples include IOException , SQLException .","title":"1. Checked Exceptions"},{"location":"java/Exception%20in%20Java/#2-unchecked-exceptions","text":"These are exceptions that are not required to be caught or declared thrown. They inherit from RuntimeException and include exceptions such as NullPointerException , ArrayIndexOutOfBoundsException , and ArithmeticException .","title":"2. Unchecked Exceptions"},{"location":"java/Exception%20in%20Java/#handling-exceptions","text":"","title":"Handling Exceptions"},{"location":"java/Exception%20in%20Java/#1-try-catch-block","text":"It allows you to handle exceptions and prevent the program from crashing. try { // Code that might throw an exception int result = 10 / 0; // This will throw ArithmeticException } catch (ArithmeticException e) { // Handle the exception System.out.println(\"Error: \" + e.getMessage()); }","title":"1. Try-Catch Block"},{"location":"java/Exception%20in%20Java/#2-finally-block","text":"The finally block is optional and is used for code that must be executed regardless of whether an exception occurred or not, such as closing resources. try { // Code that might throw an exception } catch (Exception e) { // Handle the exception } finally { // Cleanup code System.out.println(\"This will always execute\"); }","title":"2. Finally Block"},{"location":"java/Exception%20in%20Java/#3-throws-clause","text":"If a method can throw an exception, you can declare it using the throws keyword. public void readFile() throws IOException { // Code that may throw IOException }","title":"3. Throws Clause"},{"location":"java/FunctionalInterface/","text":"Functional Interface A Functional Interface in Java is an interface that contains exactly one abstract method. These interfaces can have multiple default or static methods, but they must have only one abstract method. Functional interfaces are intended to be used primarily with lambda expressions or method references. Example: @FunctionalInterface interface Calculator { int add(int a, int b); // Abstract method // Default method default int subtract(int a, int b) { return a - b; } } public class Main { public static void main(String[] args) { // Using lambda expression Calculator calc = (a, b) -> a + b; System.out.println(\"Sum: \" + calc.add(5, 3)); System.out.println(\"Subtraction: \" + calc.subtract(5, 3)); } } Common functional interfaces: 1. Runnable Runnable represents a task that can be executed asynchronously. It has a single abstract method run(), which does not accept any arguments and does not return a result. public class RunnableExample { public static void main(String[] args) { Runnable runnable = () -> System.out.println(\"Task is running\"); new Thread(runnable).start(); // Running the task in a separate thread } } 2. Predicate Predicate is used for evaluating a condition. It accepts one argument of type T and returns a boolean value. import java.util.function.Predicate; public class PredicateExample { public static void main(String[] args) { Predicate<Integer> isEven = (number) -> number % 2 == 0; System.out.println(isEven.test(4)); // true System.out.println(isEven.test(5)); // false } } 3. Function Function takes one argument of type T and returns a result of type R. It is commonly used for transforming data. import java.util.function.Function; public class FunctionExample { public static void main(String[] args) { Function<String, Integer> stringLength = (str) -> str.length(); System.out.println(stringLength.apply(\"Hello\")); // 5 } } 4. Consumer Consumer represents an operation that accepts a single argument of type T and returns no result. It is typically used for performing operations such as printing or modifying a value. import java.util.function.Consumer; public class ConsumerExample { public static void main(String[] args) { Consumer<String> printMessage = (message) -> System.out.println(message); printMessage.accept(\"Hello, World!\"); // Output: Hello, World! } } 5. Supplier Supplier represents a supplier of results. It does not take any arguments but returns a result of type T. import java.util.function.Supplier; public class SupplierExample { public static void main(String[] args) { Supplier<Double> randomNumber = () -> Math.random(); System.out.println(randomNumber.get()); // Generates a random number } }","title":"Functional Interface"},{"location":"java/FunctionalInterface/#functional-interface","text":"A Functional Interface in Java is an interface that contains exactly one abstract method. These interfaces can have multiple default or static methods, but they must have only one abstract method. Functional interfaces are intended to be used primarily with lambda expressions or method references. Example: @FunctionalInterface interface Calculator { int add(int a, int b); // Abstract method // Default method default int subtract(int a, int b) { return a - b; } } public class Main { public static void main(String[] args) { // Using lambda expression Calculator calc = (a, b) -> a + b; System.out.println(\"Sum: \" + calc.add(5, 3)); System.out.println(\"Subtraction: \" + calc.subtract(5, 3)); } }","title":"Functional Interface"},{"location":"java/FunctionalInterface/#common-functional-interfaces","text":"","title":"Common functional interfaces:"},{"location":"java/FunctionalInterface/#1-runnable","text":"Runnable represents a task that can be executed asynchronously. It has a single abstract method run(), which does not accept any arguments and does not return a result. public class RunnableExample { public static void main(String[] args) { Runnable runnable = () -> System.out.println(\"Task is running\"); new Thread(runnable).start(); // Running the task in a separate thread } }","title":"1. Runnable"},{"location":"java/FunctionalInterface/#2-predicate","text":"Predicate is used for evaluating a condition. It accepts one argument of type T and returns a boolean value. import java.util.function.Predicate; public class PredicateExample { public static void main(String[] args) { Predicate<Integer> isEven = (number) -> number % 2 == 0; System.out.println(isEven.test(4)); // true System.out.println(isEven.test(5)); // false } }","title":"2. Predicate"},{"location":"java/FunctionalInterface/#3-function","text":"Function takes one argument of type T and returns a result of type R. It is commonly used for transforming data. import java.util.function.Function; public class FunctionExample { public static void main(String[] args) { Function<String, Integer> stringLength = (str) -> str.length(); System.out.println(stringLength.apply(\"Hello\")); // 5 } }","title":"3. Function"},{"location":"java/FunctionalInterface/#4-consumer","text":"Consumer represents an operation that accepts a single argument of type T and returns no result. It is typically used for performing operations such as printing or modifying a value. import java.util.function.Consumer; public class ConsumerExample { public static void main(String[] args) { Consumer<String> printMessage = (message) -> System.out.println(message); printMessage.accept(\"Hello, World!\"); // Output: Hello, World! } }","title":"4. Consumer"},{"location":"java/FunctionalInterface/#5-supplier","text":"Supplier represents a supplier of results. It does not take any arguments but returns a result of type T. import java.util.function.Supplier; public class SupplierExample { public static void main(String[] args) { Supplier<Double> randomNumber = () -> Math.random(); System.out.println(randomNumber.get()); // Generates a random number } }","title":"5. Supplier"},{"location":"java/Garbage%20Collector/","text":"Understanding Garbage Collection in Java The Garbage Collector (GC) in Java is responsible for automatically managing memory by reclaiming memory occupied by objects that are no longer in use. This helps prevent memory leaks and ensures that the application does not run out of memory. How the Garbage Collector Works Heap Memory The heap is where all objects in Java are allocated. The heap is divided into Young Generation and Old Generation : Young Generation : Contains recently created objects. Old Generation : Contains objects that have been around for a while and survived multiple garbage collection cycles. Mark-and-Sweep Algorithm The GC uses a Mark-and-Sweep algorithm to identify and reclaim memory. Mark Phase : The GC identifies which objects are still in use (reachable from root objects such as local variables, static variables, and active threads). Sweep Phase : The GC removes objects that are no longer reachable (i.e., not marked during the mark phase). Generational Garbage Collection Objects are initially allocated in the Young Generation . After surviving several collections, objects are promoted to the Old Generation . This is based on the observation that most objects are short-lived (like temporary variables), and collecting them separately from longer-lived objects is more efficient. Garbage Collection Phases Minor GC : Occurs when the Young Generation is full. It involves collecting only the Young Generation, which is relatively fast. Major GC (Full GC) : Involves both the Young and Old Generations . It happens less frequently but is more expensive because it has to scan all objects in the heap. Types of Garbage Collectors Serial Garbage Collector ( -XX:+UseSerialGC ): Single-threaded collector that is simple and used for small applications or single-core machines. Parallel Garbage Collector (Throughput Collector) ( -XX:+UseParallelGC ): Uses multiple threads to perform garbage collection in parallel, improving throughput on multi-core systems. CMS (Concurrent Mark-Sweep) Garbage Collector ( -XX:+UseConcMarkSweepGC ): Performs most of its work concurrently with the application threads, minimizing pauses but is more complex. G1 Garbage Collector (Garbage First) ( -XX:+UseG1GC ): Designed for large heaps, it divides the heap into regions and performs collection in a way that can prioritize low pause times. ZGC (Z Garbage Collector) ( -XX:+UseZGC ): A low-latency collector that performs garbage collection with minimal pauses, suitable for applications requiring low latency. Shenandoah GC ( -XX:+UseShenandoahGC ): Another low-latency collector similar to ZGC, focused on reducing pause times. Garbage Collection Process Minor GC : Occurs when the Young Generation is full. Objects that survive the collection are promoted to the Old Generation . Major GC (Full GC) : Occurs less frequently but is more expensive. It collects both Young and Old Generations . The old generation objects are moved to a \"free list\" or compacted to reduce fragmentation. Stop-the-World Events : During GC, application threads may be paused (known as Stop-the-World). These pauses can be short (in the case of Minor GC) or longer (in the case of Major GC), depending on the collector and heap size. Garbage Collection Tuning You can control various aspects of garbage collection to optimize performance using JVM options. For example: Set the heap size : bash -Xms1024m -Xmx2048m Set the garbage collector to use: bash -XX:+UseG1GC Control the Young Generation size : bash -XX:NewSize=512m -XX:MaxNewSize=1024m Enable verbose GC logging : bash -XX:+PrintGCDetails -Xloggc:gc.log Common Garbage Collection Issues Long Garbage Collection Pauses : If the GC pauses are too long, it can affect application performance. This is common with Major GC or Full GC. Solution : Use a low-latency GC (like G1, ZGC, or Shenandoah) or optimize heap sizes. Memory Leaks : While Java has garbage collection, memory leaks can still happen if objects are unintentionally retained, preventing the GC from reclaiming memory. Solution : Use tools like VisualVM, Eclipse MAT, or JProfiler to identify memory leaks. OutOfMemoryError : If the heap is exhausted, Java will throw an OutOfMemoryError . Solution : Monitor memory usage and ensure the heap size is adequate for your application. Final Thoughts The Garbage Collector helps manage memory by automatically cleaning up unused objects. Understanding its working mechanism, different collectors, and the tuning options allows you to write efficient Java applications while reducing memory-related issues.","title":"Garbage Collector"},{"location":"java/Garbage%20Collector/#understanding-garbage-collection-in-java","text":"The Garbage Collector (GC) in Java is responsible for automatically managing memory by reclaiming memory occupied by objects that are no longer in use. This helps prevent memory leaks and ensures that the application does not run out of memory.","title":"Understanding Garbage Collection in Java"},{"location":"java/Garbage%20Collector/#how-the-garbage-collector-works","text":"","title":"How the Garbage Collector Works"},{"location":"java/Garbage%20Collector/#heap-memory","text":"The heap is where all objects in Java are allocated. The heap is divided into Young Generation and Old Generation : Young Generation : Contains recently created objects. Old Generation : Contains objects that have been around for a while and survived multiple garbage collection cycles.","title":"Heap Memory"},{"location":"java/Garbage%20Collector/#mark-and-sweep-algorithm","text":"The GC uses a Mark-and-Sweep algorithm to identify and reclaim memory. Mark Phase : The GC identifies which objects are still in use (reachable from root objects such as local variables, static variables, and active threads). Sweep Phase : The GC removes objects that are no longer reachable (i.e., not marked during the mark phase).","title":"Mark-and-Sweep Algorithm"},{"location":"java/Garbage%20Collector/#generational-garbage-collection","text":"Objects are initially allocated in the Young Generation . After surviving several collections, objects are promoted to the Old Generation . This is based on the observation that most objects are short-lived (like temporary variables), and collecting them separately from longer-lived objects is more efficient.","title":"Generational Garbage Collection"},{"location":"java/Garbage%20Collector/#garbage-collection-phases","text":"Minor GC : Occurs when the Young Generation is full. It involves collecting only the Young Generation, which is relatively fast. Major GC (Full GC) : Involves both the Young and Old Generations . It happens less frequently but is more expensive because it has to scan all objects in the heap.","title":"Garbage Collection Phases"},{"location":"java/Garbage%20Collector/#types-of-garbage-collectors","text":"Serial Garbage Collector ( -XX:+UseSerialGC ): Single-threaded collector that is simple and used for small applications or single-core machines. Parallel Garbage Collector (Throughput Collector) ( -XX:+UseParallelGC ): Uses multiple threads to perform garbage collection in parallel, improving throughput on multi-core systems. CMS (Concurrent Mark-Sweep) Garbage Collector ( -XX:+UseConcMarkSweepGC ): Performs most of its work concurrently with the application threads, minimizing pauses but is more complex. G1 Garbage Collector (Garbage First) ( -XX:+UseG1GC ): Designed for large heaps, it divides the heap into regions and performs collection in a way that can prioritize low pause times. ZGC (Z Garbage Collector) ( -XX:+UseZGC ): A low-latency collector that performs garbage collection with minimal pauses, suitable for applications requiring low latency. Shenandoah GC ( -XX:+UseShenandoahGC ): Another low-latency collector similar to ZGC, focused on reducing pause times.","title":"Types of Garbage Collectors"},{"location":"java/Garbage%20Collector/#garbage-collection-process","text":"Minor GC : Occurs when the Young Generation is full. Objects that survive the collection are promoted to the Old Generation . Major GC (Full GC) : Occurs less frequently but is more expensive. It collects both Young and Old Generations . The old generation objects are moved to a \"free list\" or compacted to reduce fragmentation. Stop-the-World Events : During GC, application threads may be paused (known as Stop-the-World). These pauses can be short (in the case of Minor GC) or longer (in the case of Major GC), depending on the collector and heap size.","title":"Garbage Collection Process"},{"location":"java/Garbage%20Collector/#garbage-collection-tuning","text":"You can control various aspects of garbage collection to optimize performance using JVM options. For example: Set the heap size : bash -Xms1024m -Xmx2048m Set the garbage collector to use: bash -XX:+UseG1GC Control the Young Generation size : bash -XX:NewSize=512m -XX:MaxNewSize=1024m Enable verbose GC logging : bash -XX:+PrintGCDetails -Xloggc:gc.log","title":"Garbage Collection Tuning"},{"location":"java/Garbage%20Collector/#common-garbage-collection-issues","text":"Long Garbage Collection Pauses : If the GC pauses are too long, it can affect application performance. This is common with Major GC or Full GC. Solution : Use a low-latency GC (like G1, ZGC, or Shenandoah) or optimize heap sizes. Memory Leaks : While Java has garbage collection, memory leaks can still happen if objects are unintentionally retained, preventing the GC from reclaiming memory. Solution : Use tools like VisualVM, Eclipse MAT, or JProfiler to identify memory leaks. OutOfMemoryError : If the heap is exhausted, Java will throw an OutOfMemoryError . Solution : Monitor memory usage and ensure the heap size is adequate for your application.","title":"Common Garbage Collection Issues"},{"location":"java/Garbage%20Collector/#final-thoughts","text":"The Garbage Collector helps manage memory by automatically cleaning up unused objects. Understanding its working mechanism, different collectors, and the tuning options allows you to write efficient Java applications while reducing memory-related issues.","title":"Final Thoughts"},{"location":"java/Generics/","text":"Generics in Java Basic Concepts of Generics: 1. Generic Classes: A generic class is defined with a type parameter, allowing you to create classes that can work with any data type while maintaining type safety. The class will operate on the specified type, which can vary depending on how the class is instantiated. class Container<T> { private T item; public Container(T item) { this.item = item; } public T getItem() { return item; } } public class GenericExample { public static void main(String[] args) { System.out.println(new Container<>(42).getItem()); // Output: 42 System.out.println(new Container<>(\"Hello\").getItem()); // Output: Hello } } 2. Generic Methods: Methods can also be made generic by defining type parameters that allow them to work with any type. This enables the method to perform operations on different types while ensuring that the operations are type-safe. public class GenericMethodExample { public static <T> void printArray(T[] array) { for (T element : array) { System.out.println(element); } } public static void main(String[] args) { Integer[] intArray = {1, 2, 3}; String[] strArray = {\"A\", \"B\", \"C\"}; printArray(intArray); // Output: 1 2 3 printArray(strArray); // Output: A B C } } 3. Bounded Type Parameters: You can restrict the types that can be used in place of the generic type by specifying an upper bound. This ensures that only types that extend a certain class (or implement an interface) can be used. public class BoundedExample { public static <T extends Number> void printNumber(T number) { System.out.println(number); } public static void main(String[] args) { printNumber(10); // Output: 10 printNumber(5.5); // Output: 5.5 // printNumber(\"Hello\"); // Error: String is not a subtype of Number } } 4. Wildcard in Generics: Wildcards are used when the type is not known or when it can vary. There are different types of wildcards: - Unbounded Wildcard ( ? ) : Represents any type. - Upper Bounded Wildcard ( ? extends T ) : Represents any type that is a subtype of T . - Lower Bounded Wildcard ( ? super T ) : Represents any type that is a supertype of T . public class WildcardExample { public static void printList(List<?> list) { for (Object obj : list) { System.out.println(obj); } } public static void main(String[] args) { List<Integer> intList = List.of(1, 2, 3); List<String> strList = List.of(\"A\", \"B\", \"C\"); printList(intList); // Output: 1 2 3 printList(strList); // Output: A B C } } 5. Generic Interfaces: Like classes, interfaces can also be generic, allowing you to define methods and properties that operate on different types. The type is defined at the time of instantiating the implementing class. public interface Pair<K, V> { K getKey(); V getValue(); } public class SimplePair<K, V> implements Pair<K, V> { private K key; private V value; public SimplePair(K key, V value) { this.key = key; this.value = value; } @Override public K getKey() { return key; } @Override public V getValue() { return value; } public static void main(String[] args) { Pair<Integer, String> pair = new SimplePair<>(1, \"One\"); System.out.println(pair.getKey() + \" : \" + pair.getValue()); // Output: 1 : One } } Advantages of Generics: Type Safety: Generics help catch type errors at compile time rather than runtime, reducing potential bugs related to type casting. Reusability: Generic classes and methods can be used with any data type, which helps avoid writing the same code multiple times. Readability: Generics make code easier to read and understand by explicitly stating the type of data being operated on. Commonly Used Generic Classes in Java: List : A collection of elements of type T , typically ordered. Map : A collection of key-value pairs, where K is the key type and V is the value type. Set : A collection of unique elements of type T . Generics are a key feature in Java that help create flexible and type-safe code by allowing operations on various data types while maintaining strict type checks at compile time.","title":"Generics"},{"location":"java/Generics/#generics-in-java","text":"","title":"Generics in Java"},{"location":"java/Generics/#basic-concepts-of-generics","text":"","title":"Basic Concepts of Generics:"},{"location":"java/Generics/#1-generic-classes","text":"A generic class is defined with a type parameter, allowing you to create classes that can work with any data type while maintaining type safety. The class will operate on the specified type, which can vary depending on how the class is instantiated. class Container<T> { private T item; public Container(T item) { this.item = item; } public T getItem() { return item; } } public class GenericExample { public static void main(String[] args) { System.out.println(new Container<>(42).getItem()); // Output: 42 System.out.println(new Container<>(\"Hello\").getItem()); // Output: Hello } }","title":"1. Generic Classes:"},{"location":"java/Generics/#2-generic-methods","text":"Methods can also be made generic by defining type parameters that allow them to work with any type. This enables the method to perform operations on different types while ensuring that the operations are type-safe. public class GenericMethodExample { public static <T> void printArray(T[] array) { for (T element : array) { System.out.println(element); } } public static void main(String[] args) { Integer[] intArray = {1, 2, 3}; String[] strArray = {\"A\", \"B\", \"C\"}; printArray(intArray); // Output: 1 2 3 printArray(strArray); // Output: A B C } }","title":"2. Generic Methods:"},{"location":"java/Generics/#3-bounded-type-parameters","text":"You can restrict the types that can be used in place of the generic type by specifying an upper bound. This ensures that only types that extend a certain class (or implement an interface) can be used. public class BoundedExample { public static <T extends Number> void printNumber(T number) { System.out.println(number); } public static void main(String[] args) { printNumber(10); // Output: 10 printNumber(5.5); // Output: 5.5 // printNumber(\"Hello\"); // Error: String is not a subtype of Number } }","title":"3. Bounded Type Parameters:"},{"location":"java/Generics/#4-wildcard-in-generics","text":"Wildcards are used when the type is not known or when it can vary. There are different types of wildcards: - Unbounded Wildcard ( ? ) : Represents any type. - Upper Bounded Wildcard ( ? extends T ) : Represents any type that is a subtype of T . - Lower Bounded Wildcard ( ? super T ) : Represents any type that is a supertype of T . public class WildcardExample { public static void printList(List<?> list) { for (Object obj : list) { System.out.println(obj); } } public static void main(String[] args) { List<Integer> intList = List.of(1, 2, 3); List<String> strList = List.of(\"A\", \"B\", \"C\"); printList(intList); // Output: 1 2 3 printList(strList); // Output: A B C } }","title":"4. Wildcard in Generics:"},{"location":"java/Generics/#5-generic-interfaces","text":"Like classes, interfaces can also be generic, allowing you to define methods and properties that operate on different types. The type is defined at the time of instantiating the implementing class. public interface Pair<K, V> { K getKey(); V getValue(); } public class SimplePair<K, V> implements Pair<K, V> { private K key; private V value; public SimplePair(K key, V value) { this.key = key; this.value = value; } @Override public K getKey() { return key; } @Override public V getValue() { return value; } public static void main(String[] args) { Pair<Integer, String> pair = new SimplePair<>(1, \"One\"); System.out.println(pair.getKey() + \" : \" + pair.getValue()); // Output: 1 : One } }","title":"5. Generic Interfaces:"},{"location":"java/Generics/#advantages-of-generics","text":"Type Safety: Generics help catch type errors at compile time rather than runtime, reducing potential bugs related to type casting. Reusability: Generic classes and methods can be used with any data type, which helps avoid writing the same code multiple times. Readability: Generics make code easier to read and understand by explicitly stating the type of data being operated on.","title":"Advantages of Generics:"},{"location":"java/Generics/#commonly-used-generic-classes-in-java","text":"List : A collection of elements of type T , typically ordered. Map : A collection of key-value pairs, where K is the key type and V is the value type. Set : A collection of unique elements of type T . Generics are a key feature in Java that help create flexible and type-safe code by allowing operations on various data types while maintaining strict type checks at compile time.","title":"Commonly Used Generic Classes in Java:"},{"location":"java/Hashmap/","text":"Working of HashMap in Java A HashMap in Java is a data structure that stores key-value pairs. Each key in the HashMap is unique, and it is associated with a specific value. It is part of the java.util package and implements the Map interface. Key Concepts of HashMap 1. Buckets Internally, a HashMap uses an array of buckets (also known as \"bins\" or \"slots\"). These buckets are used to store the key-value pairs. The bucket size refers to the number of available buckets in the underlying array. When a key-value pair is inserted into the HashMap, the bucket index is determined based on the hash code of the key, which is calculated by the hashCode() method. The bucket index is then computed as: bucket index = hashCode(key) % bucket size . Bucket size is an internal property that can be configured but typically defaults to 16 in many implementations of HashMap. When the number of entries in the HashMap exceeds the load factor multiplied by the current bucket size, the bucket size will increase, typically doubling. 2. Hashing Hash Code Calculation : When you insert a key-value pair into the HashMap, the hash code of the key is computed. The hash code is a number that is used to determine which bucket the key-value pair should be stored in. The hash code is then mapped to an index in the array of buckets. The formula used is: bucket index = hashCode(key) % bucket size . For example, if the hash code of a key is 123 and the bucket size is 16 , the index will be: bucket index = 123 % 16 = 11 . This means the key-value pair will be stored in bucket 11. 3. Collisions Collision Handling : If two or more keys have the same hash code (i.e., they map to the same bucket), it leads to a collision . In this case, the HashMap stores these key-value pairs in a linked list (or tree if the collisions are high) at the same bucket index. When retrieving or updating values, HashMap traverses the linked list or tree to find the correct key-value pair. 4. Insertion put(key, value) : When you add a key-value pair, the key\u2019s hash code is calculated, and the pair is stored in the appropriate bucket based on the index derived from the hash code. If the key already exists, the value is updated with the new one. If it's a new key, the pair is added to the HashMap. 5. Retrieving get(key) : To retrieve a value, the HashMap calculates the hash code of the key, finds the appropriate bucket, and searches for the key in that bucket (either in the linked list or tree). If the key is found, the corresponding value is returned. 6. Removing remove(key) : To remove a key-value pair, the HashMap calculates the hash code for the key, finds the appropriate bucket, and removes the pair from the linked list or tree at that bucket index. 7. Resize (Rehashing) Load Factor : A load factor determines when the HashMap should resize (rehash) the buckets. The default load factor is 0.75, meaning when 75% of the current bucket size is filled, the HashMap will resize the array of buckets. Rehashing : When the bucket size exceeds the threshold (load factor * current bucket size), the HashMap resizes the array, typically doubling the bucket size. All existing key-value pairs are rehashed and redistributed into the new array of buckets, ensuring even distribution and avoiding too many collisions. Example import java.util.HashMap; public class HashMapExample { public static void main(String[] args) { // Create a HashMap instance with a default initial capacity of 16 buckets HashMap<String, Integer> map = new HashMap<>(); // Insert key-value pairs map.put(\"Apple\", 5); map.put(\"Banana\", 7); map.put(\"Orange\", 3); // Retrieve a value based on key System.out.println(\"Apple's count: \" + map.get(\"Apple\")); // Output: 5 // Update a value map.put(\"Apple\", 10); System.out.println(\"Updated Apple's count: \" + map.get(\"Apple\")); // Output: 10 // Remove a key-value pair map.remove(\"Banana\"); // Check if a key exists System.out.println(\"Contains 'Banana'? \" + map.containsKey(\"Banana\")); // Output: false } }","title":"Hashmap"},{"location":"java/Hashmap/#working-of-hashmap-in-java","text":"A HashMap in Java is a data structure that stores key-value pairs. Each key in the HashMap is unique, and it is associated with a specific value. It is part of the java.util package and implements the Map interface.","title":"Working of HashMap in Java"},{"location":"java/Hashmap/#key-concepts-of-hashmap","text":"","title":"Key Concepts of HashMap"},{"location":"java/Hashmap/#1-buckets","text":"Internally, a HashMap uses an array of buckets (also known as \"bins\" or \"slots\"). These buckets are used to store the key-value pairs. The bucket size refers to the number of available buckets in the underlying array. When a key-value pair is inserted into the HashMap, the bucket index is determined based on the hash code of the key, which is calculated by the hashCode() method. The bucket index is then computed as: bucket index = hashCode(key) % bucket size . Bucket size is an internal property that can be configured but typically defaults to 16 in many implementations of HashMap. When the number of entries in the HashMap exceeds the load factor multiplied by the current bucket size, the bucket size will increase, typically doubling.","title":"1. Buckets"},{"location":"java/Hashmap/#2-hashing","text":"Hash Code Calculation : When you insert a key-value pair into the HashMap, the hash code of the key is computed. The hash code is a number that is used to determine which bucket the key-value pair should be stored in. The hash code is then mapped to an index in the array of buckets. The formula used is: bucket index = hashCode(key) % bucket size . For example, if the hash code of a key is 123 and the bucket size is 16 , the index will be: bucket index = 123 % 16 = 11 . This means the key-value pair will be stored in bucket 11.","title":"2. Hashing"},{"location":"java/Hashmap/#3-collisions","text":"Collision Handling : If two or more keys have the same hash code (i.e., they map to the same bucket), it leads to a collision . In this case, the HashMap stores these key-value pairs in a linked list (or tree if the collisions are high) at the same bucket index. When retrieving or updating values, HashMap traverses the linked list or tree to find the correct key-value pair.","title":"3. Collisions"},{"location":"java/Hashmap/#4-insertion","text":"put(key, value) : When you add a key-value pair, the key\u2019s hash code is calculated, and the pair is stored in the appropriate bucket based on the index derived from the hash code. If the key already exists, the value is updated with the new one. If it's a new key, the pair is added to the HashMap.","title":"4. Insertion"},{"location":"java/Hashmap/#5-retrieving","text":"get(key) : To retrieve a value, the HashMap calculates the hash code of the key, finds the appropriate bucket, and searches for the key in that bucket (either in the linked list or tree). If the key is found, the corresponding value is returned.","title":"5. Retrieving"},{"location":"java/Hashmap/#6-removing","text":"remove(key) : To remove a key-value pair, the HashMap calculates the hash code for the key, finds the appropriate bucket, and removes the pair from the linked list or tree at that bucket index.","title":"6. Removing"},{"location":"java/Hashmap/#7-resize-rehashing","text":"Load Factor : A load factor determines when the HashMap should resize (rehash) the buckets. The default load factor is 0.75, meaning when 75% of the current bucket size is filled, the HashMap will resize the array of buckets. Rehashing : When the bucket size exceeds the threshold (load factor * current bucket size), the HashMap resizes the array, typically doubling the bucket size. All existing key-value pairs are rehashed and redistributed into the new array of buckets, ensuring even distribution and avoiding too many collisions.","title":"7. Resize (Rehashing)"},{"location":"java/Hashmap/#example","text":"import java.util.HashMap; public class HashMapExample { public static void main(String[] args) { // Create a HashMap instance with a default initial capacity of 16 buckets HashMap<String, Integer> map = new HashMap<>(); // Insert key-value pairs map.put(\"Apple\", 5); map.put(\"Banana\", 7); map.put(\"Orange\", 3); // Retrieve a value based on key System.out.println(\"Apple's count: \" + map.get(\"Apple\")); // Output: 5 // Update a value map.put(\"Apple\", 10); System.out.println(\"Updated Apple's count: \" + map.get(\"Apple\")); // Output: 10 // Remove a key-value pair map.remove(\"Banana\"); // Check if a key exists System.out.println(\"Contains 'Banana'? \" + map.containsKey(\"Banana\")); // Output: false } }","title":"Example"},{"location":"java/How%20Java%20Works/","text":"How Java Works Java is a high-level, object-oriented programming language that operates on the principle of Write Once, Run Anywhere (WORA) . This principle is achieved through its robust runtime environment and platform-independent nature. Here's an overview of how Java works: 1. Source Code to Bytecode Java source code is written in .java files. The Java Compiler (javac) converts the source code into an intermediate form called bytecode , stored in .class files. Bytecode is platform-independent, meaning it can run on any system with a Java Virtual Machine (JVM). 2. Java Virtual Machine (JVM) The JVM is a runtime environment that interprets or compiles bytecode into machine code specific to the host operating system and hardware. JVM ensures that Java programs run in a secure and controlled manner. Key Components of JVM : Class Loader : Loads .class files into memory. Bytecode Verifier : Ensures the bytecode adheres to security and format standards. Just-In-Time (JIT) Compiler : Translates bytecode into native machine code for faster execution. 3. Java Runtime Environment (JRE) The JRE is a subset of the Java Development Kit (JDK) and includes the JVM, core libraries, and other components necessary to run Java applications. It provides the libraries and environment required for bytecode execution. 4. Key Features of Java Execution Platform Independence : Bytecode is the same regardless of the operating system. Garbage Collection : Java automatically manages memory, cleaning up unused objects. Multithreading : Java supports concurrent execution of threads. Security : The JVM isolates and verifies code execution, preventing malicious operations. 5. Execution Process Write the Code : Developer writes code in .java files. Compile the Code : javac compiles the code into .class files (bytecode). Run the Code : java command runs the bytecode using the JVM. Interpret/Compile to Machine Code : JVM interprets or JIT compiles the bytecode into native code for execution. Example Workflow Write the Program : public class HelloWorld { public static void main(String[] args) { System.out.println(\"Hello, World!\"); } } Compile the Program : javac HelloWorld.java This creates `HelloWorld.class`. Run the Program : java HelloWorld Output : Hello, World! Java's layered architecture ensures portability, robustness, and scalability, making it widely used for enterprise applications, mobile apps, and web services.","title":"How Java Works"},{"location":"java/How%20Java%20Works/#how-java-works","text":"Java is a high-level, object-oriented programming language that operates on the principle of Write Once, Run Anywhere (WORA) . This principle is achieved through its robust runtime environment and platform-independent nature. Here's an overview of how Java works:","title":"How Java Works"},{"location":"java/How%20Java%20Works/#1-source-code-to-bytecode","text":"Java source code is written in .java files. The Java Compiler (javac) converts the source code into an intermediate form called bytecode , stored in .class files. Bytecode is platform-independent, meaning it can run on any system with a Java Virtual Machine (JVM).","title":"1. Source Code to Bytecode"},{"location":"java/How%20Java%20Works/#2-java-virtual-machine-jvm","text":"The JVM is a runtime environment that interprets or compiles bytecode into machine code specific to the host operating system and hardware. JVM ensures that Java programs run in a secure and controlled manner. Key Components of JVM : Class Loader : Loads .class files into memory. Bytecode Verifier : Ensures the bytecode adheres to security and format standards. Just-In-Time (JIT) Compiler : Translates bytecode into native machine code for faster execution.","title":"2. Java Virtual Machine (JVM)"},{"location":"java/How%20Java%20Works/#3-java-runtime-environment-jre","text":"The JRE is a subset of the Java Development Kit (JDK) and includes the JVM, core libraries, and other components necessary to run Java applications. It provides the libraries and environment required for bytecode execution.","title":"3. Java Runtime Environment (JRE)"},{"location":"java/How%20Java%20Works/#4-key-features-of-java-execution","text":"Platform Independence : Bytecode is the same regardless of the operating system. Garbage Collection : Java automatically manages memory, cleaning up unused objects. Multithreading : Java supports concurrent execution of threads. Security : The JVM isolates and verifies code execution, preventing malicious operations.","title":"4. Key Features of Java Execution"},{"location":"java/How%20Java%20Works/#5-execution-process","text":"Write the Code : Developer writes code in .java files. Compile the Code : javac compiles the code into .class files (bytecode). Run the Code : java command runs the bytecode using the JVM. Interpret/Compile to Machine Code : JVM interprets or JIT compiles the bytecode into native code for execution.","title":"5. Execution Process"},{"location":"java/How%20Java%20Works/#example-workflow","text":"Write the Program : public class HelloWorld { public static void main(String[] args) { System.out.println(\"Hello, World!\"); } } Compile the Program : javac HelloWorld.java This creates `HelloWorld.class`. Run the Program : java HelloWorld Output : Hello, World! Java's layered architecture ensures portability, robustness, and scalability, making it widely used for enterprise applications, mobile apps, and web services.","title":"Example Workflow"},{"location":"java/Interface/","text":"Key Points About Interfaces in Java An interface is a reference type, similar to a class, that can contain only constants, method signatures, default methods, static methods, and nested types. Interfaces cannot contain instance fields or constructors. Key Features of Interfaces: No Implementation : Methods in an interface have no implementation, only method signatures. Multiple Inheritance : A class can implement multiple interfaces, overcoming the limitation of multiple inheritance in Java classes. Abstract Methods : All methods in an interface are abstract by default, except for default and static methods. Default Methods : Introduced in Java 8, interfaces can have default methods that provide default implementations. Static Methods : Interfaces can also have static methods. Limitations of Interfaces: Cannot contain instance fields. Cannot have constructors Example: interface MyInterface { int CONSTANT_VALUE = 100; // Constant void abstractMethod(); // Abstract method // Default method default void defaultMethod() { System.out.println(\"Default implementation\"); } // Static method static void staticMethod() { System.out.println(\"Static method in interface\"); } }","title":"Interface"},{"location":"java/Interface/#key-points-about-interfaces-in-java","text":"An interface is a reference type, similar to a class, that can contain only constants, method signatures, default methods, static methods, and nested types. Interfaces cannot contain instance fields or constructors.","title":"Key Points About Interfaces in Java"},{"location":"java/Interface/#key-features-of-interfaces","text":"No Implementation : Methods in an interface have no implementation, only method signatures. Multiple Inheritance : A class can implement multiple interfaces, overcoming the limitation of multiple inheritance in Java classes. Abstract Methods : All methods in an interface are abstract by default, except for default and static methods. Default Methods : Introduced in Java 8, interfaces can have default methods that provide default implementations. Static Methods : Interfaces can also have static methods.","title":"Key Features of Interfaces:"},{"location":"java/Interface/#limitations-of-interfaces","text":"Cannot contain instance fields. Cannot have constructors","title":"Limitations of Interfaces:"},{"location":"java/Interface/#example","text":"interface MyInterface { int CONSTANT_VALUE = 100; // Constant void abstractMethod(); // Abstract method // Default method default void defaultMethod() { System.out.println(\"Default implementation\"); } // Static method static void staticMethod() { System.out.println(\"Static method in interface\"); } }","title":"Example:"},{"location":"java/Iterator%20%26%20Iterable/","text":"Iterator and Iterable in Java In Java, the terms Iterator and Iterable refer to two concepts related to traversing collections like lists, sets, and other data structures. 1. Iterable Iterable is an interface in Java that represents a collection of elements that can be iterated over (i.e., you can loop through them). A class that implements the Iterable interface provides the capability to traverse its elements one by one. This interface has a single method: public interface Iterable<T> { Iterator<T> iterator(); } Any collection class (like ArrayList, HashSet, etc.) that implements Iterable can be used in an enhanced for-loop (for-each loop). List<String> list = Arrays.asList(\"a\", \"b\", \"c\"); for (String s : list) { System.out.println(s); } The ArrayList class, which implements Iterable, allows the above usage. 2. Iterator Iterator is an interface in Java that allows you to traverse (iterate) through a collection, element by element, and optionally remove elements from the collection. The Iterator interface provides three primary methods: hasNext(): Returns true if there are more elements to iterate over. next(): Returns the next element in the iteration. remove(): Removes the last element returned by the iterator (optional operation). List<String> list = Arrays.asList(\"a\", \"b\", \"c\"); Iterator<String> iterator = list.iterator(); while (iterator.hasNext()) { String element = iterator.next(); System.out.println(element); } Key Differences Iterable is used to represent collections that can be traversed, while Iterator provides the mechanism for iterating over those collections. Iterable has the iterator() method that returns an Iterator, and Iterator has methods for accessing and removing elements.","title":"Iterator vs Iterable"},{"location":"java/Iterator%20%26%20Iterable/#iterator-and-iterable-in-java","text":"In Java, the terms Iterator and Iterable refer to two concepts related to traversing collections like lists, sets, and other data structures.","title":"Iterator and Iterable in Java"},{"location":"java/Iterator%20%26%20Iterable/#1-iterable","text":"Iterable is an interface in Java that represents a collection of elements that can be iterated over (i.e., you can loop through them). A class that implements the Iterable interface provides the capability to traverse its elements one by one. This interface has a single method: public interface Iterable<T> { Iterator<T> iterator(); } Any collection class (like ArrayList, HashSet, etc.) that implements Iterable can be used in an enhanced for-loop (for-each loop). List<String> list = Arrays.asList(\"a\", \"b\", \"c\"); for (String s : list) { System.out.println(s); } The ArrayList class, which implements Iterable, allows the above usage.","title":"1. Iterable"},{"location":"java/Iterator%20%26%20Iterable/#2-iterator","text":"Iterator is an interface in Java that allows you to traverse (iterate) through a collection, element by element, and optionally remove elements from the collection. The Iterator interface provides three primary methods: hasNext(): Returns true if there are more elements to iterate over. next(): Returns the next element in the iteration. remove(): Removes the last element returned by the iterator (optional operation). List<String> list = Arrays.asList(\"a\", \"b\", \"c\"); Iterator<String> iterator = list.iterator(); while (iterator.hasNext()) { String element = iterator.next(); System.out.println(element); }","title":"2. Iterator"},{"location":"java/Iterator%20%26%20Iterable/#key-differences","text":"Iterable is used to represent collections that can be traversed, while Iterator provides the mechanism for iterating over those collections. Iterable has the iterator() method that returns an Iterator, and Iterator has methods for accessing and removing elements.","title":"Key Differences"},{"location":"java/Java%20Virtual%20Machine%20%28JVM%29/","text":"Java Virtual Machine (JVM) The Java Virtual Machine (JVM) is a critical component of the Java platform. It executes Java bytecode, providing platform independence and efficient memory management. Key Features of JVM Platform Independence : Ensures Java programs run on any system with a JVM. Memory Management : Manages memory with garbage collection. Execution Engine : Converts bytecode to native machine code. Security : Sandboxed environment for secure execution. JVM Architecture 1. Class Loader Loads Java class files. Divided into: Bootstrap Class Loader : Loads core Java classes. Extension Class Loader : Loads classes from the ext directory. Application Class Loader : Loads classes from the classpath. 2. Method Area Stores metadata about loaded classes, methods, and static variables. 3. Heap Memory area for object allocation, managed by the Garbage Collector. 4. Stack Stores stack frames for method invocations, including: Local variables Operand stack Return values 5. Program Counter (PC) Register Tracks the next instruction to execute. 6. Native Method Stack Used for executing native methods (e.g., in C/C++). 7. Execution Engine Executes bytecode instructions. Components: Interpreter : Executes bytecode line by line. It translates bytecode to native machine code at runtime. Just-In-Time (JIT) Compiler : Converts bytecode to native code for faster execution.Initially, the interpreter starts executing the bytecode. The JIT compiler identifies \"hot spots\" (frequently executed code e.g. methods or loops) and compiles them into native code. Once compiled, the native code is cached and reused, avoiding repetitive interpretation. 8. Garbage Collector Automatically reclaims memory occupied by unused objects. JVM Lifecycle Loading : The class loader loads the .class file. Linking : Verifies bytecode and prepares the method area. Initialization : Executes static initializers and assigns static variables. Execution : The execution engine runs the bytecode. Shutdown : JVM shuts down after program execution. Popular JVM Implementations HotSpot JVM (by Oracle): Widely used and optimized for performance. OpenJ9 (by IBM): Tailored for cloud and container environments. GraalVM : High-performance JVM with polyglot support. How JVM Enables \"Write Once, Run Anywhere\" Java code is compiled into platform-independent bytecode by the Java Compiler (javac) . The JVM interprets and executes this bytecode, ensuring compatibility across systems with a JVM.","title":"JVM"},{"location":"java/Java%20Virtual%20Machine%20%28JVM%29/#java-virtual-machine-jvm","text":"The Java Virtual Machine (JVM) is a critical component of the Java platform. It executes Java bytecode, providing platform independence and efficient memory management.","title":"Java Virtual Machine (JVM)"},{"location":"java/Java%20Virtual%20Machine%20%28JVM%29/#key-features-of-jvm","text":"Platform Independence : Ensures Java programs run on any system with a JVM. Memory Management : Manages memory with garbage collection. Execution Engine : Converts bytecode to native machine code. Security : Sandboxed environment for secure execution.","title":"Key Features of JVM"},{"location":"java/Java%20Virtual%20Machine%20%28JVM%29/#jvm-architecture","text":"","title":"JVM Architecture"},{"location":"java/Java%20Virtual%20Machine%20%28JVM%29/#1-class-loader","text":"Loads Java class files. Divided into: Bootstrap Class Loader : Loads core Java classes. Extension Class Loader : Loads classes from the ext directory. Application Class Loader : Loads classes from the classpath.","title":"1. Class Loader"},{"location":"java/Java%20Virtual%20Machine%20%28JVM%29/#2-method-area","text":"Stores metadata about loaded classes, methods, and static variables.","title":"2. Method Area"},{"location":"java/Java%20Virtual%20Machine%20%28JVM%29/#3-heap","text":"Memory area for object allocation, managed by the Garbage Collector.","title":"3. Heap"},{"location":"java/Java%20Virtual%20Machine%20%28JVM%29/#4-stack","text":"Stores stack frames for method invocations, including: Local variables Operand stack Return values","title":"4. Stack"},{"location":"java/Java%20Virtual%20Machine%20%28JVM%29/#5-program-counter-pc-register","text":"Tracks the next instruction to execute.","title":"5. Program Counter (PC) Register"},{"location":"java/Java%20Virtual%20Machine%20%28JVM%29/#6-native-method-stack","text":"Used for executing native methods (e.g., in C/C++).","title":"6. Native Method Stack"},{"location":"java/Java%20Virtual%20Machine%20%28JVM%29/#7-execution-engine","text":"Executes bytecode instructions. Components: Interpreter : Executes bytecode line by line. It translates bytecode to native machine code at runtime. Just-In-Time (JIT) Compiler : Converts bytecode to native code for faster execution.Initially, the interpreter starts executing the bytecode. The JIT compiler identifies \"hot spots\" (frequently executed code e.g. methods or loops) and compiles them into native code. Once compiled, the native code is cached and reused, avoiding repetitive interpretation.","title":"7. Execution Engine"},{"location":"java/Java%20Virtual%20Machine%20%28JVM%29/#8-garbage-collector","text":"Automatically reclaims memory occupied by unused objects.","title":"8. Garbage Collector"},{"location":"java/Java%20Virtual%20Machine%20%28JVM%29/#jvm-lifecycle","text":"Loading : The class loader loads the .class file. Linking : Verifies bytecode and prepares the method area. Initialization : Executes static initializers and assigns static variables. Execution : The execution engine runs the bytecode. Shutdown : JVM shuts down after program execution.","title":"JVM Lifecycle"},{"location":"java/Java%20Virtual%20Machine%20%28JVM%29/#popular-jvm-implementations","text":"HotSpot JVM (by Oracle): Widely used and optimized for performance. OpenJ9 (by IBM): Tailored for cloud and container environments. GraalVM : High-performance JVM with polyglot support.","title":"Popular JVM Implementations"},{"location":"java/Java%20Virtual%20Machine%20%28JVM%29/#how-jvm-enables-write-once-run-anywhere","text":"Java code is compiled into platform-independent bytecode by the Java Compiler (javac) . The JVM interprets and executes this bytecode, ensuring compatibility across systems with a JVM.","title":"How JVM Enables \"Write Once, Run Anywhere\""},{"location":"java/LambdaExpression/","text":"Lambda A Lambda Expression in Java is a way to provide clear and concise syntax for writing anonymous methods (implementations of functional interfaces). It allows you to treat functionality as a method argument, or to create a short-hand for writing instances of classes with a single method (functional interfaces). The basic syntax of a lambda expression is: (parameters) -> expression Here are some examples: 1. No parameters: () -> System.out.println(\"Hello, World!\"); 2. One parameter: (x) -> System.out.println(x); 3. Multiple parameters: (x, y) -> System.out.println(x + y); 4. With return type: (a, b) -> a + b; Common uses of Lambda Expressions: With Functional Interfaces : A lambda expression implements the abstract method of a functional interface. Example: interface MathOperation { int operate(int a, int b); } public class Main { public static void main(String[] args) { MathOperation addition = (a, b) -> a + b; MathOperation subtraction = (a, b) -> a - b; System.out.println(\"Addition: \" + addition.operate(10, 5)); System.out.println(\"Subtraction: \" + subtraction.operate(10, 5)); } } In Collections : Lambda expressions are widely used in the Streams API and with forEach loops. Example with forEach: List<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); names.forEach(name -> System.out.println(name)); Sorting : Lambda expressions can be used to pass custom comparators. Example: List<Integer> numbers = Arrays.asList(5, 3, 8, 1); numbers.sort((a, b) -> a - b); System.out.println(numbers); Benefits of Lambda Expressions: Conciseness : Reduces boilerplate code. Readability : Makes code more readable and easier to understand. Enables Functional Programming : Lambda expressions help with writing functional-style code, especially when working with streams.","title":"Lambda Expression"},{"location":"java/LambdaExpression/#lambda","text":"A Lambda Expression in Java is a way to provide clear and concise syntax for writing anonymous methods (implementations of functional interfaces). It allows you to treat functionality as a method argument, or to create a short-hand for writing instances of classes with a single method (functional interfaces). The basic syntax of a lambda expression is: (parameters) -> expression Here are some examples:","title":"Lambda"},{"location":"java/LambdaExpression/#1-no-parameters","text":"() -> System.out.println(\"Hello, World!\");","title":"1. No parameters:"},{"location":"java/LambdaExpression/#2-one-parameter","text":"(x) -> System.out.println(x);","title":"2. One parameter:"},{"location":"java/LambdaExpression/#3-multiple-parameters","text":"(x, y) -> System.out.println(x + y);","title":"3. Multiple parameters:"},{"location":"java/LambdaExpression/#4-with-return-type","text":"(a, b) -> a + b;","title":"4. With return type:"},{"location":"java/LambdaExpression/#common-uses-of-lambda-expressions","text":"With Functional Interfaces : A lambda expression implements the abstract method of a functional interface. Example: interface MathOperation { int operate(int a, int b); } public class Main { public static void main(String[] args) { MathOperation addition = (a, b) -> a + b; MathOperation subtraction = (a, b) -> a - b; System.out.println(\"Addition: \" + addition.operate(10, 5)); System.out.println(\"Subtraction: \" + subtraction.operate(10, 5)); } } In Collections : Lambda expressions are widely used in the Streams API and with forEach loops. Example with forEach: List<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); names.forEach(name -> System.out.println(name)); Sorting : Lambda expressions can be used to pass custom comparators. Example: List<Integer> numbers = Arrays.asList(5, 3, 8, 1); numbers.sort((a, b) -> a - b); System.out.println(numbers);","title":"Common uses of Lambda Expressions:"},{"location":"java/LambdaExpression/#benefits-of-lambda-expressions","text":"Conciseness : Reduces boilerplate code. Readability : Makes code more readable and easier to understand. Enables Functional Programming : Lambda expressions help with writing functional-style code, especially when working with streams.","title":"Benefits of Lambda Expressions:"},{"location":"java/Method%20overloading%20%26%20overiding/","text":"Method Overloading vs. Method Overriding 1. Method Overloading: Definition: Method overloading is a feature that allows a class to have multiple methods with the same name but with different parameters (i.e., different number or type of arguments). Key Points: Methods with the same name but different signatures (different parameter types or a different number of parameters). It is determined at compile time (known as compile-time polymorphism or static polymorphism). Overloaded methods must differ in the type or number of their parameters, not their return type . Overloading can occur within the same class or in a subclass . class Calculator { // Overloaded method for adding two integers int add(int a, int b) { return a + b; } // Overloaded method for adding three integers int add(int a, int b, int c) { return a + b + c; } // Overloaded method for adding two doubles double add(double a, double b) { return a + b; } } public class Main { public static void main(String[] args) { Calculator calc = new Calculator(); System.out.println(calc.add(2, 3)); // Calls the method with two integers System.out.println(calc.add(1, 2, 3)); // Calls the method with three integers System.out.println(calc.add(2.5, 3.5)); // Calls the method with two doubles } } Output: Copy code 5 6 6.0 2. Method Overriding: Definition: Method overriding occurs when a subclass provides a specific implementation of a method that is already defined in its superclass. The method signature (name, return type, and parameters) must be the same in both the superclass and subclass. Key Points: The method in the subclass must have the same name , return type , and parameters as in the superclass. It is determined at runtime (known as runtime polymorphism or dynamic polymorphism). Overriding allows a subclass to provide a specific implementation of a method that is already provided by its parent class . The method in the subclass can be called using an object of the subclass or the parent class (through a reference to the subclass). The @Override annotation is used to indicate method overriding, though it\u2019s not mandatory . class Animal { // Method to be overridden in subclass void sound() { System.out.println(\"Animal makes a sound\"); } } class Dog extends Animal { // Overriding the sound method in the subclass @Override void sound() { System.out.println(\"Dog barks\"); } } public class Main { public static void main(String[] args) { Animal animal = new Animal(); animal.sound(); // Calls the method in Animal class Dog dog = new Dog(); dog.sound(); // Calls the overridden method in Dog class Animal myDog = new Dog(); myDog.sound(); // Calls the overridden method in Dog class (runtime polymorphism) } } Output: css Copy code Animal makes a sound Dog barks Dog barks","title":"Method overloading & overiding"},{"location":"java/Method%20overloading%20%26%20overiding/#method-overloading-vs-method-overriding","text":"","title":"Method Overloading vs. Method Overriding"},{"location":"java/Method%20overloading%20%26%20overiding/#1-method-overloading","text":"","title":"1. Method Overloading:"},{"location":"java/Method%20overloading%20%26%20overiding/#definition","text":"Method overloading is a feature that allows a class to have multiple methods with the same name but with different parameters (i.e., different number or type of arguments).","title":"Definition:"},{"location":"java/Method%20overloading%20%26%20overiding/#key-points","text":"Methods with the same name but different signatures (different parameter types or a different number of parameters). It is determined at compile time (known as compile-time polymorphism or static polymorphism). Overloaded methods must differ in the type or number of their parameters, not their return type . Overloading can occur within the same class or in a subclass . class Calculator { // Overloaded method for adding two integers int add(int a, int b) { return a + b; } // Overloaded method for adding three integers int add(int a, int b, int c) { return a + b + c; } // Overloaded method for adding two doubles double add(double a, double b) { return a + b; } } public class Main { public static void main(String[] args) { Calculator calc = new Calculator(); System.out.println(calc.add(2, 3)); // Calls the method with two integers System.out.println(calc.add(1, 2, 3)); // Calls the method with three integers System.out.println(calc.add(2.5, 3.5)); // Calls the method with two doubles } } Output: Copy code 5 6 6.0","title":"Key Points:"},{"location":"java/Method%20overloading%20%26%20overiding/#2-method-overriding","text":"","title":"2. Method Overriding:"},{"location":"java/Method%20overloading%20%26%20overiding/#definition_1","text":"Method overriding occurs when a subclass provides a specific implementation of a method that is already defined in its superclass. The method signature (name, return type, and parameters) must be the same in both the superclass and subclass.","title":"Definition:"},{"location":"java/Method%20overloading%20%26%20overiding/#key-points_1","text":"The method in the subclass must have the same name , return type , and parameters as in the superclass. It is determined at runtime (known as runtime polymorphism or dynamic polymorphism). Overriding allows a subclass to provide a specific implementation of a method that is already provided by its parent class . The method in the subclass can be called using an object of the subclass or the parent class (through a reference to the subclass). The @Override annotation is used to indicate method overriding, though it\u2019s not mandatory . class Animal { // Method to be overridden in subclass void sound() { System.out.println(\"Animal makes a sound\"); } } class Dog extends Animal { // Overriding the sound method in the subclass @Override void sound() { System.out.println(\"Dog barks\"); } } public class Main { public static void main(String[] args) { Animal animal = new Animal(); animal.sound(); // Calls the method in Animal class Dog dog = new Dog(); dog.sound(); // Calls the overridden method in Dog class Animal myDog = new Dog(); myDog.sound(); // Calls the overridden method in Dog class (runtime polymorphism) } } Output: css Copy code Animal makes a sound Dog barks Dog barks","title":"Key Points:"},{"location":"java/Object-Oriented%20Programming/","text":"Object-Oriented Programming (OOP) Concepts Object-Oriented Programming (OOP) is a programming paradigm based on the concept of \"objects,\" which are instances of classes. OOP focuses on organizing software design around data (objects) and the methods (functions) that operate on that data. Below are the core principles of OOP: 1. Class A blueprint for creating objects. Defines properties (fields) and behaviors (methods). Example : class Animal { String name; int age; void eat() { System.out.println(name + \" is eating.\"); } } 2. Object An instance of a class. Represents a real-world entity. Example : public class Main { public static void main(String[] args) { Animal dog = new Animal(); dog.name = \"Buddy\"; dog.age = 3; dog.eat(); // Output: Buddy is eating. } } 3. Inheritance Definition : Inheritance allows a class to inherit properties and behaviors (methods) from another class. This helps in reusing existing code and establishing a relationship between parent and child classes. Mechanism to acquire properties and methods from another class. Promotes code reuse. Example : If you have a class Animal , a Dog class can inherit from Animal , gaining properties like name and methods like eat() . The Dog class can also have additional methods like bark() . class Dog extends Animal { void bark() { System.out.println(name + \" is barking.\"); } } public class Main { public static void main(String[] args) { Dog dog = new Dog(); dog.name = \"Buddy\"; dog.bark(); // Output: Buddy is barking. } } Single Inheritance : A class can inherit from only one superclass. Multilevel Inheritance : A class can inherit from a class that itself inherits from another class. Hierarchical Inheritance : Multiple subclasses inherit from a single superclass. Hybrid Inheritance : A combination of the above types. 4. Encapsulation Definition : The bundling of data and methods that operate on that data within a single unit or class. It also involves restricting direct access to some of the object's components, which is typically done by making some variables or methods private and providing public getter and setter methods to access them. Bundling data (fields) and methods into a single unit (class). Use access modifiers (private, public, protected) to control access. Example : If you have a Car class, its attributes like speed and fuelLevel can be encapsulated, with methods like accelerate() or refuel() controlling how these properties change. class Person { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } } 5. Polymorphism Definition : It allows objects to take on multiple forms by enabling a single action to behave differently based on the object performing it. Ability to take many forms. Two types: Compile-time Polymorphism (Method Overloading) Runtime Polymorphism (Method Overriding) Example : A method makeSound() might behave differently depending on whether it is called on a Dog object or a Cat object, even though the method signature is the same. - Method Overloading: class Calculator { int add(int a, int b) { return a + b; } double add(double a, double b) { return a + b; } } Method Overriding: class Animal { void sound() { System.out.println(\"Animal makes a sound\"); } } class Dog extends Animal { @Override void sound() { System.out.println(\"Dog barks\"); } } 6. Abstraction Definition : Abstraction refers to hiding the complex implementation details of a system and exposing only the essential features to the user. This is done through abstract classes and interfaces. Hiding implementation details and showing only essential features. Achieved using: Abstract classes (abstract keyword) Interfaces Example : A Vehicle class may be abstract, with a method move() . Classes like Car or Bike will inherit from it and implement the move() method in their own way (e.g., car moves on four wheels, bike moves on two). - Abstract Class: abstract class Shape { abstract void draw(); } class Circle extends Shape { void draw() { System.out.println(\"Drawing Circle\"); } } Interface: interface Animal { void sound(); } class Dog implements Animal { public void sound() { System.out.println(\"Dog barks\"); } } Advantages of OOP: Code Reusability : Through inheritance and composition, code can be reused across different parts of an application. Modularity : Code is organized into classes and objects, making it easier to understand and maintain. Scalability and Maintainability : OOP systems can be more easily updated, modified, and extended because of their modular structure. Real-world modeling : OOP reflects real-world concepts, making it intuitive to model complex systems.","title":"Object-Oriented Programming"},{"location":"java/Object-Oriented%20Programming/#object-oriented-programming-oop-concepts","text":"Object-Oriented Programming (OOP) is a programming paradigm based on the concept of \"objects,\" which are instances of classes. OOP focuses on organizing software design around data (objects) and the methods (functions) that operate on that data. Below are the core principles of OOP:","title":"Object-Oriented Programming (OOP) Concepts"},{"location":"java/Object-Oriented%20Programming/#1-class","text":"A blueprint for creating objects. Defines properties (fields) and behaviors (methods). Example : class Animal { String name; int age; void eat() { System.out.println(name + \" is eating.\"); } }","title":"1. Class"},{"location":"java/Object-Oriented%20Programming/#2-object","text":"An instance of a class. Represents a real-world entity. Example : public class Main { public static void main(String[] args) { Animal dog = new Animal(); dog.name = \"Buddy\"; dog.age = 3; dog.eat(); // Output: Buddy is eating. } }","title":"2. Object"},{"location":"java/Object-Oriented%20Programming/#3-inheritance","text":"Definition : Inheritance allows a class to inherit properties and behaviors (methods) from another class. This helps in reusing existing code and establishing a relationship between parent and child classes. Mechanism to acquire properties and methods from another class. Promotes code reuse. Example : If you have a class Animal , a Dog class can inherit from Animal , gaining properties like name and methods like eat() . The Dog class can also have additional methods like bark() . class Dog extends Animal { void bark() { System.out.println(name + \" is barking.\"); } } public class Main { public static void main(String[] args) { Dog dog = new Dog(); dog.name = \"Buddy\"; dog.bark(); // Output: Buddy is barking. } } Single Inheritance : A class can inherit from only one superclass. Multilevel Inheritance : A class can inherit from a class that itself inherits from another class. Hierarchical Inheritance : Multiple subclasses inherit from a single superclass. Hybrid Inheritance : A combination of the above types.","title":"3. Inheritance"},{"location":"java/Object-Oriented%20Programming/#4-encapsulation","text":"Definition : The bundling of data and methods that operate on that data within a single unit or class. It also involves restricting direct access to some of the object's components, which is typically done by making some variables or methods private and providing public getter and setter methods to access them. Bundling data (fields) and methods into a single unit (class). Use access modifiers (private, public, protected) to control access. Example : If you have a Car class, its attributes like speed and fuelLevel can be encapsulated, with methods like accelerate() or refuel() controlling how these properties change. class Person { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } }","title":"4. Encapsulation"},{"location":"java/Object-Oriented%20Programming/#5-polymorphism","text":"Definition : It allows objects to take on multiple forms by enabling a single action to behave differently based on the object performing it. Ability to take many forms. Two types: Compile-time Polymorphism (Method Overloading) Runtime Polymorphism (Method Overriding) Example : A method makeSound() might behave differently depending on whether it is called on a Dog object or a Cat object, even though the method signature is the same. - Method Overloading: class Calculator { int add(int a, int b) { return a + b; } double add(double a, double b) { return a + b; } } Method Overriding: class Animal { void sound() { System.out.println(\"Animal makes a sound\"); } } class Dog extends Animal { @Override void sound() { System.out.println(\"Dog barks\"); } }","title":"5. Polymorphism"},{"location":"java/Object-Oriented%20Programming/#6-abstraction","text":"Definition : Abstraction refers to hiding the complex implementation details of a system and exposing only the essential features to the user. This is done through abstract classes and interfaces. Hiding implementation details and showing only essential features. Achieved using: Abstract classes (abstract keyword) Interfaces Example : A Vehicle class may be abstract, with a method move() . Classes like Car or Bike will inherit from it and implement the move() method in their own way (e.g., car moves on four wheels, bike moves on two). - Abstract Class: abstract class Shape { abstract void draw(); } class Circle extends Shape { void draw() { System.out.println(\"Drawing Circle\"); } } Interface: interface Animal { void sound(); } class Dog implements Animal { public void sound() { System.out.println(\"Dog barks\"); } }","title":"6. Abstraction"},{"location":"java/Object-Oriented%20Programming/#advantages-of-oop","text":"Code Reusability : Through inheritance and composition, code can be reused across different parts of an application. Modularity : Code is organized into classes and objects, making it easier to understand and maintain. Scalability and Maintainability : OOP systems can be more easily updated, modified, and extended because of their modular structure. Real-world modeling : OOP reflects real-world concepts, making it intuitive to model complex systems.","title":"Advantages of OOP:"},{"location":"java/Operators/","text":"Operators In Java, operators are special symbols or keywords used to perform operations on variables and values. They can be classified into several types. 1. Arithmetic Operators These operators are used to perform basic arithmetic operations. + : Addition - : Subtraction * : Multiplication / : Division % : Modulus (remainder) 2. Relational (Comparison) Operators These operators are used to compare two values. == : Equal to != : Not equal to > : Greater than < : Less than >= : Greater than or equal to <= : Less than or equal to 3. Logical Operators These operators are used to perform logical operations, typically used in control flow statements. && : Logical AND || : Logical OR ! : Logical NOT 4. Assignment Operators These operators are used to assign values to variables. = : Simple assignment += : Addition assignment -= : Subtraction assignment *= : Multiplication assignment /= : Division assignment %= : Modulus assignment 5. Bitwise Operators These operators are used to perform bit-level operations. & : Bitwise AND | : Bitwise OR ^ : Bitwise XOR ~ : Bitwise NOT << : Left shift >> : Right shift >>> : Unsigned right shift 6. Unary Operators These operators operate on a single operand. + : Unary plus (indicates a positive value) - : Unary minus (negates the value) ++ : Increment -- : Decrement ! : Logical NOT (negates a boolean value) 7. Ternary (Conditional) Operator This is a shorthand for the if-else statement. condition ? expr1 : expr2 : If condition is true, expr1 is executed; otherwise, expr2 is executed. 8. Instanceof Operator This operator checks whether an object is an instance of a specified class or subclass. instanceof : Checks if an object is an instance of a specific class or subclass. 9. Type Cast Operator Used to convert one data type to another. (type) : Type casting (e.g., (int) 3.14 ) 10. New Operator Used to create new objects. new : Creates a new instance of a class. 11. Dot (.) Operator Used to access members of a class or object. object.member : Access fields, methods, or properties of an object.","title":"Operators"},{"location":"java/Operators/#operators","text":"In Java, operators are special symbols or keywords used to perform operations on variables and values. They can be classified into several types.","title":"Operators"},{"location":"java/Operators/#1-arithmetic-operators","text":"These operators are used to perform basic arithmetic operations. + : Addition - : Subtraction * : Multiplication / : Division % : Modulus (remainder)","title":"1. Arithmetic Operators"},{"location":"java/Operators/#2-relational-comparison-operators","text":"These operators are used to compare two values. == : Equal to != : Not equal to > : Greater than < : Less than >= : Greater than or equal to <= : Less than or equal to","title":"2. Relational (Comparison) Operators"},{"location":"java/Operators/#3-logical-operators","text":"These operators are used to perform logical operations, typically used in control flow statements. && : Logical AND || : Logical OR ! : Logical NOT","title":"3. Logical Operators"},{"location":"java/Operators/#4-assignment-operators","text":"These operators are used to assign values to variables. = : Simple assignment += : Addition assignment -= : Subtraction assignment *= : Multiplication assignment /= : Division assignment %= : Modulus assignment","title":"4. Assignment Operators"},{"location":"java/Operators/#5-bitwise-operators","text":"These operators are used to perform bit-level operations. & : Bitwise AND | : Bitwise OR ^ : Bitwise XOR ~ : Bitwise NOT << : Left shift >> : Right shift >>> : Unsigned right shift","title":"5. Bitwise Operators"},{"location":"java/Operators/#6-unary-operators","text":"These operators operate on a single operand. + : Unary plus (indicates a positive value) - : Unary minus (negates the value) ++ : Increment -- : Decrement ! : Logical NOT (negates a boolean value)","title":"6. Unary Operators"},{"location":"java/Operators/#7-ternary-conditional-operator","text":"This is a shorthand for the if-else statement. condition ? expr1 : expr2 : If condition is true, expr1 is executed; otherwise, expr2 is executed.","title":"7. Ternary (Conditional) Operator"},{"location":"java/Operators/#8-instanceof-operator","text":"This operator checks whether an object is an instance of a specified class or subclass. instanceof : Checks if an object is an instance of a specific class or subclass.","title":"8. Instanceof Operator"},{"location":"java/Operators/#9-type-cast-operator","text":"Used to convert one data type to another. (type) : Type casting (e.g., (int) 3.14 )","title":"9. Type Cast Operator"},{"location":"java/Operators/#10-new-operator","text":"Used to create new objects. new : Creates a new instance of a class.","title":"10. New Operator"},{"location":"java/Operators/#11-dot-operator","text":"Used to access members of a class or object. object.member : Access fields, methods, or properties of an object.","title":"11. Dot (.) Operator"},{"location":"java/ProgrammingQuestions/","text":"Java Interview Programming Questions Core Java Reverse a String : Without using built-in methods. Check Palindrome : Verify if a given string or number is a palindrome. Prime Number Check : Write a program to check if a number is prime. Fibonacci Sequence : Generate the Fibonacci sequence up to n terms. Factorial Calculation : Calculate the factorial of a number using recursion. Swap Two Numbers : Swap without using a third variable. Find Missing Number : From a series of numbers in an array (e.g., 1 to 100). Anagram Check : Determine if two strings are anagrams. Count Occurrences : Count the occurrences of characters in a string. Armstrong Number : Check if a number is an Armstrong number. Object-Oriented Programming Explain the difference between overloading and overriding . Write a program demonstrating inheritance and polymorphism . Singleton Design Pattern : Implement a singleton class in Java. Factory Design Pattern : Explain and implement a factory pattern. Write a program to demonstrate the use of abstract classes and interfaces . Collections Framework Write a program to sort a list of strings in alphabetical order. Find the second highest number in an array or list. Write a program to remove duplicates from an ArrayList . Implement a custom HashMap without using Java's built-in HashMap. Explain the difference between HashSet and TreeSet and their use cases. Use a PriorityQueue to sort elements in descending order. Write a program to traverse a HashMap using entrySet() . Advanced Topics Write a Lambda Expression for filtering a list of integers. Use Stream API to find the first non-repeated character in a string. Explain and demonstrate the use of Optional in Java 8. Implement parallel streams for large data processing. Write a program using CompletableFuture for asynchronous programming. Miscellaneous Explain the difference between Checked and Unchecked Exceptions . Write a custom Exception Class . Solve a coding problem using recursion and iteration and compare the solutions. Write a program to implement a simple cache using a LinkedHashMap. Implement the Observer Design Pattern using Java's built-in classes.","title":"Programming Questions"},{"location":"java/ProgrammingQuestions/#java-interview-programming-questions","text":"","title":"Java Interview Programming Questions"},{"location":"java/ProgrammingQuestions/#core-java","text":"Reverse a String : Without using built-in methods. Check Palindrome : Verify if a given string or number is a palindrome. Prime Number Check : Write a program to check if a number is prime. Fibonacci Sequence : Generate the Fibonacci sequence up to n terms. Factorial Calculation : Calculate the factorial of a number using recursion. Swap Two Numbers : Swap without using a third variable. Find Missing Number : From a series of numbers in an array (e.g., 1 to 100). Anagram Check : Determine if two strings are anagrams. Count Occurrences : Count the occurrences of characters in a string. Armstrong Number : Check if a number is an Armstrong number.","title":"Core Java"},{"location":"java/ProgrammingQuestions/#object-oriented-programming","text":"Explain the difference between overloading and overriding . Write a program demonstrating inheritance and polymorphism . Singleton Design Pattern : Implement a singleton class in Java. Factory Design Pattern : Explain and implement a factory pattern. Write a program to demonstrate the use of abstract classes and interfaces .","title":"Object-Oriented Programming"},{"location":"java/ProgrammingQuestions/#collections-framework","text":"Write a program to sort a list of strings in alphabetical order. Find the second highest number in an array or list. Write a program to remove duplicates from an ArrayList . Implement a custom HashMap without using Java's built-in HashMap. Explain the difference between HashSet and TreeSet and their use cases. Use a PriorityQueue to sort elements in descending order. Write a program to traverse a HashMap using entrySet() .","title":"Collections Framework"},{"location":"java/ProgrammingQuestions/#advanced-topics","text":"Write a Lambda Expression for filtering a list of integers. Use Stream API to find the first non-repeated character in a string. Explain and demonstrate the use of Optional in Java 8. Implement parallel streams for large data processing. Write a program using CompletableFuture for asynchronous programming.","title":"Advanced Topics"},{"location":"java/ProgrammingQuestions/#miscellaneous","text":"Explain the difference between Checked and Unchecked Exceptions . Write a custom Exception Class . Solve a coding problem using recursion and iteration and compare the solutions. Write a program to implement a simple cache using a LinkedHashMap. Implement the Observer Design Pattern using Java's built-in classes.","title":"Miscellaneous"},{"location":"java/StaticFinalKeyword/","text":"static and final Keywords in Java static Keyword The static keyword is used to indicate that a particular member (variable or method) belongs to the class, rather than instances of the class. This means that static members can be accessed without creating an object of the class. Static Variables: A static variable is shared by all instances of a class. It is initialized only once, when the class is loaded. It is useful for representing data that should be common to all objects of the class, such as a counter or a constant value. Static Methods: A static method can be called without creating an object of the class. It can only access other static members of the class (variables or methods). Static methods are typically utility methods, such as main() . Static Blocks: A static block is used for static initialization. It runs only once, when the class is first loaded into memory. final Keyword The final keyword is used to define constants and to prevent modification of variables, methods, and classes. Final Variables: A final variable's value cannot be changed once it is initialized. It is often used for constants. Final Methods: A final method cannot be overridden by subclasses. Final Classes: A final class cannot be subclassed (inherited). This is useful when you want to prevent a class from being extended, ensuring that the behavior of the method cannot be changed.","title":"Static & Final Keyword"},{"location":"java/StaticFinalKeyword/#static-and-final-keywords-in-java","text":"","title":"static and final Keywords in Java"},{"location":"java/StaticFinalKeyword/#static-keyword","text":"The static keyword is used to indicate that a particular member (variable or method) belongs to the class, rather than instances of the class. This means that static members can be accessed without creating an object of the class.","title":"static Keyword"},{"location":"java/StaticFinalKeyword/#static-variables","text":"A static variable is shared by all instances of a class. It is initialized only once, when the class is loaded. It is useful for representing data that should be common to all objects of the class, such as a counter or a constant value.","title":"Static Variables:"},{"location":"java/StaticFinalKeyword/#static-methods","text":"A static method can be called without creating an object of the class. It can only access other static members of the class (variables or methods). Static methods are typically utility methods, such as main() .","title":"Static Methods:"},{"location":"java/StaticFinalKeyword/#static-blocks","text":"A static block is used for static initialization. It runs only once, when the class is first loaded into memory.","title":"Static Blocks:"},{"location":"java/StaticFinalKeyword/#final-keyword","text":"The final keyword is used to define constants and to prevent modification of variables, methods, and classes.","title":"final Keyword"},{"location":"java/StaticFinalKeyword/#final-variables","text":"A final variable's value cannot be changed once it is initialized. It is often used for constants.","title":"Final Variables:"},{"location":"java/StaticFinalKeyword/#final-methods","text":"A final method cannot be overridden by subclasses.","title":"Final Methods:"},{"location":"java/StaticFinalKeyword/#final-classes","text":"A final class cannot be subclassed (inherited). This is useful when you want to prevent a class from being extended, ensuring that the behavior of the method cannot be changed.","title":"Final Classes:"},{"location":"java/Stream/","text":"Stream A Stream is a sequence of data elements that you can process (e.g., from a list, array, or file). Think of it as a pipeline through which data flows, and you can perform operations on it in a more readable and efficient way. Key Concepts of Stream API 1. Creating a Stream You can create a stream from a collection, array, or other data sources. List<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); Stream<String> stream = names.stream(); // Creating a stream from a list 2. Intermediate Operations These operations modify the stream but don\u2019t produce a result until a \"terminal operation\" is called. Examples are: filter : Keep only the elements that meet a condition. map : Change each element (like converting text to uppercase). sorted : Sort elements. stream.filter(name -> name.startsWith(\"A\")); // Keep names that start with \"A\" stream.map(String::toUpperCase); // Convert all names to uppercase 3. Terminal Operations These operations do something with the data (e.g., print it, collect it into a list, or count elements). Examples are: forEach : Perform an action for each element (e.g., print). collect : Collect the results into a collection like a list. reduce : Combine all elements into one result (e.g., sum). stream.forEach(System.out::println); // Print each name List<String> result = stream.collect(Collectors.toList()); // Collect into a list Example: Let's say we have a list of names, and we want to: Keep only the names that start with \"A\". Convert them to uppercase. Sort them. Here's how it looks with the Stream API: List<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\", \"David\"); List<String> result = names.stream() // Start the stream .filter(name -> name.startsWith(\"A\")) // Filter names starting with \"A\" .map(String::toUpperCase) // Convert to uppercase .sorted() // Sort them .collect(Collectors.toList()); // Collect the results into a list System.out.println(result); // Output: [ALICE] Why Use Streams? Readability : The code looks cleaner and more understandable. Less Boilerplate : You don\u2019t need to write complex loops. Efficiency : Streams can be processed in parallel, making them faster for large data.","title":"Stream"},{"location":"java/Stream/#stream","text":"A Stream is a sequence of data elements that you can process (e.g., from a list, array, or file). Think of it as a pipeline through which data flows, and you can perform operations on it in a more readable and efficient way.","title":"Stream"},{"location":"java/Stream/#key-concepts-of-stream-api","text":"","title":"Key Concepts of Stream API"},{"location":"java/Stream/#1-creating-a-stream","text":"You can create a stream from a collection, array, or other data sources. List<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); Stream<String> stream = names.stream(); // Creating a stream from a list","title":"1. Creating a Stream"},{"location":"java/Stream/#2-intermediate-operations","text":"These operations modify the stream but don\u2019t produce a result until a \"terminal operation\" is called. Examples are: filter : Keep only the elements that meet a condition. map : Change each element (like converting text to uppercase). sorted : Sort elements. stream.filter(name -> name.startsWith(\"A\")); // Keep names that start with \"A\" stream.map(String::toUpperCase); // Convert all names to uppercase","title":"2. Intermediate Operations"},{"location":"java/Stream/#3-terminal-operations","text":"These operations do something with the data (e.g., print it, collect it into a list, or count elements). Examples are: forEach : Perform an action for each element (e.g., print). collect : Collect the results into a collection like a list. reduce : Combine all elements into one result (e.g., sum). stream.forEach(System.out::println); // Print each name List<String> result = stream.collect(Collectors.toList()); // Collect into a list Example: Let's say we have a list of names, and we want to: Keep only the names that start with \"A\". Convert them to uppercase. Sort them. Here's how it looks with the Stream API: List<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\", \"David\"); List<String> result = names.stream() // Start the stream .filter(name -> name.startsWith(\"A\")) // Filter names starting with \"A\" .map(String::toUpperCase) // Convert to uppercase .sorted() // Sort them .collect(Collectors.toList()); // Collect the results into a list System.out.println(result); // Output: [ALICE] Why Use Streams? Readability : The code looks cleaner and more understandable. Less Boilerplate : You don\u2019t need to write complex loops. Efficiency : Streams can be processed in parallel, making them faster for large data.","title":"3. Terminal Operations"},{"location":"java/StreamsLambdaFunctional/","text":"Streams, Lambda Expressions, and Functional Interfaces 1. Streams: A stream is a sequence of elements that allows for functional-style operations on collections, such as filtering, mapping, and reducing. Streams can be processed sequentially or in parallel. Operations like filter() , map() , reduce() , forEach() , and collect() are commonly used to manipulate data within a stream. List<String> names = List.of(\"Alice\", \"Bob\", \"Charlie\", \"David\"); names.stream() .filter(name -> name.startsWith(\"A\")) .map(String::toUpperCase) .forEach(System.out::println); 2. Lambda Expressions: Lambda expressions provide a compact way to define anonymous functions (functions without a name). They allow you to pass behavior as parameters to methods or assign them to variables, typically used in conjunction with functional interfaces. List<Integer> numbers = List.of(1, 2, 3, 4, 5); int sum = numbers.stream() .filter(n -> n % 2 == 0) .mapToInt(Integer::intValue) .sum(); System.out.println(\"Sum of even numbers: \" + sum); 3. Functional Interfaces: A functional interface is an interface that has exactly one abstract method. They are intended to be used with lambda expressions, enabling a functional approach to programming. Common functional interfaces include: Predicate : Represents a boolean-valued function of one argument. Function : Represents a function that takes an argument and produces a result. Consumer : Represents an operation that takes a single input and returns no result. Supplier : Represents a supplier of results. UnaryOperator : A function that takes a single argument and returns a result of the same type. BinaryOperator : A function that takes two arguments of the same type and returns a result of the same type. @FunctionalInterface interface MyFunction { int apply(int a, int b); } public class Example { public static void main(String[] args) { MyFunction add = (a, b) -> a + b; System.out.println(add.apply(5, 3)); // Output: 8 } } These concepts enable cleaner, more readable, and more concise code, especially when working with collections or higher-order functions in Java.","title":"StreamsLambdaFunctional"},{"location":"java/StreamsLambdaFunctional/#streams-lambda-expressions-and-functional-interfaces","text":"","title":"Streams, Lambda Expressions, and Functional Interfaces"},{"location":"java/StreamsLambdaFunctional/#1-streams","text":"A stream is a sequence of elements that allows for functional-style operations on collections, such as filtering, mapping, and reducing. Streams can be processed sequentially or in parallel. Operations like filter() , map() , reduce() , forEach() , and collect() are commonly used to manipulate data within a stream. List<String> names = List.of(\"Alice\", \"Bob\", \"Charlie\", \"David\"); names.stream() .filter(name -> name.startsWith(\"A\")) .map(String::toUpperCase) .forEach(System.out::println);","title":"1. Streams:"},{"location":"java/StreamsLambdaFunctional/#2-lambda-expressions","text":"Lambda expressions provide a compact way to define anonymous functions (functions without a name). They allow you to pass behavior as parameters to methods or assign them to variables, typically used in conjunction with functional interfaces. List<Integer> numbers = List.of(1, 2, 3, 4, 5); int sum = numbers.stream() .filter(n -> n % 2 == 0) .mapToInt(Integer::intValue) .sum(); System.out.println(\"Sum of even numbers: \" + sum);","title":"2. Lambda Expressions:"},{"location":"java/StreamsLambdaFunctional/#3-functional-interfaces","text":"A functional interface is an interface that has exactly one abstract method. They are intended to be used with lambda expressions, enabling a functional approach to programming. Common functional interfaces include: Predicate : Represents a boolean-valued function of one argument. Function : Represents a function that takes an argument and produces a result. Consumer : Represents an operation that takes a single input and returns no result. Supplier : Represents a supplier of results. UnaryOperator : A function that takes a single argument and returns a result of the same type. BinaryOperator : A function that takes two arguments of the same type and returns a result of the same type. @FunctionalInterface interface MyFunction { int apply(int a, int b); } public class Example { public static void main(String[] args) { MyFunction add = (a, b) -> a + b; System.out.println(add.apply(5, 3)); // Output: 8 } } These concepts enable cleaner, more readable, and more concise code, especially when working with collections or higher-order functions in Java.","title":"3. Functional Interfaces:"},{"location":"java/String/","text":"Why Java String is Immutable In Java, strings are immutable , meaning that once a String object is created, its value cannot be changed. The primary reasons for this design choice are: 1. Security Strings are widely used for sensitive information such as passwords, file paths, and network connections. If strings were mutable, it could lead to unintended modifications, causing security risks. By making strings immutable, their values cannot be altered after creation, ensuring the integrity of sensitive data. 2. Thread-Safety In a multi-threaded environment, immutable objects are inherently thread-safe. Since strings cannot be changed once created, multiple threads can safely use the same string instance without requiring synchronization. This reduces the chances of race conditions, where one thread might alter the value of a string while another is reading or using it. 3. Hash Code Caching Java strings are commonly used as keys in hash-based collections like HashMap . When a string is immutable, its hash code can be cached at the time of its creation. This improves performance since the hash code doesn\u2019t need to be recomputed each time the string is used as a key. 4. Optimization (String Pooling) Java has an internal String Pool (also known as String Literal Pool ) to optimize memory usage. When a string is created using a literal (e.g., \"Hello\" ), it is stored in the pool. Since strings are immutable, the JVM can safely reuse the same string instance, avoiding the creation of multiple instances with the same value. This optimizes memory and improves performance. 5. Consistency The immutability of strings ensures that their value remains consistent throughout the program. Since strings cannot be changed, they are reliable and predictable, preventing errors caused by unexpected modifications. How Immutability Works in Practice When you try to modify a string, such as using methods like replace() , concat() , or toUpperCase() , a new string is created with the modified value, and the original string remains unchanged. For example: ```java String str = \"Hello\"; str = str.concat(\" World\"); // This creates a new string \"Hello World\" System.out.println(str); // Outputs: Hello World","title":"String"},{"location":"java/String/#why-java-string-is-immutable","text":"In Java, strings are immutable , meaning that once a String object is created, its value cannot be changed. The primary reasons for this design choice are:","title":"Why Java String is Immutable"},{"location":"java/String/#1-security","text":"Strings are widely used for sensitive information such as passwords, file paths, and network connections. If strings were mutable, it could lead to unintended modifications, causing security risks. By making strings immutable, their values cannot be altered after creation, ensuring the integrity of sensitive data.","title":"1. Security"},{"location":"java/String/#2-thread-safety","text":"In a multi-threaded environment, immutable objects are inherently thread-safe. Since strings cannot be changed once created, multiple threads can safely use the same string instance without requiring synchronization. This reduces the chances of race conditions, where one thread might alter the value of a string while another is reading or using it.","title":"2. Thread-Safety"},{"location":"java/String/#3-hash-code-caching","text":"Java strings are commonly used as keys in hash-based collections like HashMap . When a string is immutable, its hash code can be cached at the time of its creation. This improves performance since the hash code doesn\u2019t need to be recomputed each time the string is used as a key.","title":"3. Hash Code Caching"},{"location":"java/String/#4-optimization-string-pooling","text":"Java has an internal String Pool (also known as String Literal Pool ) to optimize memory usage. When a string is created using a literal (e.g., \"Hello\" ), it is stored in the pool. Since strings are immutable, the JVM can safely reuse the same string instance, avoiding the creation of multiple instances with the same value. This optimizes memory and improves performance.","title":"4. Optimization (String Pooling)"},{"location":"java/String/#5-consistency","text":"The immutability of strings ensures that their value remains consistent throughout the program. Since strings cannot be changed, they are reliable and predictable, preventing errors caused by unexpected modifications.","title":"5. Consistency"},{"location":"java/String/#how-immutability-works-in-practice","text":"When you try to modify a string, such as using methods like replace() , concat() , or toUpperCase() , a new string is created with the modified value, and the original string remains unchanged. For example: ```java String str = \"Hello\"; str = str.concat(\" World\"); // This creates a new string \"Hello World\" System.out.println(str); // Outputs: Hello World","title":"How Immutability Works in Practice"},{"location":"java/Thread/","text":"Thread A Thread is a lightweight process, and the basic unit of execution within a Java application. Threads allow multiple operations to run concurrently, making programs more efficient, especially in multi-core systems. Creating a Thread using Thread Class: The Thread class provides several methods to control the execution of threads. To create a thread, you can either subclass Thread or implement the Runnable interface. 1. Subclassing the Thread class: class MyThread extends Thread { @Override public void run() { // Code to be executed by the thread System.out.println(\"Thread is running\"); } } public class ThreadExample { public static void main(String[] args) { MyThread thread = new MyThread(); // Creating a thread thread.start(); // Starting the thread (calls the run method) } } 2. Implementing the Runnable interface: If you want to define your own thread behavior, you can implement the Runnable interface and pass it to a Thread object. class MyRunnable implements Runnable { @Override public void run() { System.out.println(\"Runnable thread is running\"); } } public class ThreadExample { public static void main(String[] args) { MyRunnable runnable = new MyRunnable(); // Creating a Runnable object Thread thread = new Thread(runnable); // Creating a thread with Runnable thread.start(); // Starting the thread } }","title":"Thread"},{"location":"java/Thread/#thread","text":"A Thread is a lightweight process, and the basic unit of execution within a Java application. Threads allow multiple operations to run concurrently, making programs more efficient, especially in multi-core systems.","title":"Thread"},{"location":"java/Thread/#creating-a-thread-using-thread-class","text":"The Thread class provides several methods to control the execution of threads. To create a thread, you can either subclass Thread or implement the Runnable interface.","title":"Creating a Thread using Thread Class:"},{"location":"java/Thread/#1-subclassing-the-thread-class","text":"class MyThread extends Thread { @Override public void run() { // Code to be executed by the thread System.out.println(\"Thread is running\"); } } public class ThreadExample { public static void main(String[] args) { MyThread thread = new MyThread(); // Creating a thread thread.start(); // Starting the thread (calls the run method) } }","title":"1. Subclassing the Thread class:"},{"location":"java/Thread/#2-implementing-the-runnable-interface","text":"If you want to define your own thread behavior, you can implement the Runnable interface and pass it to a Thread object. class MyRunnable implements Runnable { @Override public void run() { System.out.println(\"Runnable thread is running\"); } } public class ThreadExample { public static void main(String[] args) { MyRunnable runnable = new MyRunnable(); // Creating a Runnable object Thread thread = new Thread(runnable); // Creating a thread with Runnable thread.start(); // Starting the thread } }","title":"2. Implementing the Runnable interface:"},{"location":"java/introduction/","text":"Introduction Java is a widely-used, object-oriented programming language known for its robustness, portability, and versatility. Below are the key features of Java: 1. Object-Oriented Everything in Java is treated as an object, which makes it easier to model real-world systems. Key principles: Encapsulation , Inheritance , Polymorphism , and Abstraction . 2. Platform-Independent Java programs are compiled into bytecode by the Java Compiler. Bytecode is platform-independent and runs on any system with a Java Virtual Machine (JVM) . 3. Simple Java eliminates complex features like pointers and multiple inheritance found in C++. Its syntax is straightforward and easy to learn, especially for those familiar with C/C++. 4. Secure Java includes features like a runtime environment and bytecode verification, making it resistant to tampering and viruses. No explicit pointers reduce vulnerabilities. 5. Robust Strong memory management through garbage collection. Exception handling and type-checking mechanisms ensure reliable code. 6. Multithreading Java supports multithreading, enabling programs to perform multiple tasks simultaneously. Threads are lightweight and efficient, managed by the JVM. 7. High Performance Java's Just-In-Time (JIT) compiler improves performance by converting bytecode to machine code at runtime. 8. Portable Write Once, Run Anywhere ( WORA )\u2014the compiled bytecode can run on any system with a JVM. 9. Distributed Java has libraries like RMI (Remote Method Invocation) and CORBA (Common Object Request Broker Architecture) for building distributed applications. 10. Dynamic Java supports dynamic loading of classes (classes are loaded on demand). It supports runtime polymorphism and dynamic method resolution. 11. Architecture-Neutral The bytecode is designed to be compatible with any processor architecture, ensuring portability. 12. Extensive APIs Java provides a rich set of APIs for various functionalities, such as collections, networking, multithreading, and more. 13. Automatic Memory Management Java's Garbage Collector automatically handles memory allocation and deallocation, reducing the chances of memory leaks. 14. Built-in Libraries and Tools Java offers comprehensive libraries for tasks like database access (JDBC), XML parsing, and more. Tools like JDK (Java Development Kit) include a debugger, compiler, and other utilities. 15. Functional Programming Features (Since Java 8) Lambda expressions, Stream API, and default methods in interfaces introduced functional programming capabilities. 16. Modularity (Since Java 9) The introduction of the Java Platform Module System (JPMS) allows developers to create modular and scalable applications. 17. Rich Ecosystem Java has a vast ecosystem, including frameworks like Spring, Hibernate, and tools for web development, testing, and deployment. If you'd like to dive deeper into any specific feature or discuss Java's evolution, let me know!","title":"Introduction"},{"location":"java/introduction/#introduction","text":"Java is a widely-used, object-oriented programming language known for its robustness, portability, and versatility. Below are the key features of Java:","title":"Introduction"},{"location":"java/introduction/#1-object-oriented","text":"Everything in Java is treated as an object, which makes it easier to model real-world systems. Key principles: Encapsulation , Inheritance , Polymorphism , and Abstraction .","title":"1. Object-Oriented"},{"location":"java/introduction/#2-platform-independent","text":"Java programs are compiled into bytecode by the Java Compiler. Bytecode is platform-independent and runs on any system with a Java Virtual Machine (JVM) .","title":"2. Platform-Independent"},{"location":"java/introduction/#3-simple","text":"Java eliminates complex features like pointers and multiple inheritance found in C++. Its syntax is straightforward and easy to learn, especially for those familiar with C/C++.","title":"3. Simple"},{"location":"java/introduction/#4-secure","text":"Java includes features like a runtime environment and bytecode verification, making it resistant to tampering and viruses. No explicit pointers reduce vulnerabilities.","title":"4. Secure"},{"location":"java/introduction/#5-robust","text":"Strong memory management through garbage collection. Exception handling and type-checking mechanisms ensure reliable code.","title":"5. Robust"},{"location":"java/introduction/#6-multithreading","text":"Java supports multithreading, enabling programs to perform multiple tasks simultaneously. Threads are lightweight and efficient, managed by the JVM.","title":"6. Multithreading"},{"location":"java/introduction/#7-high-performance","text":"Java's Just-In-Time (JIT) compiler improves performance by converting bytecode to machine code at runtime.","title":"7. High Performance"},{"location":"java/introduction/#8-portable","text":"Write Once, Run Anywhere ( WORA )\u2014the compiled bytecode can run on any system with a JVM.","title":"8. Portable"},{"location":"java/introduction/#9-distributed","text":"Java has libraries like RMI (Remote Method Invocation) and CORBA (Common Object Request Broker Architecture) for building distributed applications.","title":"9. Distributed"},{"location":"java/introduction/#10-dynamic","text":"Java supports dynamic loading of classes (classes are loaded on demand). It supports runtime polymorphism and dynamic method resolution.","title":"10. Dynamic"},{"location":"java/introduction/#11-architecture-neutral","text":"The bytecode is designed to be compatible with any processor architecture, ensuring portability.","title":"11. Architecture-Neutral"},{"location":"java/introduction/#12-extensive-apis","text":"Java provides a rich set of APIs for various functionalities, such as collections, networking, multithreading, and more.","title":"12. Extensive APIs"},{"location":"java/introduction/#13-automatic-memory-management","text":"Java's Garbage Collector automatically handles memory allocation and deallocation, reducing the chances of memory leaks.","title":"13. Automatic Memory Management"},{"location":"java/introduction/#14-built-in-libraries-and-tools","text":"Java offers comprehensive libraries for tasks like database access (JDBC), XML parsing, and more. Tools like JDK (Java Development Kit) include a debugger, compiler, and other utilities.","title":"14. Built-in Libraries and Tools"},{"location":"java/introduction/#15-functional-programming-features-since-java-8","text":"Lambda expressions, Stream API, and default methods in interfaces introduced functional programming capabilities.","title":"15. Functional Programming Features (Since Java 8)"},{"location":"java/introduction/#16-modularity-since-java-9","text":"The introduction of the Java Platform Module System (JPMS) allows developers to create modular and scalable applications.","title":"16. Modularity (Since Java 9)"},{"location":"java/introduction/#17-rich-ecosystem","text":"Java has a vast ecosystem, including frameworks like Spring, Hibernate, and tools for web development, testing, and deployment. If you'd like to dive deeper into any specific feature or discuss Java's evolution, let me know!","title":"17. Rich Ecosystem"},{"location":"microservices/ConfigServer/","text":"Spring Cloud Config Server Setup In a Spring Boot microservices architecture, a Config Server is used to centralize and manage the configuration of all microservices. The following steps show how to set up a Spring Cloud Config Server and configure the microservices to consume configurations. 1. Spring Cloud Config Server Setup a. Add Dependencies to pom.xml To enable Spring Cloud Config Server in your project, add the following dependency: <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-config</artifactId> </dependency> b. Enable Config Server in Your Application In the main application class of your Config Server, add the @EnableConfigServer annotation: @SpringBootApplication @EnableConfigServer public class ConfigServerApplication { public static void main(String[] args) { SpringApplication.run(ConfigServerApplication.class, args); } } c. Configuration in application.properties Configure the Config Server to source the properties (e.g., from a Git repository): # Config Server Settings spring.application.name=config-server server.port=8071 # Git repository configuration for the config server spring.cloud.config.server.git.uri=https://github.com/your-org/your-config-repo spring.cloud.config.server.git.clone-on-start=true # Optionally, if you want to use file system # spring.cloud.config.server.native.search-locations=file:///path/to/configs 2. Config Client Setup Each microservice (client) that will fetch configurations from the Config Server needs to follow these steps. a. Add Dependencies to pom.xml Add the following dependency in the microservice's pom.xml file: <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-config</artifactId> </dependency> b. Enable Configuration in application.properties In your client microservice, specify the URI of the Config Server in the application.yml file: # Config Client Settings spring.application.name=your-service-name spring.profiles.active=default # URI of the Config Server spring.cloud.config.uri=http://localhost:8071 # Optionally, define a timeout for the connection to the Config Server spring.cloud.config.timeout=1000 3. Config Server Data Source The Config Server can source configuration from different locations: a. Git Repository Store configuration files (such as application.properties or application.yml) in a Git repository. The uri configuration in the Config Server should point to this Git repository. b. File System The Config Server can read configuration files directly from the local file system. c. Vault You can configure the Config Server to read from HashiCorp Vault for more secure configuration management. Example Structure in a Git Repo: In your Git repository, you might store the configuration for different applications like this: your-service-name-dev.properties : Configuration file for your service in the development environment. your-service-name-prod.properties : Configuration file for your service in the production environment. application-dev.properties : General configuration for the application in the development environment. application-prod.properties : General configuration for the application in the production environment. bootstrap.yml : Contains configuration that is loaded during the initialization phase of the application. You can use these configuration files to manage different environments for your applications.","title":"Configserver"},{"location":"microservices/ConfigServer/#spring-cloud-config-server-setup","text":"In a Spring Boot microservices architecture, a Config Server is used to centralize and manage the configuration of all microservices. The following steps show how to set up a Spring Cloud Config Server and configure the microservices to consume configurations.","title":"Spring Cloud Config Server Setup"},{"location":"microservices/ConfigServer/#1-spring-cloud-config-server-setup","text":"","title":"1. Spring Cloud Config Server Setup"},{"location":"microservices/ConfigServer/#a-add-dependencies-to-pomxml","text":"To enable Spring Cloud Config Server in your project, add the following dependency: <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-config</artifactId> </dependency>","title":"a. Add Dependencies to pom.xml"},{"location":"microservices/ConfigServer/#b-enable-config-server-in-your-application","text":"In the main application class of your Config Server, add the @EnableConfigServer annotation: @SpringBootApplication @EnableConfigServer public class ConfigServerApplication { public static void main(String[] args) { SpringApplication.run(ConfigServerApplication.class, args); } }","title":"b. Enable Config Server in Your Application"},{"location":"microservices/ConfigServer/#c-configuration-in-applicationproperties","text":"Configure the Config Server to source the properties (e.g., from a Git repository): # Config Server Settings spring.application.name=config-server server.port=8071 # Git repository configuration for the config server spring.cloud.config.server.git.uri=https://github.com/your-org/your-config-repo spring.cloud.config.server.git.clone-on-start=true # Optionally, if you want to use file system # spring.cloud.config.server.native.search-locations=file:///path/to/configs","title":"c. Configuration in application.properties"},{"location":"microservices/ConfigServer/#2-config-client-setup","text":"Each microservice (client) that will fetch configurations from the Config Server needs to follow these steps.","title":"2. Config Client Setup"},{"location":"microservices/ConfigServer/#a-add-dependencies-to-pomxml_1","text":"Add the following dependency in the microservice's pom.xml file: <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-config</artifactId> </dependency>","title":"a. Add Dependencies to pom.xml"},{"location":"microservices/ConfigServer/#b-enable-configuration-in-applicationproperties","text":"In your client microservice, specify the URI of the Config Server in the application.yml file: # Config Client Settings spring.application.name=your-service-name spring.profiles.active=default # URI of the Config Server spring.cloud.config.uri=http://localhost:8071 # Optionally, define a timeout for the connection to the Config Server spring.cloud.config.timeout=1000","title":"b. Enable Configuration in application.properties"},{"location":"microservices/ConfigServer/#3-config-server-data-source","text":"The Config Server can source configuration from different locations:","title":"3. Config Server Data Source"},{"location":"microservices/ConfigServer/#a-git-repository","text":"Store configuration files (such as application.properties or application.yml) in a Git repository. The uri configuration in the Config Server should point to this Git repository.","title":"a. Git Repository"},{"location":"microservices/ConfigServer/#b-file-system","text":"The Config Server can read configuration files directly from the local file system.","title":"b. File System"},{"location":"microservices/ConfigServer/#c-vault","text":"You can configure the Config Server to read from HashiCorp Vault for more secure configuration management. Example Structure in a Git Repo: In your Git repository, you might store the configuration for different applications like this: your-service-name-dev.properties : Configuration file for your service in the development environment. your-service-name-prod.properties : Configuration file for your service in the production environment. application-dev.properties : General configuration for the application in the development environment. application-prod.properties : General configuration for the application in the production environment. bootstrap.yml : Contains configuration that is loaded during the initialization phase of the application. You can use these configuration files to manage different environments for your applications.","title":"c. Vault"},{"location":"microservices/EurekaServer/","text":"Setting Up Eureka Server with Spring Boot Eureka is a service discovery tool that helps microservices communicate with each other by dynamically registering and discovering services. 1. Add Dependencies in pom.xml If you are using Maven, add the following dependencies in your pom.xml : <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId> </dependency> Also, ensure the Spring Cloud dependency management is included: <dependencyManagement> <repositories> <repository> <id>spring-milestones</id> <url>https://repo.spring.io/milestone</url> </repository> </repositories> </dependencyManagement> <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter</artifactId> </dependency> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId> </dependency> </dependencies> 2. Enable Eureka Server in Your Application In your main application class, enable Eureka Server with the @EnableEurekaServer annotation: package com.example.eurekaserver; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer; @SpringBootApplication @EnableEurekaServer public class EurekaServerApplication { public static void main(String[] args) { SpringApplication.run(EurekaServerApplication.class, args); } } 3. Configure application.yml or application.properties In the src/main/resources/application.properties, add the following Eureka configuration: server.port=8761 #Tells the server not to look for services since it is the server. eureka.client.fetch-registry=false #Prevents the Eureka server from registering itself as a client. eureka.client.register-with-eureka=false 4. Run the Eureka Server Run the Eureka server application. Once the application is up, visit http://localhost:8761/ to view the Eureka dashboard where you can see all registered microservices. 5. Register Clients with Eureka Server For each microservice you want to register with Eureka, follow these steps: Add the spring-cloud-starter-netflix-eureka-client dependency. Add the following configuration in application.yml or application.properties: eureka.client.fetch-registry=true eureka.client.register-with-eureka=true eureka.client.service-url.default-zone=http://localhost:8761/eureka/ This configuration registers your client with the Eureka server running at http://localhost:8761/eureka/.","title":"Eureka Server"},{"location":"microservices/EurekaServer/#setting-up-eureka-server-with-spring-boot","text":"Eureka is a service discovery tool that helps microservices communicate with each other by dynamically registering and discovering services.","title":"Setting Up Eureka Server with Spring Boot"},{"location":"microservices/EurekaServer/#1-add-dependencies-in-pomxml","text":"If you are using Maven, add the following dependencies in your pom.xml : <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId> </dependency> Also, ensure the Spring Cloud dependency management is included: <dependencyManagement> <repositories> <repository> <id>spring-milestones</id> <url>https://repo.spring.io/milestone</url> </repository> </repositories> </dependencyManagement> <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter</artifactId> </dependency> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId> </dependency> </dependencies>","title":"1. Add Dependencies in pom.xml"},{"location":"microservices/EurekaServer/#2-enable-eureka-server-in-your-application","text":"In your main application class, enable Eureka Server with the @EnableEurekaServer annotation: package com.example.eurekaserver; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer; @SpringBootApplication @EnableEurekaServer public class EurekaServerApplication { public static void main(String[] args) { SpringApplication.run(EurekaServerApplication.class, args); } }","title":"2. Enable Eureka Server in Your Application"},{"location":"microservices/EurekaServer/#3-configure-applicationyml-or-applicationproperties","text":"In the src/main/resources/application.properties, add the following Eureka configuration: server.port=8761 #Tells the server not to look for services since it is the server. eureka.client.fetch-registry=false #Prevents the Eureka server from registering itself as a client. eureka.client.register-with-eureka=false","title":"3. Configure application.yml or application.properties"},{"location":"microservices/EurekaServer/#4-run-the-eureka-server","text":"Run the Eureka server application. Once the application is up, visit http://localhost:8761/ to view the Eureka dashboard where you can see all registered microservices.","title":"4. Run the Eureka Server"},{"location":"microservices/EurekaServer/#5-register-clients-with-eureka-server","text":"For each microservice you want to register with Eureka, follow these steps: Add the spring-cloud-starter-netflix-eureka-client dependency. Add the following configuration in application.yml or application.properties: eureka.client.fetch-registry=true eureka.client.register-with-eureka=true eureka.client.service-url.default-zone=http://localhost:8761/eureka/ This configuration registers your client with the Eureka server running at http://localhost:8761/eureka/.","title":"5. Register Clients with Eureka Server"},{"location":"microservices/FeignClient/","text":"Feign Client FeignClient is a declarative REST client provided by Spring Cloud. It simplifies making HTTP calls to external REST services by providing an easy-to-use interface. Here's a guide to understanding and implementing a FeignClient: Key Features Declarative Syntax: Annotate methods with @RequestMapping-like annotations to define API calls. Built-in Load Balancing: Works seamlessly with Ribbon for client-side load balancing (if Ribbon is in use). Error Handling: Custom error handling with ErrorDecoder. Integration: Supports HTTP request/response handling, including headers and parameters. Basic Setup 1. Add Dependencies Add the Spring Cloud OpenFeign dependency to your pom.xml: <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-openfeign</artifactId> </dependency> Also, ensure your spring-cloud-dependencies version is included in the dependency management: <dependencyManagement> <dependencies> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-dependencies</artifactId> <version>2023.0.3</version> <type>pom</type> <scope>import</scope> </dependency> </dependencies> </dependencyManagement> 2. Enable Feign Clients Add the @EnableFeignClients annotation in your Spring Boot application class: @SpringBootApplication @EnableFeignClients public class FeignExampleApplication { public static void main(String[] args) { SpringApplication.run(FeignExampleApplication.class, args); } } 3. Create Feign Client Interface Define an interface annotated with @FeignClient. For example: Copy code @FeignClient(name = \"user-service\", url = \"http://localhost:8080\") public interface UserServiceClient { @GetMapping(\"/users/{id}\") User getUserById(@PathVariable(\"id\") Long id); @PostMapping(\"/users\") User createUser(@RequestBody User user); } 4. Use the Feign Client Inject and use the Feign client in your services or controllers: @Service public class UserService { private final UserServiceClient userServiceClient; public UserService(UserServiceClient userServiceClient) { this.userServiceClient = userServiceClient; } public User getUser(Long id) { return userServiceClient.getUserById(id); } public User createUser(User user) { return userServiceClient.createUser(user); } }","title":"FeignClient"},{"location":"microservices/FeignClient/#feign-client","text":"FeignClient is a declarative REST client provided by Spring Cloud. It simplifies making HTTP calls to external REST services by providing an easy-to-use interface. Here's a guide to understanding and implementing a FeignClient:","title":"Feign Client"},{"location":"microservices/FeignClient/#key-features","text":"Declarative Syntax: Annotate methods with @RequestMapping-like annotations to define API calls. Built-in Load Balancing: Works seamlessly with Ribbon for client-side load balancing (if Ribbon is in use). Error Handling: Custom error handling with ErrorDecoder. Integration: Supports HTTP request/response handling, including headers and parameters.","title":"Key Features"},{"location":"microservices/FeignClient/#basic-setup","text":"","title":"Basic Setup"},{"location":"microservices/FeignClient/#1-add-dependencies","text":"Add the Spring Cloud OpenFeign dependency to your pom.xml: <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-openfeign</artifactId> </dependency> Also, ensure your spring-cloud-dependencies version is included in the dependency management: <dependencyManagement> <dependencies> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-dependencies</artifactId> <version>2023.0.3</version> <type>pom</type> <scope>import</scope> </dependency> </dependencies> </dependencyManagement>","title":"1. Add Dependencies"},{"location":"microservices/FeignClient/#2-enable-feign-clients","text":"Add the @EnableFeignClients annotation in your Spring Boot application class: @SpringBootApplication @EnableFeignClients public class FeignExampleApplication { public static void main(String[] args) { SpringApplication.run(FeignExampleApplication.class, args); } }","title":"2. Enable Feign Clients"},{"location":"microservices/FeignClient/#3-create-feign-client-interface","text":"Define an interface annotated with @FeignClient. For example: Copy code @FeignClient(name = \"user-service\", url = \"http://localhost:8080\") public interface UserServiceClient { @GetMapping(\"/users/{id}\") User getUserById(@PathVariable(\"id\") Long id); @PostMapping(\"/users\") User createUser(@RequestBody User user); }","title":"3. Create Feign Client Interface"},{"location":"microservices/FeignClient/#4-use-the-feign-client","text":"Inject and use the Feign client in your services or controllers: @Service public class UserService { private final UserServiceClient userServiceClient; public UserService(UserServiceClient userServiceClient) { this.userServiceClient = userServiceClient; } public User getUser(Long id) { return userServiceClient.getUserById(id); } public User createUser(User user) { return userServiceClient.createUser(user); } }","title":"4. Use the Feign Client"},{"location":"microservices/Gateway/","text":"Spring Cloud Gateway Spring Cloud Gateway is a powerful, easy-to-use API Gateway built on top of the Spring Framework, providing a simple, effective way to route and filter requests to different microservices in a Spring Cloud architecture. Key Features Routing Allows routing requests to microservices based on URL paths, headers, etc. Enables dynamic route creation easily. Filters Supports pre- and post-filters for request manipulation (e.g., logging, authentication, adding headers) and response manipulation. Load Balancing Integrates with Spring Cloud Load Balancer , enabling easy load balancing across multiple services. Security Can integrate with Spring Security for authenticating and authorizing incoming requests. Monitoring Supports monitoring and tracing with Spring Cloud Sleuth and Zipkin for observability. Rate Limiting Built-in support for rate-limiting to avoid service overload. API Gateway Handles cross-cutting concerns like logging, metrics, and security centrally. 1. Add Dependencies Add the following dependencies to your pom.xml : <dependencies> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-gateway</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> </dependencies> Ensure the Spring Cloud version is compatible with your Spring Boot version. You may need to include the Spring Cloud BOM for dependency management. 2. Create a Configuration Class Define routes and filters programmatically in a Spring configuration class: import org.springframework.cloud.gateway.route.RouteLocator; import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class GatewayConfig { @Bean public RouteLocator customRouteLocator(RouteLocatorBuilder builder) { return routeLocatorBuilder.routes() .route(p -> p .path(\"/eazybank/accounts/**\") .filters( f -> f.rewritePath(\"/eazybank/accounts/(?<segment>.*)\",\"/${segment}\") .addResponseHeader(\"X-Response-Time\", LocalDateTime.now().toString()) .circuitBreaker(config -> config.setName(\"accountsCircuitBreaker\") .setFallbackUri(\"forward:/contactSupport\"))) .uri(\"lb://ACCOUNTS\")) .route(p -> p .path(\"/eazybank/loans/**\") .filters( f -> f.rewritePath(\"/eazybank/loans/(?<segment>.*)\",\"/${segment}\") .addResponseHeader(\"X-Response-Time\", LocalDateTime.now().toString()) .retry(retryConfig -> retryConfig.setRetries(3) .setMethods(HttpMethod.GET) .setBackoff(Duration.ofMillis(100),Duration.ofMillis(1000),2,true))) .uri(\"lb://LOANS\")) .route(p -> p .path(\"/eazybank/cards/**\") .filters( f -> f.rewritePath(\"/eazybank/cards/(?<segment>.*)\",\"/${segment}\") .addResponseHeader(\"X-Response-Time\", LocalDateTime.now().toString()) .requestRateLimiter(config -> config.setRateLimiter(redisRateLimiter()) .setKeyResolver(userKeyResolver()))) .uri(\"lb://CARDS\")).build(); } }","title":"Spring Cloud Gateway"},{"location":"microservices/Gateway/#spring-cloud-gateway","text":"Spring Cloud Gateway is a powerful, easy-to-use API Gateway built on top of the Spring Framework, providing a simple, effective way to route and filter requests to different microservices in a Spring Cloud architecture.","title":"Spring Cloud Gateway"},{"location":"microservices/Gateway/#key-features","text":"","title":"Key Features"},{"location":"microservices/Gateway/#routing","text":"Allows routing requests to microservices based on URL paths, headers, etc. Enables dynamic route creation easily.","title":"Routing"},{"location":"microservices/Gateway/#filters","text":"Supports pre- and post-filters for request manipulation (e.g., logging, authentication, adding headers) and response manipulation.","title":"Filters"},{"location":"microservices/Gateway/#load-balancing","text":"Integrates with Spring Cloud Load Balancer , enabling easy load balancing across multiple services.","title":"Load Balancing"},{"location":"microservices/Gateway/#security","text":"Can integrate with Spring Security for authenticating and authorizing incoming requests.","title":"Security"},{"location":"microservices/Gateway/#monitoring","text":"Supports monitoring and tracing with Spring Cloud Sleuth and Zipkin for observability.","title":"Monitoring"},{"location":"microservices/Gateway/#rate-limiting","text":"Built-in support for rate-limiting to avoid service overload.","title":"Rate Limiting"},{"location":"microservices/Gateway/#api-gateway","text":"Handles cross-cutting concerns like logging, metrics, and security centrally.","title":"API Gateway"},{"location":"microservices/Gateway/#1-add-dependencies","text":"Add the following dependencies to your pom.xml : <dependencies> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-gateway</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> </dependencies> Ensure the Spring Cloud version is compatible with your Spring Boot version. You may need to include the Spring Cloud BOM for dependency management.","title":"1. Add Dependencies"},{"location":"microservices/Gateway/#2-create-a-configuration-class","text":"Define routes and filters programmatically in a Spring configuration class: import org.springframework.cloud.gateway.route.RouteLocator; import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class GatewayConfig { @Bean public RouteLocator customRouteLocator(RouteLocatorBuilder builder) { return routeLocatorBuilder.routes() .route(p -> p .path(\"/eazybank/accounts/**\") .filters( f -> f.rewritePath(\"/eazybank/accounts/(?<segment>.*)\",\"/${segment}\") .addResponseHeader(\"X-Response-Time\", LocalDateTime.now().toString()) .circuitBreaker(config -> config.setName(\"accountsCircuitBreaker\") .setFallbackUri(\"forward:/contactSupport\"))) .uri(\"lb://ACCOUNTS\")) .route(p -> p .path(\"/eazybank/loans/**\") .filters( f -> f.rewritePath(\"/eazybank/loans/(?<segment>.*)\",\"/${segment}\") .addResponseHeader(\"X-Response-Time\", LocalDateTime.now().toString()) .retry(retryConfig -> retryConfig.setRetries(3) .setMethods(HttpMethod.GET) .setBackoff(Duration.ofMillis(100),Duration.ofMillis(1000),2,true))) .uri(\"lb://LOANS\")) .route(p -> p .path(\"/eazybank/cards/**\") .filters( f -> f.rewritePath(\"/eazybank/cards/(?<segment>.*)\",\"/${segment}\") .addResponseHeader(\"X-Response-Time\", LocalDateTime.now().toString()) .requestRateLimiter(config -> config.setRateLimiter(redisRateLimiter()) .setKeyResolver(userKeyResolver()))) .uri(\"lb://CARDS\")).build(); } }","title":"2. Create a Configuration Class"},{"location":"microservices/Introduction/","text":"Microservices Architecture Microservices is an architectural style that structures an application as a collection of small, loosely coupled, and independently deployable services. Each service in a microservices architecture typically corresponds to a specific business functionality, and they communicate with each other through APIs, often using HTTP/REST or messaging systems. Key Characteristics of Microservices: Independent Deployability : Microservices can be developed, tested, deployed, and scaled independently of each other. Domain-Driven Design : Microservices are usually organized around business capabilities, making them easier to manage and scale. Technology Agnostic : Each microservice can be built using a different technology stack, depending on the requirements. Resilience : Microservices are designed to handle failures gracefully. If one service fails, it doesn't bring down the entire system. Scalability : Individual services can be scaled independently based on demand, improving resource utilization. Benefits of Microservices: Flexibility : Teams can work on different services concurrently, enabling faster development and deployment. Resilience : Failure in one service doesn't affect the whole application. Scalability : Services can be scaled independently. Faster Time to Market : Smaller codebases are easier to manage and deploy. Challenges of Microservices: Complexity : Managing many services, each with its own database and communication mechanisms, can be complex. Data Consistency : Maintaining consistency across services can be challenging, especially when services have their own databases. Distributed Systems Issues : Issues such as latency, failure handling, and monitoring across multiple services can be tricky. DevOps : Requires strong DevOps practices for deployment, monitoring, and maintenance. Typical Microservices Components: API Gateway : Acts as a single entry point for all requests to the microservices. Service Discovery : Helps locate services dynamically and manage their IP addresses and ports. Database per Service : Each service typically has its own database to ensure independence. Message Brokers : Used for communication between services, especially in event-driven architectures.","title":"Introduction"},{"location":"microservices/Introduction/#microservices-architecture","text":"Microservices is an architectural style that structures an application as a collection of small, loosely coupled, and independently deployable services. Each service in a microservices architecture typically corresponds to a specific business functionality, and they communicate with each other through APIs, often using HTTP/REST or messaging systems.","title":"Microservices Architecture"},{"location":"microservices/Introduction/#key-characteristics-of-microservices","text":"Independent Deployability : Microservices can be developed, tested, deployed, and scaled independently of each other. Domain-Driven Design : Microservices are usually organized around business capabilities, making them easier to manage and scale. Technology Agnostic : Each microservice can be built using a different technology stack, depending on the requirements. Resilience : Microservices are designed to handle failures gracefully. If one service fails, it doesn't bring down the entire system. Scalability : Individual services can be scaled independently based on demand, improving resource utilization.","title":"Key Characteristics of Microservices:"},{"location":"microservices/Introduction/#benefits-of-microservices","text":"Flexibility : Teams can work on different services concurrently, enabling faster development and deployment. Resilience : Failure in one service doesn't affect the whole application. Scalability : Services can be scaled independently. Faster Time to Market : Smaller codebases are easier to manage and deploy.","title":"Benefits of Microservices:"},{"location":"microservices/Introduction/#challenges-of-microservices","text":"Complexity : Managing many services, each with its own database and communication mechanisms, can be complex. Data Consistency : Maintaining consistency across services can be challenging, especially when services have their own databases. Distributed Systems Issues : Issues such as latency, failure handling, and monitoring across multiple services can be tricky. DevOps : Requires strong DevOps practices for deployment, monitoring, and maintenance.","title":"Challenges of Microservices:"},{"location":"microservices/Introduction/#typical-microservices-components","text":"API Gateway : Acts as a single entry point for all requests to the microservices. Service Discovery : Helps locate services dynamically and manage their IP addresses and ports. Database per Service : Each service typically has its own database to ensure independence. Message Brokers : Used for communication between services, especially in event-driven architectures.","title":"Typical Microservices Components:"},{"location":"microservices/Resiliency/","text":"Resiliency Resilience4j is a lightweight and easy-to-use library for building resilient systems in Java. It provides fault tolerance and resilience patterns like circuit breaker, rate limiter, bulkhead, retry, and time limiter. Steps to Integrate Resilience4j with Spring Boot 1. Add Dependencies Include the required Resilience4j modules in your pom.xml if you're using Maven: <dependency> <groupId>io.github.resilience4j</groupId> <artifactId>resilience4j-spring-boot3</artifactId> <version>2.0.2</version> <!-- Replace with the latest version --> </dependency> 2. Enable Resilience4j Resilience4j automatically configures itself in a Spring Boot application. You just need to create configuration properties in your application.yml or application.properties file. 2.1. Retry Configuration To set up retry for a specific service method, you can configure it in application.properties like this: resilience4j.retry.instances.myServiceRetry.maxAttempts=3 resilience4j.retry.instances.myServiceRetry.waitDuration=500ms resilience4j.retry.instances.myServiceRetry.enableExponentialBackoff=true resilience4j.retry.instances.myServiceRetry.randomize=true maxAttempts: The maximum number of retry attempts (e.g., 3). waitDuration: The wait time between retry attempts (e.g., 500ms). enableExponentialBackoff: Enable exponential backoff between retries. randomize: Randomize the backoff duration to avoid retries happening at the same time. 2.2. Circuit Breaker Configuration For a circuit breaker, configure it like so: resilience4j.circuitbreaker.instances.myServiceCircuitBreaker.registerHealthIndicator=true resilience4j.circuitbreaker.instances.myServiceCircuitBreaker.slidingWindowSize=10 resilience4j.circuitbreaker.instances.myServiceCircuitBreaker.failureRateThreshold=50 resilience4j.circuitbreaker.instances.myServiceCircuitBreaker.waitDurationInOpenState=10000ms slidingWindowSize: Defines the number of calls to consider for calculating failure rate. failureRateThreshold: Percentage of failures above which the circuit breaker will open (e.g., 50%). waitDurationInOpenState: Time the circuit breaker will stay open before attempting to close again. 2.3. Rate Limiter Configuration To limit the number of calls in a given time period, use: resilience4j.ratelimiter.instances.myServiceRateLimiter.limitForPeriod=5 resilience4j.ratelimiter.instances.myServiceRateLimiter.limitRefreshPeriod=1s resilience4j.ratelimiter.instances.myServiceRateLimiter.timeoutDuration=500ms limitForPeriod: Maximum number of requests allowed in the specified period. limitRefreshPeriod: Time interval for refreshing the rate limit (e.g., 1 second). timeoutDuration: Timeout if the rate limit is exceeded. Example @Retry(name = \"myServiceRetry\") @CircuitBreaker(name = \"myServiceCircuitBreaker\") If 5 requests have already been made within 1 second, additional requests will be queued for up to 500 milliseconds. If the queued request cannot proceed within the timeout period, it will fail (typically by throwing a RequestNotPermitted exception).","title":"Resiliency"},{"location":"microservices/Resiliency/#resiliency","text":"Resilience4j is a lightweight and easy-to-use library for building resilient systems in Java. It provides fault tolerance and resilience patterns like circuit breaker, rate limiter, bulkhead, retry, and time limiter.","title":"Resiliency"},{"location":"microservices/Resiliency/#steps-to-integrate-resilience4j-with-spring-boot","text":"","title":"Steps to Integrate Resilience4j with Spring Boot"},{"location":"microservices/Resiliency/#1-add-dependencies","text":"Include the required Resilience4j modules in your pom.xml if you're using Maven: <dependency> <groupId>io.github.resilience4j</groupId> <artifactId>resilience4j-spring-boot3</artifactId> <version>2.0.2</version> <!-- Replace with the latest version --> </dependency>","title":"1. Add Dependencies"},{"location":"microservices/Resiliency/#2-enable-resilience4j","text":"Resilience4j automatically configures itself in a Spring Boot application. You just need to create configuration properties in your application.yml or application.properties file.","title":"2. Enable Resilience4j"},{"location":"microservices/Resiliency/#21-retry-configuration","text":"To set up retry for a specific service method, you can configure it in application.properties like this: resilience4j.retry.instances.myServiceRetry.maxAttempts=3 resilience4j.retry.instances.myServiceRetry.waitDuration=500ms resilience4j.retry.instances.myServiceRetry.enableExponentialBackoff=true resilience4j.retry.instances.myServiceRetry.randomize=true maxAttempts: The maximum number of retry attempts (e.g., 3). waitDuration: The wait time between retry attempts (e.g., 500ms). enableExponentialBackoff: Enable exponential backoff between retries. randomize: Randomize the backoff duration to avoid retries happening at the same time.","title":"2.1. Retry Configuration"},{"location":"microservices/Resiliency/#22-circuit-breaker-configuration","text":"For a circuit breaker, configure it like so: resilience4j.circuitbreaker.instances.myServiceCircuitBreaker.registerHealthIndicator=true resilience4j.circuitbreaker.instances.myServiceCircuitBreaker.slidingWindowSize=10 resilience4j.circuitbreaker.instances.myServiceCircuitBreaker.failureRateThreshold=50 resilience4j.circuitbreaker.instances.myServiceCircuitBreaker.waitDurationInOpenState=10000ms slidingWindowSize: Defines the number of calls to consider for calculating failure rate. failureRateThreshold: Percentage of failures above which the circuit breaker will open (e.g., 50%). waitDurationInOpenState: Time the circuit breaker will stay open before attempting to close again.","title":"2.2. Circuit Breaker Configuration"},{"location":"microservices/Resiliency/#23-rate-limiter-configuration","text":"To limit the number of calls in a given time period, use: resilience4j.ratelimiter.instances.myServiceRateLimiter.limitForPeriod=5 resilience4j.ratelimiter.instances.myServiceRateLimiter.limitRefreshPeriod=1s resilience4j.ratelimiter.instances.myServiceRateLimiter.timeoutDuration=500ms limitForPeriod: Maximum number of requests allowed in the specified period. limitRefreshPeriod: Time interval for refreshing the rate limit (e.g., 1 second). timeoutDuration: Timeout if the rate limit is exceeded.","title":"2.3. Rate Limiter Configuration"},{"location":"microservices/Resiliency/#example","text":"@Retry(name = \"myServiceRetry\") @CircuitBreaker(name = \"myServiceCircuitBreaker\") If 5 requests have already been made within 1 second, additional requests will be queued for up to 500 milliseconds. If the queued request cannot proceed within the timeout period, it will fail (typically by throwing a RequestNotPermitted exception).","title":"Example"},{"location":"microservices/SpringCloudFunction/","text":"Spring Cloud Function Spring Cloud Function enables the development of business logic as functions and decouples the development lifecycle from deployment. It allows you to write reusable and easily deployable functional code for various environments like AWS Lambda, Azure, or on-premise. Key Features Write Once, Run Anywhere : Develop functions independently of the runtime. Adaptable : Deploy on AWS Lambda, Azure Functions, Apache OpenWhisk, or your own server. Streamlined Testing : Write and test your function locally. Efficient : Focus on business logic without worrying about infrastructure. Getting Started 1. Add Dependencies In your pom.xml , include: <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-function-web</artifactId> </dependency> 2. Create a Function Write a function as a bean in a Spring Boot application. Example : A function that converts strings to uppercase. import org.springframework.context.annotation.Bean; import org.springframework.stereotype.Component; import java.util.function.Function; @Component public class FunctionExample { @Bean public Function<String, String> toUpperCase() { return input -> input.toUpperCase(); } } Deploying to the Cloud 1. AWS Lambda Add the AWS adapter dependency: <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-function-adapter-aws</artifactId> </dependency> Then package your app as a .jar and deploy to AWS Lambda. 2. Azure Functions Add the Azure adapter dependency: <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-function-adapter-azure</artifactId> </dependency>","title":"Spring Cloud Function"},{"location":"microservices/SpringCloudFunction/#spring-cloud-function","text":"Spring Cloud Function enables the development of business logic as functions and decouples the development lifecycle from deployment. It allows you to write reusable and easily deployable functional code for various environments like AWS Lambda, Azure, or on-premise.","title":"Spring Cloud Function"},{"location":"microservices/SpringCloudFunction/#key-features","text":"Write Once, Run Anywhere : Develop functions independently of the runtime. Adaptable : Deploy on AWS Lambda, Azure Functions, Apache OpenWhisk, or your own server. Streamlined Testing : Write and test your function locally. Efficient : Focus on business logic without worrying about infrastructure.","title":"Key Features"},{"location":"microservices/SpringCloudFunction/#getting-started","text":"","title":"Getting Started"},{"location":"microservices/SpringCloudFunction/#1-add-dependencies","text":"In your pom.xml , include: <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-function-web</artifactId> </dependency>","title":"1. Add Dependencies"},{"location":"microservices/SpringCloudFunction/#2-create-a-function","text":"Write a function as a bean in a Spring Boot application. Example : A function that converts strings to uppercase. import org.springframework.context.annotation.Bean; import org.springframework.stereotype.Component; import java.util.function.Function; @Component public class FunctionExample { @Bean public Function<String, String> toUpperCase() { return input -> input.toUpperCase(); } }","title":"2. Create a Function"},{"location":"microservices/SpringCloudFunction/#deploying-to-the-cloud","text":"","title":"Deploying to the Cloud"},{"location":"microservices/SpringCloudFunction/#1-aws-lambda","text":"Add the AWS adapter dependency: <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-function-adapter-aws</artifactId> </dependency> Then package your app as a .jar and deploy to AWS Lambda.","title":"1. AWS Lambda"},{"location":"microservices/SpringCloudFunction/#2-azure-functions","text":"Add the Azure adapter dependency: <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-function-adapter-azure</artifactId> </dependency>","title":"2. Azure Functions"},{"location":"microservices/SpringCloudSleuth/","text":"Spring Cloud Sleuth Spring Cloud Sleuth is a distributed tracing solution that helps in tracking the flow of requests across various microservices in a system. It adds trace and span IDs to logs and other metadata, enabling you to track how requests propagate across different services. This helps in debugging, monitoring, and identifying performance bottlenecks in microservices-based applications. Key Concepts: Trace : A trace represents the entire journey of a request as it passes through different services. Span : A span is a single unit of work within a trace, typically representing the processing time in a specific service. Trace ID : A unique identifier for a trace that helps link all the related spans together. Span ID : A unique identifier for a span. It allows tracking the individual work done in a service. Features: Context Propagation : Sleuth automatically propagates the trace and span information across different services using HTTP headers (or other protocols). Integration with Logging : It integrates with popular logging frameworks (like SLF4J) to automatically include trace and span IDs in the logs. Integration with Monitoring Systems : Sleuth can work with monitoring systems like Zipkin or OpenTelemetry to visualize traces. Setup in a Spring Boot Application: 1. Add Dependencies: To get started, include the following dependencies in your pom.xml for Maven or build.gradle for Gradle. <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-sleuth</artifactId> </dependency> 2. Configuration: Spring Cloud Sleuth is often configured automatically with Spring Boot. However, you can customize its behavior in the application.properties or application.yml. spring.sleuth.sampler.probability=1.0 # 100% of requests are traced spring.sleuth.integration.enabled=true # Enable integration with messaging systems 3. Integration with Zipkin: If you want to send traces to Zipkin, you can add the Zipkin dependency: <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-zipkin</artifactId> </dependency> Configuration for Zipkin: spring.zipkin.base-url=http://localhost:9411/ spring.sleuth.sampler.probability=1.0","title":"SpringCloudSleuth"},{"location":"microservices/SpringCloudSleuth/#spring-cloud-sleuth","text":"Spring Cloud Sleuth is a distributed tracing solution that helps in tracking the flow of requests across various microservices in a system. It adds trace and span IDs to logs and other metadata, enabling you to track how requests propagate across different services. This helps in debugging, monitoring, and identifying performance bottlenecks in microservices-based applications.","title":"Spring Cloud Sleuth"},{"location":"microservices/SpringCloudSleuth/#key-concepts","text":"Trace : A trace represents the entire journey of a request as it passes through different services. Span : A span is a single unit of work within a trace, typically representing the processing time in a specific service. Trace ID : A unique identifier for a trace that helps link all the related spans together. Span ID : A unique identifier for a span. It allows tracking the individual work done in a service.","title":"Key Concepts:"},{"location":"microservices/SpringCloudSleuth/#features","text":"Context Propagation : Sleuth automatically propagates the trace and span information across different services using HTTP headers (or other protocols). Integration with Logging : It integrates with popular logging frameworks (like SLF4J) to automatically include trace and span IDs in the logs. Integration with Monitoring Systems : Sleuth can work with monitoring systems like Zipkin or OpenTelemetry to visualize traces.","title":"Features:"},{"location":"microservices/SpringCloudSleuth/#setup-in-a-spring-boot-application","text":"","title":"Setup in a Spring Boot Application:"},{"location":"microservices/SpringCloudSleuth/#1-add-dependencies","text":"To get started, include the following dependencies in your pom.xml for Maven or build.gradle for Gradle. <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-sleuth</artifactId> </dependency>","title":"1. Add Dependencies:"},{"location":"microservices/SpringCloudSleuth/#2-configuration","text":"Spring Cloud Sleuth is often configured automatically with Spring Boot. However, you can customize its behavior in the application.properties or application.yml. spring.sleuth.sampler.probability=1.0 # 100% of requests are traced spring.sleuth.integration.enabled=true # Enable integration with messaging systems","title":"2. Configuration:"},{"location":"microservices/SpringCloudSleuth/#3-integration-with-zipkin","text":"If you want to send traces to Zipkin, you can add the Zipkin dependency: <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-zipkin</artifactId> </dependency> Configuration for Zipkin: spring.zipkin.base-url=http://localhost:9411/ spring.sleuth.sampler.probability=1.0","title":"3. Integration with Zipkin:"},{"location":"microservices/SpringCloudStream/","text":"Spring Cloud Stream: Spring Cloud Stream is a framework for building event-driven microservices using messaging systems like RabbitMQ, Kafka, etc. It abstracts complex messaging system configurations, enabling developers to focus on business logic. Key Concepts 1. Binder Acts as a bridge between your application and the messaging system. Examples: Kafka, RabbitMQ. 2. Input and Output Input: Represents a message consumer. Output: Represents a message producer. 3. Channels Logical names for input/output communication. Channels map to topics, queues, or exchanges in the messaging system. 4. Binding Connects application channels (@Input or @Output) to messaging destinations (e.g., Kafka topics or RabbitMQ queues). How It Works You write business logic using Spring Boot. Spring Cloud Stream manages binding your logic to the messaging system. Messages flow between microservices via configured topics or queues.","title":"Spring Cloud Stream"},{"location":"microservices/SpringCloudStream/#spring-cloud-stream","text":"Spring Cloud Stream is a framework for building event-driven microservices using messaging systems like RabbitMQ, Kafka, etc. It abstracts complex messaging system configurations, enabling developers to focus on business logic.","title":"Spring Cloud Stream:"},{"location":"microservices/SpringCloudStream/#key-concepts","text":"","title":"Key Concepts"},{"location":"microservices/SpringCloudStream/#1-binder","text":"Acts as a bridge between your application and the messaging system. Examples: Kafka, RabbitMQ.","title":"1. Binder"},{"location":"microservices/SpringCloudStream/#2-input-and-output","text":"Input: Represents a message consumer. Output: Represents a message producer.","title":"2. Input and Output"},{"location":"microservices/SpringCloudStream/#3-channels","text":"Logical names for input/output communication. Channels map to topics, queues, or exchanges in the messaging system.","title":"3. Channels"},{"location":"microservices/SpringCloudStream/#4-binding","text":"Connects application channels (@Input or @Output) to messaging destinations (e.g., Kafka topics or RabbitMQ queues).","title":"4. Binding"},{"location":"microservices/SpringCloudStream/#how-it-works","text":"You write business logic using Spring Boot. Spring Cloud Stream manages binding your logic to the messaging system. Messages flow between microservices via configured topics or queues.","title":"How It Works"},{"location":"other/Agile/","text":"Agile Workflow Example Epic Enhance the e-commerce shopping experience. Stories As a user, I want to add items to a wishlist so that I can purchase them later. As a user, I want personalized product recommendations so that I can find relevant items quickly. Tasks (for the Wishlist Story) Design the wishlist button. Develop backend API for wishlist management. Implement the wishlist page in the UI. Sprint Stories and tasks are completed within a defined time frame. Story Estimation Purpose Determines the effort or complexity of completing a user story. This is the most common level for estimation. When to Estimate During Backlog Refinement or Sprint Planning . How to Estimate Use story points , often based on Fibonacci numbers (1, 2, 3, 5, 8, etc.). Consider factors like: Complexity Risk Effort required Tools/Methods Planning Poker : Team members assign points, discuss, and agree on a final estimate. Example Story : \"As a user, I want to filter products by category.\" Estimate : 5 story points","title":"Agile"},{"location":"other/Agile/#agile-workflow-example","text":"","title":"Agile Workflow Example"},{"location":"other/Agile/#epic","text":"Enhance the e-commerce shopping experience.","title":"Epic"},{"location":"other/Agile/#stories","text":"As a user, I want to add items to a wishlist so that I can purchase them later. As a user, I want personalized product recommendations so that I can find relevant items quickly.","title":"Stories"},{"location":"other/Agile/#tasks-for-the-wishlist-story","text":"Design the wishlist button. Develop backend API for wishlist management. Implement the wishlist page in the UI.","title":"Tasks (for the Wishlist Story)"},{"location":"other/Agile/#sprint","text":"Stories and tasks are completed within a defined time frame.","title":"Sprint"},{"location":"other/Agile/#story-estimation","text":"","title":"Story Estimation"},{"location":"other/Agile/#purpose","text":"Determines the effort or complexity of completing a user story. This is the most common level for estimation.","title":"Purpose"},{"location":"other/Agile/#when-to-estimate","text":"During Backlog Refinement or Sprint Planning .","title":"When to Estimate"},{"location":"other/Agile/#how-to-estimate","text":"Use story points , often based on Fibonacci numbers (1, 2, 3, 5, 8, etc.). Consider factors like: Complexity Risk Effort required","title":"How to Estimate"},{"location":"other/Agile/#toolsmethods","text":"Planning Poker : Team members assign points, discuss, and agree on a final estimate.","title":"Tools/Methods"},{"location":"other/Agile/#example","text":"Story : \"As a user, I want to filter products by category.\" Estimate : 5 story points","title":"Example"},{"location":"other/Docker/","text":"Docker Docker is an open-source platform used for developing, shipping, and running applications. It allows you to package an application and its dependencies into a container , which can run consistently across different environments, such as development, testing, and production. Key Docker Concepts 1. Container A lightweight, standalone, executable package that includes everything needed to run a piece of software, such as the code, runtime, libraries, and system tools. Containers are isolated from the host system but share the OS kernel. 2. Image A read-only template used to create containers. It contains the application and its dependencies. Images are built from Dockerfiles, which are scripts containing instructions on how to build the image. 3. Dockerfile A script that contains instructions for Docker to create an image. It defines the application's environment, dependencies, and configuration settings. 4. Docker Hub A public repository where Docker images can be shared. It\u2019s similar to GitHub, but for Docker images. 5. Docker Compose A tool used for defining and running multi-container Docker applications. You define a YAML file ( docker-compose.yml ) to configure the services, networks, and volumes needed for your application. 6. Docker Engine The runtime that builds, runs, and manages containers. It consists of: - Docker daemon (server) - REST API - Command-line interface (CLI) Benefits of Docker Docker helps ensure that applications run the same way, regardless of where they are deployed. It is ideal for: - Microservices - Cloud-native applications - CI/CD pipelines Docker Cheatsheet Docker Setup docker --version - Check Docker version. docker info - Display Docker system-wide information. Container Management docker ps - List running containers. docker ps -a - List all containers. docker run <image> - Run a container from an image. docker run -d <image> - Run a container in detached mode. docker run -it <image> - Run a container interactively. docker start <container> - Start a stopped container. docker stop <container> - Stop a running container. docker restart <container> - Restart a container. docker rm <container> - Remove a container. docker rm -f <container> - Force remove a running container. docker logs <container> - View logs of a container. docker exec -it <container> bash - Access a running container\u2019s shell. Image Management docker images - List all Docker images. docker pull <image> - Download an image from Docker Hub. docker push <image> - Push an image to Docker Hub. docker build -t <image:tag> . - Build an image from a Dockerfile. docker rmi <image> - Remove an image. docker tag <source-image> <target-image> - Tag an image with a new name. docker inspect <image> - View details of an image. Network Management docker network ls - List all networks. docker network create <name> - Create a new network. docker network rm <name> - Remove a network. docker network inspect <name> - View details of a network. docker network connect <network> <container> - Connect a container to a network. docker network disconnect <network> <container> - Disconnect a container from a network. Volume Management docker volume ls - List all volumes. docker volume create <name> - Create a new volume. docker volume rm <name> - Remove a volume. docker volume inspect <name> - View details of a volume. Container Cleanup docker system prune - Remove unused data (containers, networks, images, and volumes). docker container prune - Remove all stopped containers. docker image prune - Remove unused images. docker volume prune - Remove unused volumes. Docker Compose docker-compose up - Start all services defined in docker-compose.yml . docker-compose up -d - Start all services in detached mode. docker-compose down - Stop and remove all services. docker-compose ps - List running services. docker-compose logs - View logs of services. docker-compose exec <service> bash - Access a running service container\u2019s shell. Miscellaneous docker save -o <file> <image> - Save an image to a tar file. docker load -i <file> - Load an image from a tar file. docker stats - Display live resource usage stats for containers. docker top <container> - Display processes running in a container. docker history <image> - Show the history of an image.","title":"Docker"},{"location":"other/Docker/#docker","text":"Docker is an open-source platform used for developing, shipping, and running applications. It allows you to package an application and its dependencies into a container , which can run consistently across different environments, such as development, testing, and production.","title":"Docker"},{"location":"other/Docker/#key-docker-concepts","text":"","title":"Key Docker Concepts"},{"location":"other/Docker/#1-container","text":"A lightweight, standalone, executable package that includes everything needed to run a piece of software, such as the code, runtime, libraries, and system tools. Containers are isolated from the host system but share the OS kernel.","title":"1. Container"},{"location":"other/Docker/#2-image","text":"A read-only template used to create containers. It contains the application and its dependencies. Images are built from Dockerfiles, which are scripts containing instructions on how to build the image.","title":"2. Image"},{"location":"other/Docker/#3-dockerfile","text":"A script that contains instructions for Docker to create an image. It defines the application's environment, dependencies, and configuration settings.","title":"3. Dockerfile"},{"location":"other/Docker/#4-docker-hub","text":"A public repository where Docker images can be shared. It\u2019s similar to GitHub, but for Docker images.","title":"4. Docker Hub"},{"location":"other/Docker/#5-docker-compose","text":"A tool used for defining and running multi-container Docker applications. You define a YAML file ( docker-compose.yml ) to configure the services, networks, and volumes needed for your application.","title":"5. Docker Compose"},{"location":"other/Docker/#6-docker-engine","text":"The runtime that builds, runs, and manages containers. It consists of: - Docker daemon (server) - REST API - Command-line interface (CLI)","title":"6. Docker Engine"},{"location":"other/Docker/#benefits-of-docker","text":"Docker helps ensure that applications run the same way, regardless of where they are deployed. It is ideal for: - Microservices - Cloud-native applications - CI/CD pipelines","title":"Benefits of Docker"},{"location":"other/Docker/#docker-cheatsheet","text":"","title":"Docker Cheatsheet"},{"location":"other/Docker/#docker-setup","text":"docker --version - Check Docker version. docker info - Display Docker system-wide information.","title":"Docker Setup"},{"location":"other/Docker/#container-management","text":"docker ps - List running containers. docker ps -a - List all containers. docker run <image> - Run a container from an image. docker run -d <image> - Run a container in detached mode. docker run -it <image> - Run a container interactively. docker start <container> - Start a stopped container. docker stop <container> - Stop a running container. docker restart <container> - Restart a container. docker rm <container> - Remove a container. docker rm -f <container> - Force remove a running container. docker logs <container> - View logs of a container. docker exec -it <container> bash - Access a running container\u2019s shell.","title":"Container Management"},{"location":"other/Docker/#image-management","text":"docker images - List all Docker images. docker pull <image> - Download an image from Docker Hub. docker push <image> - Push an image to Docker Hub. docker build -t <image:tag> . - Build an image from a Dockerfile. docker rmi <image> - Remove an image. docker tag <source-image> <target-image> - Tag an image with a new name. docker inspect <image> - View details of an image.","title":"Image Management"},{"location":"other/Docker/#network-management","text":"docker network ls - List all networks. docker network create <name> - Create a new network. docker network rm <name> - Remove a network. docker network inspect <name> - View details of a network. docker network connect <network> <container> - Connect a container to a network. docker network disconnect <network> <container> - Disconnect a container from a network.","title":"Network Management"},{"location":"other/Docker/#volume-management","text":"docker volume ls - List all volumes. docker volume create <name> - Create a new volume. docker volume rm <name> - Remove a volume. docker volume inspect <name> - View details of a volume.","title":"Volume Management"},{"location":"other/Docker/#container-cleanup","text":"docker system prune - Remove unused data (containers, networks, images, and volumes). docker container prune - Remove all stopped containers. docker image prune - Remove unused images. docker volume prune - Remove unused volumes.","title":"Container Cleanup"},{"location":"other/Docker/#docker-compose","text":"docker-compose up - Start all services defined in docker-compose.yml . docker-compose up -d - Start all services in detached mode. docker-compose down - Stop and remove all services. docker-compose ps - List running services. docker-compose logs - View logs of services. docker-compose exec <service> bash - Access a running service container\u2019s shell.","title":"Docker Compose"},{"location":"other/Docker/#miscellaneous","text":"docker save -o <file> <image> - Save an image to a tar file. docker load -i <file> - Load an image from a tar file. docker stats - Display live resource usage stats for containers. docker top <container> - Display processes running in a container. docker history <image> - Show the history of an image.","title":"Miscellaneous"},{"location":"other/Fastag/","text":"Documentation: Communication Between HDFC FASTag Microservices and NETC System for Automatic Toll Deduction 1. Overview This document explains how HDFC\u2019s FASTag microservices communicate with the NETC Switch (operated by NPCI) for automatic toll deduction at toll plazas. It describes the flow of data from the moment a vehicle with an HDFC FASTag passes through a toll plaza to the final deduction from the vehicle owner's account. The NETC System (National Electronic Toll Collection) is a centralized platform for managing toll payments in India, facilitating interoperability between various FASTag providers (banks) and toll plazas . This document focuses on the interaction between HDFC\u2019s FASTag microservices and the NETC Switch . 2. Key Participants HDFC FASTag Microservices : Responsible for handling communication between HDFC\u2019s systems and the NETC platform, including transaction processing, account management, and customer notifications. NETC Switch (NPCI-managed) : The centralized platform that manages toll payments and transactions between toll plazas and FASTag providers. Toll Plaza Infrastructure : Includes RFID readers, cameras, and automated toll collection systems. Vehicle Owner\u2019s Bank Account : The HDFC Bank account or prepaid wallet linked to the FASTag for toll payment. FASTag : A prepaid RFID tag linked to the vehicle owner's account, enabling automatic toll payment. 3. How to Apply for FASTag Online via the HDFC Bank Website To apply for a FASTag online through HDFC Bank, follow these steps: Open the HDFC Bank Website : Navigate to the official HDFC Bank website and go to the FASTag section. Fill in Your Mobile Number and PAN : Enter your mobile number and PAN details in the required fields. Verify Your Details : Verify your PAN details to ensure they match the records. You will have three attempts to enter the correct PAN information. Select Your Bank Account : If you are an existing HDFC Bank customer, select your bank account. If you are a new user, provide your personal details and vehicle information. Upload Documents : Upload the required documents: Your vehicle's RC (Registration Certificate) . Front and side images of the vehicle. Enter Vehicle Details : Input the last five digits of your vehicle\u2019s engine number and chassis number . Review and Accept Terms : Review all your entered details and accept the terms and conditions to proceed. Enter OTP : Enter the OTP sent to your mobile number for verification. Make Payment : Proceed to pay for the FASTag. Confirmation : Once your application is successful, you will receive a confirmation message . Note : It is essential to accept the terms and conditions and verify your PAN details. If your PAN does not match the records, you will not be able to proceed with the application. 4. Communication Flow The following section details the step-by-step communication flow from the vehicle passing through the toll plaza to the payment deduction. Step 1: Vehicle Approaches Toll Plaza The vehicle approaches the FASTag lane at the toll plaza, where an RFID reader scans the FASTag attached to the vehicle\u2019s windshield. The FASTag ID (a unique identifier) is read by the RFID scanner. Step 2: FASTag Data Sent to NETC Switch The NETC Switch receives the FASTag ID from the toll plaza's RFID reader. This FASTag ID contains information about which FASTag provider (bank) issued the tag. For example, HDFC FASTags may have a specific prefix such as HDFC001 , HDFC002 , etc. Step 3: NETC Switch Verifies FASTag Provider The NETC Switch uses the FASTag ID to query a central registry or mapping database that stores the prefixes for various FASTag providers (e.g., HDFC, ICICI, SBI). Based on the FASTag ID prefix (e.g., \"HDFC\"), the NETC Switch identifies that the HDFC FASTag microservice needs to be contacted. Step 4: NETC Switch Communicates with HDFC Microservice The NETC Switch sends a transaction request to HDFC\u2019s FASTag microservice via an API call . The transaction request includes the following details: Vehicle ID FASTag ID Toll amount Timestamp Step 5: HDFC FASTag Microservice Processes the Transaction HDFC\u2019s microservice receives the transaction request and performs the following actions: Validate the FASTag ID and ensure it matches the vehicle owner\u2019s details in HDFC\u2019s backend system. Check the account balance or prepaid wallet associated with the FASTag to verify if sufficient funds are available for toll payment. Authorize the payment : If the balance is sufficient, the microservice processes the toll deduction. Send the payment authorization to HDFC Bank's backend payment systems for further processing. Step 6: Payment Authorization and Confirmation HDFC\u2019s backend payment system processes the payment, and the toll amount is deducted from the vehicle owner's account . The HDFC microservice sends a payment confirmation response back to the NETC Switch , including transaction details: Transaction ID Toll amount Payment status (successful or failure) Step 7: NETC Switch Sends Confirmation to Toll Plaza Upon receiving the payment confirmation from HDFC\u2019s microservice , the NETC Switch sends a message to the toll plaza\u2019s system, indicating that the payment was successful. The toll plaza barrier is lifted, allowing the vehicle to pass through. Step 8: Transaction Notification to Customer Once the payment is successfully processed, HDFC\u2019s microservice sends a transaction notification to the vehicle owner via: SMS Email Mobile App Notification The notification includes: - Toll amount deducted - Vehicle number - Date and time of deduction - Remaining balance (if applicable) Step 9: Backend Logging and Monitoring All transaction details are logged by HDFC\u2019s backend systems for auditing and monitoring purposes. HDFC microservices track and log the transaction status, ensuring that any errors (e.g., insufficient funds) are handled appropriately. 5. Central Registry and Mapping Database The NETC Switch uses a central registry or mapping database to link FASTag IDs to their respective FASTag providers (banks). This database includes: FASTag ID Prefixes : Unique prefixes associated with each bank\u2019s FASTags (e.g., \"HDFC\", \"ICICI\"). Microservice Endpoints : The corresponding API endpoint for each FASTag provider\u2019s microservice, allowing the NETC Switch to route requests to the correct service. This registry allows the NETC Switch to efficiently direct each transaction request to the correct FASTag provider's microservice for processing. 6. Technology Stack The technology stack for HDFC\u2019s FASTag microservices and the communication with NETC Switch typically involves: REST APIs : For communication between HDFC\u2019s microservices and the NETC Switch. Kafka/RabbitMQ : For reliable messaging and event streaming between microservices. Spring Boot : For building scalable microservices. OAuth2 : For secure authorization and authentication between systems. HTTPS : For secure communication between the NETC Switch and HDFC's systems. Database : For storing transaction logs, account balances, and FASTag details. Redis : For caching frequently accessed data like account balances or toll history. 7. Security Considerations Encryption : All communication between the NETC Switch , HDFC\u2019s microservices , and toll plazas is encrypted using HTTPS and other encryption protocols to protect sensitive data. Authentication : OAuth2 or other secure methods are used to ensure that only authorized services can access the system. Fraud Prevention : HDFC\u2019s microservices include mechanisms to detect and prevent fraud, such as duplicate transactions or unauthorized access. 8. Summary This documentation outlines the detailed process of how HDFC\u2019s FASTag microservices interact with the NETC Switch to facilitate automatic toll payments. The key steps include identifying the FASTag provider, communicating with the correct microservice, processing the payment, and sending confirmation to both the toll plaza and the vehicle owner. This seamless interaction enables the interoperability of FASTag systems across multiple banks and toll plazas, improving the efficiency and convenience of toll payments in India.","title":"Fastag"},{"location":"other/Fastag/#documentation-communication-between-hdfc-fastag-microservices-and-netc-system-for-automatic-toll-deduction","text":"","title":"Documentation: Communication Between HDFC FASTag Microservices and NETC System for Automatic Toll Deduction"},{"location":"other/Fastag/#1-overview","text":"This document explains how HDFC\u2019s FASTag microservices communicate with the NETC Switch (operated by NPCI) for automatic toll deduction at toll plazas. It describes the flow of data from the moment a vehicle with an HDFC FASTag passes through a toll plaza to the final deduction from the vehicle owner's account. The NETC System (National Electronic Toll Collection) is a centralized platform for managing toll payments in India, facilitating interoperability between various FASTag providers (banks) and toll plazas . This document focuses on the interaction between HDFC\u2019s FASTag microservices and the NETC Switch .","title":"1. Overview"},{"location":"other/Fastag/#2-key-participants","text":"HDFC FASTag Microservices : Responsible for handling communication between HDFC\u2019s systems and the NETC platform, including transaction processing, account management, and customer notifications. NETC Switch (NPCI-managed) : The centralized platform that manages toll payments and transactions between toll plazas and FASTag providers. Toll Plaza Infrastructure : Includes RFID readers, cameras, and automated toll collection systems. Vehicle Owner\u2019s Bank Account : The HDFC Bank account or prepaid wallet linked to the FASTag for toll payment. FASTag : A prepaid RFID tag linked to the vehicle owner's account, enabling automatic toll payment.","title":"2. Key Participants"},{"location":"other/Fastag/#3-how-to-apply-for-fastag-online-via-the-hdfc-bank-website","text":"To apply for a FASTag online through HDFC Bank, follow these steps: Open the HDFC Bank Website : Navigate to the official HDFC Bank website and go to the FASTag section. Fill in Your Mobile Number and PAN : Enter your mobile number and PAN details in the required fields. Verify Your Details : Verify your PAN details to ensure they match the records. You will have three attempts to enter the correct PAN information. Select Your Bank Account : If you are an existing HDFC Bank customer, select your bank account. If you are a new user, provide your personal details and vehicle information. Upload Documents : Upload the required documents: Your vehicle's RC (Registration Certificate) . Front and side images of the vehicle. Enter Vehicle Details : Input the last five digits of your vehicle\u2019s engine number and chassis number . Review and Accept Terms : Review all your entered details and accept the terms and conditions to proceed. Enter OTP : Enter the OTP sent to your mobile number for verification. Make Payment : Proceed to pay for the FASTag. Confirmation : Once your application is successful, you will receive a confirmation message . Note : It is essential to accept the terms and conditions and verify your PAN details. If your PAN does not match the records, you will not be able to proceed with the application.","title":"3. How to Apply for FASTag Online via the HDFC Bank Website"},{"location":"other/Fastag/#4-communication-flow","text":"The following section details the step-by-step communication flow from the vehicle passing through the toll plaza to the payment deduction.","title":"4. Communication Flow"},{"location":"other/Fastag/#step-1-vehicle-approaches-toll-plaza","text":"The vehicle approaches the FASTag lane at the toll plaza, where an RFID reader scans the FASTag attached to the vehicle\u2019s windshield. The FASTag ID (a unique identifier) is read by the RFID scanner.","title":"Step 1: Vehicle Approaches Toll Plaza"},{"location":"other/Fastag/#step-2-fastag-data-sent-to-netc-switch","text":"The NETC Switch receives the FASTag ID from the toll plaza's RFID reader. This FASTag ID contains information about which FASTag provider (bank) issued the tag. For example, HDFC FASTags may have a specific prefix such as HDFC001 , HDFC002 , etc.","title":"Step 2: FASTag Data Sent to NETC Switch"},{"location":"other/Fastag/#step-3-netc-switch-verifies-fastag-provider","text":"The NETC Switch uses the FASTag ID to query a central registry or mapping database that stores the prefixes for various FASTag providers (e.g., HDFC, ICICI, SBI). Based on the FASTag ID prefix (e.g., \"HDFC\"), the NETC Switch identifies that the HDFC FASTag microservice needs to be contacted.","title":"Step 3: NETC Switch Verifies FASTag Provider"},{"location":"other/Fastag/#step-4-netc-switch-communicates-with-hdfc-microservice","text":"The NETC Switch sends a transaction request to HDFC\u2019s FASTag microservice via an API call . The transaction request includes the following details: Vehicle ID FASTag ID Toll amount Timestamp","title":"Step 4: NETC Switch Communicates with HDFC Microservice"},{"location":"other/Fastag/#step-5-hdfc-fastag-microservice-processes-the-transaction","text":"HDFC\u2019s microservice receives the transaction request and performs the following actions: Validate the FASTag ID and ensure it matches the vehicle owner\u2019s details in HDFC\u2019s backend system. Check the account balance or prepaid wallet associated with the FASTag to verify if sufficient funds are available for toll payment. Authorize the payment : If the balance is sufficient, the microservice processes the toll deduction. Send the payment authorization to HDFC Bank's backend payment systems for further processing.","title":"Step 5: HDFC FASTag Microservice Processes the Transaction"},{"location":"other/Fastag/#step-6-payment-authorization-and-confirmation","text":"HDFC\u2019s backend payment system processes the payment, and the toll amount is deducted from the vehicle owner's account . The HDFC microservice sends a payment confirmation response back to the NETC Switch , including transaction details: Transaction ID Toll amount Payment status (successful or failure)","title":"Step 6: Payment Authorization and Confirmation"},{"location":"other/Fastag/#step-7-netc-switch-sends-confirmation-to-toll-plaza","text":"Upon receiving the payment confirmation from HDFC\u2019s microservice , the NETC Switch sends a message to the toll plaza\u2019s system, indicating that the payment was successful. The toll plaza barrier is lifted, allowing the vehicle to pass through.","title":"Step 7: NETC Switch Sends Confirmation to Toll Plaza"},{"location":"other/Fastag/#step-8-transaction-notification-to-customer","text":"Once the payment is successfully processed, HDFC\u2019s microservice sends a transaction notification to the vehicle owner via: SMS Email Mobile App Notification The notification includes: - Toll amount deducted - Vehicle number - Date and time of deduction - Remaining balance (if applicable)","title":"Step 8: Transaction Notification to Customer"},{"location":"other/Fastag/#step-9-backend-logging-and-monitoring","text":"All transaction details are logged by HDFC\u2019s backend systems for auditing and monitoring purposes. HDFC microservices track and log the transaction status, ensuring that any errors (e.g., insufficient funds) are handled appropriately.","title":"Step 9: Backend Logging and Monitoring"},{"location":"other/Fastag/#5-central-registry-and-mapping-database","text":"The NETC Switch uses a central registry or mapping database to link FASTag IDs to their respective FASTag providers (banks). This database includes: FASTag ID Prefixes : Unique prefixes associated with each bank\u2019s FASTags (e.g., \"HDFC\", \"ICICI\"). Microservice Endpoints : The corresponding API endpoint for each FASTag provider\u2019s microservice, allowing the NETC Switch to route requests to the correct service. This registry allows the NETC Switch to efficiently direct each transaction request to the correct FASTag provider's microservice for processing.","title":"5. Central Registry and Mapping Database"},{"location":"other/Fastag/#6-technology-stack","text":"The technology stack for HDFC\u2019s FASTag microservices and the communication with NETC Switch typically involves: REST APIs : For communication between HDFC\u2019s microservices and the NETC Switch. Kafka/RabbitMQ : For reliable messaging and event streaming between microservices. Spring Boot : For building scalable microservices. OAuth2 : For secure authorization and authentication between systems. HTTPS : For secure communication between the NETC Switch and HDFC's systems. Database : For storing transaction logs, account balances, and FASTag details. Redis : For caching frequently accessed data like account balances or toll history.","title":"6. Technology Stack"},{"location":"other/Fastag/#7-security-considerations","text":"Encryption : All communication between the NETC Switch , HDFC\u2019s microservices , and toll plazas is encrypted using HTTPS and other encryption protocols to protect sensitive data. Authentication : OAuth2 or other secure methods are used to ensure that only authorized services can access the system. Fraud Prevention : HDFC\u2019s microservices include mechanisms to detect and prevent fraud, such as duplicate transactions or unauthorized access.","title":"7. Security Considerations"},{"location":"other/Fastag/#8-summary","text":"This documentation outlines the detailed process of how HDFC\u2019s FASTag microservices interact with the NETC Switch to facilitate automatic toll payments. The key steps include identifying the FASTag provider, communicating with the correct microservice, processing the payment, and sending confirmation to both the toll plaza and the vehicle owner. This seamless interaction enables the interoperability of FASTag systems across multiple banks and toll plazas, improving the efficiency and convenience of toll payments in India.","title":"8. Summary"},{"location":"other/Flowchart/","text":"ILMS Workflow Here is the flowchart for the ILMS workflow: graph TD Start --> QC1[Allocate to QC1] QC1 --> AllocationStatus[Status: Pending for Allocation] AllocationStatus --> DecisionInternalExternal{Internal or External?} DecisionInternalExternal --> Internal[Internal: No invoice generated] Internal --> Assigned[Status: Assigned] Assigned --> InvestigatorAccepts[Investigator Accepts] DecisionInternalExternal --> External[External: Invoice is generated] External --> AH[Assigned to AH] AH --> AHDecision{AH Accept or Decline?} AHDecision --> Accept[Accept] Accept --> AcceptedStatus[Status: Accepted] AcceptedStatus --> InvestigatorAllocate[Allocate Investigator] InvestigatorAllocate --> SelfAssigned[Status: Self Assigned by AH] SelfAssigned --> GenerateReport[Generate Report] GenerateReport --> SubmitReport[Create & Submit] SubmitReport --> QC1Review[Status: Pending for Review by QC1] AHDecision --> Decline[Decline] Decline --> DeclinedStatus[Status: Declined] DeclinedStatus --> ReturnQC1[Case returns to QC1 bucket] ReturnQC1 --> QC1Reassign[QC1 assigns another agency or internal investigator] QC1Review --> PaymentDecision{Cashless or Reimbursement?} PaymentDecision --> Cashless PaymentDecision --> Reimbursement Cashless --> CashlessDecision{Amount <= 5?} CashlessDecision --> ApproveCashless[Yes: Approve Report] ApproveCashless --> PendingQC2[Status: Pending for Invoice Approval by QC2] CashlessDecision --> SubmitCashless[No: Submit Report] SubmitCashless --> PendingQC2Report[Status: Pending for Report & Invoice Approval by QC2] Reimbursement --> ReimbursementDecision1{Amount <= 2.5?} ReimbursementDecision1 --> ApproveReimbursement[Yes: Approve Report] ApproveReimbursement --> PendingQC2[Status: Pending for Invoice Approval by QC2] ReimbursementDecision1 --> ReimbursementDecision2{Amount > 2.5} ReimbursementDecision2 --> AmountGreater10{Amount >= 10?} AmountGreater10 --> SubmitLarge[Yes: Submit Report] SubmitLarge --> PendingQC2Review[Status: Pending for QC2 Review] AmountGreater10 --> SubmitSmall[No: Submit Report] SubmitSmall --> PendingQC2Report[Status: Pending for Report & Invoice Approval by QC2] PendingQC2 --> QC2Action[QC2 View Report] QC2Action --> FillQC2[Fill QC2 Details] FillQC2 --> ApproveInvoice[Approve Invoice Amount] ApproveInvoice --> Closed[Submit Report: Status Closed] PendingQC2Report --> QC2Action PendingQC2Review --> QC2Review[QC2 Review Report] QC2Review --> SubmitToQC3[Submit Report] SubmitToQC3 --> QC3Review[Status: Pending for Review by QC3] QC3Review --> ApproveQC3[Approve Report & Invoice Amount] ApproveQC3 --> Closed","title":"Flowchart"},{"location":"other/Flowchart/#ilms-workflow","text":"Here is the flowchart for the ILMS workflow: graph TD Start --> QC1[Allocate to QC1] QC1 --> AllocationStatus[Status: Pending for Allocation] AllocationStatus --> DecisionInternalExternal{Internal or External?} DecisionInternalExternal --> Internal[Internal: No invoice generated] Internal --> Assigned[Status: Assigned] Assigned --> InvestigatorAccepts[Investigator Accepts] DecisionInternalExternal --> External[External: Invoice is generated] External --> AH[Assigned to AH] AH --> AHDecision{AH Accept or Decline?} AHDecision --> Accept[Accept] Accept --> AcceptedStatus[Status: Accepted] AcceptedStatus --> InvestigatorAllocate[Allocate Investigator] InvestigatorAllocate --> SelfAssigned[Status: Self Assigned by AH] SelfAssigned --> GenerateReport[Generate Report] GenerateReport --> SubmitReport[Create & Submit] SubmitReport --> QC1Review[Status: Pending for Review by QC1] AHDecision --> Decline[Decline] Decline --> DeclinedStatus[Status: Declined] DeclinedStatus --> ReturnQC1[Case returns to QC1 bucket] ReturnQC1 --> QC1Reassign[QC1 assigns another agency or internal investigator] QC1Review --> PaymentDecision{Cashless or Reimbursement?} PaymentDecision --> Cashless PaymentDecision --> Reimbursement Cashless --> CashlessDecision{Amount <= 5?} CashlessDecision --> ApproveCashless[Yes: Approve Report] ApproveCashless --> PendingQC2[Status: Pending for Invoice Approval by QC2] CashlessDecision --> SubmitCashless[No: Submit Report] SubmitCashless --> PendingQC2Report[Status: Pending for Report & Invoice Approval by QC2] Reimbursement --> ReimbursementDecision1{Amount <= 2.5?} ReimbursementDecision1 --> ApproveReimbursement[Yes: Approve Report] ApproveReimbursement --> PendingQC2[Status: Pending for Invoice Approval by QC2] ReimbursementDecision1 --> ReimbursementDecision2{Amount > 2.5} ReimbursementDecision2 --> AmountGreater10{Amount >= 10?} AmountGreater10 --> SubmitLarge[Yes: Submit Report] SubmitLarge --> PendingQC2Review[Status: Pending for QC2 Review] AmountGreater10 --> SubmitSmall[No: Submit Report] SubmitSmall --> PendingQC2Report[Status: Pending for Report & Invoice Approval by QC2] PendingQC2 --> QC2Action[QC2 View Report] QC2Action --> FillQC2[Fill QC2 Details] FillQC2 --> ApproveInvoice[Approve Invoice Amount] ApproveInvoice --> Closed[Submit Report: Status Closed] PendingQC2Report --> QC2Action PendingQC2Review --> QC2Review[QC2 Review Report] QC2Review --> SubmitToQC3[Submit Report] SubmitToQC3 --> QC3Review[Status: Pending for Review by QC3] QC3Review --> ApproveQC3[Approve Report & Invoice Amount] ApproveQC3 --> Closed","title":"ILMS Workflow"},{"location":"other/Git/","text":"Git Git is a distributed version control system that allows multiple developers to collaborate on software development projects. It helps track changes to files, manage code versions, and allows teams to work on the same codebase simultaneously without overwriting each other's work. Key Features of Git Version Control : Git records the history of changes to files, enabling developers to revert to previous versions, track changes over time, and manage code versions. Distributed : Unlike centralized version control systems, where there is a central server holding the repository, Git allows each developer to have a complete local copy of the repository, including its history. Branching and Merging : Git allows developers to create branches to work on different features or bug fixes separately. After completing work, they can merge their changes back into the main branch. Collaboration : Git makes it easier for multiple developers to work on a project simultaneously, handle conflicts, and track who made each change. Usage in Development Git is widely used in software development and is the underlying system for platforms like GitHub , GitLab , and Bitbucket , where developers can share code, collaborate, and manage repositories remotely. Git Cheatsheet Setup git config --global user.name \"Your Name\" - Set the global username for Git. git config --global user.email \"youremail@example.com\" - Set the global email for Git. git config --list - Display Git configuration. Repository Initialization git init - Initialize a new Git repository. git clone <repository-url> - Clone an existing repository. Basic Snapshotting git status - Check the current repository status. git add <file> - Add a file to the staging area. git add . - Add all changes to the staging area. git reset <file> - Unstage a file. git commit -m \"message\" - Commit staged changes with a message. git commit --amend - Modify the last commit. Branching and Merging git branch - List all branches. git branch <branch-name> - Create a new branch. git checkout <branch-name> - Switch to an existing branch. git checkout -b <branch-name> - Create and switch to a new branch. git merge <branch-name> - Merge a branch into the current branch. git branch -d <branch-name> - Delete a branch. Remote Repositories git remote -v - List remote repositories. git remote add <name> <url> - Add a new remote. git fetch <remote-name> - Fetch updates from a remote repository. git pull <remote-name> <branch> - Pull changes from a remote branch. git push <remote-name> <branch> - Push changes to a remote branch. git remote rename <old-name> <new-name> - Rename a remote. git remote remove <name> - Remove a remote. Stashing Changes git stash - Stash uncommitted changes. git stash list - List all stashes. git stash apply - Apply the most recent stash. git stash pop - Apply and remove the most recent stash. git stash drop stash@{index} - Remove a specific stash. Viewing History git log - View commit history. git log --oneline - View a compact commit history. git show <commit-hash> - View details of a specific commit. git diff - Show changes in the working directory. git diff --staged - Show changes in the staging area. Undoing Changes git checkout -- <file> - Revert changes in the working directory. git reset <commit-hash> - Reset to a specific commit (keep changes). git reset --hard <commit-hash> - Reset to a specific commit (discard changes). git revert <commit-hash> - Revert a specific commit. Tags git tag - List all tags. git tag <tag-name> - Create a lightweight tag. git tag -a <tag-name> -m \"message\" - Create an annotated tag. git push <remote-name> <tag-name> - Push a tag to a remote. git tag -d <tag-name> - Delete a local tag. git push <remote-name> --delete <tag-name> - Delete a tag from a remote. Collaboration git diff <branch-name> - Compare changes with another branch. git pull - Pull changes from the remote repository. git push - Push changes to the remote repository. Miscellaneous git clean -f - Remove untracked files. git clean -fd - Remove untracked files and directories. git apply <patch-file> - Apply a patch file. git format-patch <commit-hash> - Create a patch file for a commit.","title":"Git"},{"location":"other/Git/#git","text":"Git is a distributed version control system that allows multiple developers to collaborate on software development projects. It helps track changes to files, manage code versions, and allows teams to work on the same codebase simultaneously without overwriting each other's work.","title":"Git"},{"location":"other/Git/#key-features-of-git","text":"Version Control : Git records the history of changes to files, enabling developers to revert to previous versions, track changes over time, and manage code versions. Distributed : Unlike centralized version control systems, where there is a central server holding the repository, Git allows each developer to have a complete local copy of the repository, including its history. Branching and Merging : Git allows developers to create branches to work on different features or bug fixes separately. After completing work, they can merge their changes back into the main branch. Collaboration : Git makes it easier for multiple developers to work on a project simultaneously, handle conflicts, and track who made each change.","title":"Key Features of Git"},{"location":"other/Git/#usage-in-development","text":"Git is widely used in software development and is the underlying system for platforms like GitHub , GitLab , and Bitbucket , where developers can share code, collaborate, and manage repositories remotely.","title":"Usage in Development"},{"location":"other/Git/#git-cheatsheet","text":"","title":"Git Cheatsheet"},{"location":"other/Git/#setup","text":"git config --global user.name \"Your Name\" - Set the global username for Git. git config --global user.email \"youremail@example.com\" - Set the global email for Git. git config --list - Display Git configuration.","title":"Setup"},{"location":"other/Git/#repository-initialization","text":"git init - Initialize a new Git repository. git clone <repository-url> - Clone an existing repository.","title":"Repository Initialization"},{"location":"other/Git/#basic-snapshotting","text":"git status - Check the current repository status. git add <file> - Add a file to the staging area. git add . - Add all changes to the staging area. git reset <file> - Unstage a file. git commit -m \"message\" - Commit staged changes with a message. git commit --amend - Modify the last commit.","title":"Basic Snapshotting"},{"location":"other/Git/#branching-and-merging","text":"git branch - List all branches. git branch <branch-name> - Create a new branch. git checkout <branch-name> - Switch to an existing branch. git checkout -b <branch-name> - Create and switch to a new branch. git merge <branch-name> - Merge a branch into the current branch. git branch -d <branch-name> - Delete a branch.","title":"Branching and Merging"},{"location":"other/Git/#remote-repositories","text":"git remote -v - List remote repositories. git remote add <name> <url> - Add a new remote. git fetch <remote-name> - Fetch updates from a remote repository. git pull <remote-name> <branch> - Pull changes from a remote branch. git push <remote-name> <branch> - Push changes to a remote branch. git remote rename <old-name> <new-name> - Rename a remote. git remote remove <name> - Remove a remote.","title":"Remote Repositories"},{"location":"other/Git/#stashing-changes","text":"git stash - Stash uncommitted changes. git stash list - List all stashes. git stash apply - Apply the most recent stash. git stash pop - Apply and remove the most recent stash. git stash drop stash@{index} - Remove a specific stash.","title":"Stashing Changes"},{"location":"other/Git/#viewing-history","text":"git log - View commit history. git log --oneline - View a compact commit history. git show <commit-hash> - View details of a specific commit. git diff - Show changes in the working directory. git diff --staged - Show changes in the staging area.","title":"Viewing History"},{"location":"other/Git/#undoing-changes","text":"git checkout -- <file> - Revert changes in the working directory. git reset <commit-hash> - Reset to a specific commit (keep changes). git reset --hard <commit-hash> - Reset to a specific commit (discard changes). git revert <commit-hash> - Revert a specific commit.","title":"Undoing Changes"},{"location":"other/Git/#tags","text":"git tag - List all tags. git tag <tag-name> - Create a lightweight tag. git tag -a <tag-name> -m \"message\" - Create an annotated tag. git push <remote-name> <tag-name> - Push a tag to a remote. git tag -d <tag-name> - Delete a local tag. git push <remote-name> --delete <tag-name> - Delete a tag from a remote.","title":"Tags"},{"location":"other/Git/#collaboration","text":"git diff <branch-name> - Compare changes with another branch. git pull - Pull changes from the remote repository. git push - Push changes to the remote repository.","title":"Collaboration"},{"location":"other/Git/#miscellaneous","text":"git clean -f - Remove untracked files. git clean -fd - Remove untracked files and directories. git apply <patch-file> - Apply a patch file. git format-patch <commit-hash> - Create a patch file for a commit.","title":"Miscellaneous"},{"location":"other/ILMS/","text":"","title":"ILMS"},{"location":"other/IntroduceYourself/","text":"Introduction Hi, I am ABC, Software Engineer with ** years of experience in developing microservice-based applications using Java and Spring Boot**. My focus has always been on creating robust, scalable, and efficient backend solutions that address client requirements and align with business goals. I have hands-on experience in designing and implementing RESTful APIs , integrating databases like PostgreSQL and MySQL , and ensuring the applications align with business goals. My expertise also includes debugging and resolving issues reported by QA teams, collaborating with cross-functional teams, and actively participating in Agile methodologies such as daily stand-ups. Key Projects Passion and Vision I am passionate about solving complex problems, building scalable and modular backend systems, and staying updated with the latest advancements in microservices and Java technologies.","title":"Introduction"},{"location":"other/IntroduceYourself/#introduction","text":"Hi, I am ABC, Software Engineer with ** years of experience in developing microservice-based applications using Java and Spring Boot**. My focus has always been on creating robust, scalable, and efficient backend solutions that address client requirements and align with business goals. I have hands-on experience in designing and implementing RESTful APIs , integrating databases like PostgreSQL and MySQL , and ensuring the applications align with business goals. My expertise also includes debugging and resolving issues reported by QA teams, collaborating with cross-functional teams, and actively participating in Agile methodologies such as daily stand-ups.","title":"Introduction"},{"location":"other/IntroduceYourself/#key-projects","text":"","title":"Key Projects"},{"location":"other/IntroduceYourself/#passion-and-vision","text":"I am passionate about solving complex problems, building scalable and modular backend systems, and staying updated with the latest advancements in microservices and Java technologies.","title":"Passion and Vision"},{"location":"other/Maven/","text":"Maven Maven is a build automation tool primarily used for Java projects. It simplifies the process of building, testing, packaging, and deploying applications. Maven uses an XML configuration file called pom.xml (Project Object Model) to define project dependencies, build configurations, and other project-related settings. Key Features of Maven Dependency Management Maven allows you to specify external libraries (dependencies) that your project needs. It automatically downloads and manages these dependencies from remote repositories (like Maven Central). Build Automation Maven automates the build process, which includes compiling code, running tests, packaging the project into JARs or WARs, and generating documentation. Standardized Project Structure Maven enforces a standard directory structure, making it easier for developers to understand and navigate projects. Plugin-Based System Maven provides a wide range of plugins for various tasks, such as compiling code, running tests, generating reports, and deploying applications. Multi-Module Projects Maven supports multi-module projects, allowing you to organize related sub-projects under one parent project. Lifecycle Management Maven defines a series of build phases (such as compile , test , package , install , and deploy ) that describe the steps in the build process, making it easier to manage. Maven is widely used in Java development for its ability to streamline and simplify the build process and manage project dependencies effectively. Maven Commands mvn --version - Check Maven version. mvn clean - Clean the project (remove target/ directory). mvn compile - Compile the project source code. mvn test - Run tests. mvn package - Compile and package the code into a .jar or .war . mvn install - Install the package into the local repository. mvn deploy - Deploy the package to a remote repository. mvn dependency:tree - Display the project\u2019s dependency tree. mvn clean install - Clean, compile, test, and install the package in one step. mvn exec:java -Dexec.mainClass=<class> - Run a Java class. mvn help:describe -Dcmd=<goal> - Get details about a specific goal. Spring Boot Commands mvn spring-boot:run - Run the Spring Boot application. mvn spring-boot:start - Start a Spring Boot application (non-blocking). mvn spring-boot:stop - Stop a running Spring Boot application. mvn spring-boot:repackage - Create an executable JAR or WAR. mvn clean spring-boot:run - Clean and run the Spring Boot application. mvn spring-boot:build-image - Build a container image for the application. java -jar <app>.jar - Run the Spring Boot application from the packaged JAR. mvn spring-boot:build-info - Generate build information for the application. Maven Profile Commands mvn clean install -P<profile> - Build the project using a specific profile. mvn help:active-profiles - Display the active profiles in the project. Maven Debugging Commands mvn -X clean install - Run Maven with debug output. mvn -Dmaven.test.skip=true - Skip tests during the build. mvn -DskipTests - Compile tests but do not execute them. Spring Boot Debugging and Configuration mvn spring-boot:run -Dspring-boot.run.profiles=<profile> - Run with a specific Spring profile. mvn spring-boot:run -Dspring-boot.run.arguments=--<property>=<value> - Pass arguments to the application. java -jar <app>.jar --spring.profiles.active=<profile> - Run with a specific profile from the JAR. java -jar <app>.jar --<property>=<value> - Override properties at runtime.","title":"Maven"},{"location":"other/Maven/#maven","text":"Maven is a build automation tool primarily used for Java projects. It simplifies the process of building, testing, packaging, and deploying applications. Maven uses an XML configuration file called pom.xml (Project Object Model) to define project dependencies, build configurations, and other project-related settings.","title":"Maven"},{"location":"other/Maven/#key-features-of-maven","text":"Dependency Management Maven allows you to specify external libraries (dependencies) that your project needs. It automatically downloads and manages these dependencies from remote repositories (like Maven Central). Build Automation Maven automates the build process, which includes compiling code, running tests, packaging the project into JARs or WARs, and generating documentation. Standardized Project Structure Maven enforces a standard directory structure, making it easier for developers to understand and navigate projects. Plugin-Based System Maven provides a wide range of plugins for various tasks, such as compiling code, running tests, generating reports, and deploying applications. Multi-Module Projects Maven supports multi-module projects, allowing you to organize related sub-projects under one parent project. Lifecycle Management Maven defines a series of build phases (such as compile , test , package , install , and deploy ) that describe the steps in the build process, making it easier to manage. Maven is widely used in Java development for its ability to streamline and simplify the build process and manage project dependencies effectively.","title":"Key Features of Maven"},{"location":"other/Maven/#maven-commands","text":"mvn --version - Check Maven version. mvn clean - Clean the project (remove target/ directory). mvn compile - Compile the project source code. mvn test - Run tests. mvn package - Compile and package the code into a .jar or .war . mvn install - Install the package into the local repository. mvn deploy - Deploy the package to a remote repository. mvn dependency:tree - Display the project\u2019s dependency tree. mvn clean install - Clean, compile, test, and install the package in one step. mvn exec:java -Dexec.mainClass=<class> - Run a Java class. mvn help:describe -Dcmd=<goal> - Get details about a specific goal.","title":"Maven Commands"},{"location":"other/Maven/#spring-boot-commands","text":"mvn spring-boot:run - Run the Spring Boot application. mvn spring-boot:start - Start a Spring Boot application (non-blocking). mvn spring-boot:stop - Stop a running Spring Boot application. mvn spring-boot:repackage - Create an executable JAR or WAR. mvn clean spring-boot:run - Clean and run the Spring Boot application. mvn spring-boot:build-image - Build a container image for the application. java -jar <app>.jar - Run the Spring Boot application from the packaged JAR. mvn spring-boot:build-info - Generate build information for the application.","title":"Spring Boot Commands"},{"location":"other/Maven/#maven-profile-commands","text":"mvn clean install -P<profile> - Build the project using a specific profile. mvn help:active-profiles - Display the active profiles in the project.","title":"Maven Profile Commands"},{"location":"other/Maven/#maven-debugging-commands","text":"mvn -X clean install - Run Maven with debug output. mvn -Dmaven.test.skip=true - Skip tests during the build. mvn -DskipTests - Compile tests but do not execute them.","title":"Maven Debugging Commands"},{"location":"other/Maven/#spring-boot-debugging-and-configuration","text":"mvn spring-boot:run -Dspring-boot.run.profiles=<profile> - Run with a specific Spring profile. mvn spring-boot:run -Dspring-boot.run.arguments=--<property>=<value> - Pass arguments to the application. java -jar <app>.jar --spring.profiles.active=<profile> - Run with a specific profile from the JAR. java -jar <app>.jar --<property>=<value> - Override properties at runtime.","title":"Spring Boot Debugging and Configuration"},{"location":"other/RabbitMQ/","text":"RabbitMQ RabbitMQ is a message queueing system that follows the Advanced Message Queuing Protocol (AMQP). It is used to send messages between different systems, microservices, or even different parts of an application. It's helpful in distributed applications where reliability and communication between components are critical. Key features of RabbitMQ: Message Queues: RabbitMQ stores messages in queues, which can then be consumed by various services. Routing: It allows messages to be routed to different queues based on routing rules. Reliability: It ensures message durability (storing messages on disk) and supports message acknowledgment, making sure messages are reliably delivered. Scalability: RabbitMQ can scale by clustering multiple instances, allowing for high availability and load balancing. Flexible Messaging Patterns: It supports different messaging patterns such as publish/subscribe, request/reply, and point-to-point communication. Management and Monitoring: RabbitMQ comes with a web-based management interface for monitoring queues, exchanges, and connections. Key Concepts in RabbitMQ: Producer: The entity that sends messages to the queue. Queue: A buffer that holds messages until they can be processed by a consumer. Consumer: The entity that receives and processes messages from the queue. Exchange: A routing mechanism that decides how to route messages to one or more queues. Direct Exchange: Routes messages with a specific routing key. Topic Exchange: Routes messages based on routing keys that match patterns. Fanout Exchange: Routes messages to all bound queues. Binding: A link between an exchange and a queue that tells the exchange where to send the message. The pattern might contain wildcards, such as * (matches exactly one word) and # (matches zero or more words). Example of binding key patterns: animals.*.mammal \u2014 Matches any routing key that starts with animals., followed by any word, and ending with .mammal. animals.# \u2014 Matches any routing key that starts with animals. followed by any number of words. .dog. \u2014 Matches any routing key with .dog. as the second word. Message: The actual data being sent between the producer and consumer. Using RabbitMQ in Spring Boot Application Step 1: Add Dependencies Add the necessary dependencies to your pom.xml (for Maven) or build.gradle (for Gradle). <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-amqp</artifactId> </dependency> Step 2: Configure RabbitMQ in application.properties Configure RabbitMQ connection details in the application.properties or application.yml file. # RabbitMQ Configuration spring.rabbitmq.host=localhost spring.rabbitmq.port=5672 spring.rabbitmq.username=guest spring.rabbitmq.password=guest spring.rabbitmq.virtual-host=/ Step 3: Create a Configuration Class for RabbitMQ You can configure RabbitMQ using @Configuration in a separate class. This step involves declaring Queue, Exchange, and Binding. import org.springframework.amqp.core.Queue; import org.springframework.amqp.core.TopicExchange; import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabbitMQConfig { @Bean public Queue queue() { return new Queue(\"testQueue\", true); } @Bean public TopicExchange exchange() { return new TopicExchange(\"testExchange\"); } @Bean public Binding binding(Queue queue, TopicExchange exchange) { return BindingBuilder.bind(queue).to(exchange).with(\"routing.key.#\"); } } This configuration creates: A queue named testQueue. A topic exchange named testExchange. A binding between the queue and exchange with a routing key. Step 4: Create a Producer (Sender) to Send Messages Create a service that will send messages to RabbitMQ. import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; @Service public class MessageProducer { @Autowired private AmqpTemplate amqpTemplate; @Autowired private TopicExchange exchange; public void sendMessage(String message) { amqpTemplate.convertAndSend(exchange.getName(), \"routing.key.test\", message); System.out.println(\"Sent: \" + message); } } In this code, amqpTemplate.convertAndSend sends the message to the RabbitMQ exchange with the specified routing key. Step 5: Create a Consumer (Listener) to Receive Messages Create a listener that listens for messages from RabbitMQ. import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Service; @Service public class MessageListener { @RabbitListener(queues = \"testQueue\") public void receiveMessage(String message) { System.out.println(\"Received: \" + message); } } This listener listens on the testQueue and prints the received messages. Step 6: Test the Application In your main application class or a test class, you can autowire the MessageProducer and send a message to RabbitMQ: import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.CommandLineRunner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class RabbitmqExampleApplication implements CommandLineRunner { @Autowired private MessageProducer messageProducer; public static void main(String[] args) { SpringApplication.run(RabbitmqExampleApplication.class, args); } @Override public void run(String... args) throws Exception { messageProducer.sendMessage(\"Hello, RabbitMQ!\"); } } Durability Features in RabbitMQ Durable Queues : Queues survive broker restarts. @Bean public Queue queue() { return new Queue(QUEUE_NAME, true); // 'true' makes the queue durable } Persistent Messages : Messages are saved to disk and not lost if the broker crashes. public void sendMessage(String message) { // Sending persistent message rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_NAME, RabbitMQConfig.ROUTING_KEY, message, messagePostProcessor -> { messagePostProcessor.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT); // Makes the message persistent return messagePostProcessor; }); } Acknowledgments : Ensures messages are only removed once processed by the consumer. By default, Spring AMQP automatically acknowledges messages once they have been processed by the consumer. Publisher Confirms : Confirms that the message has been successfully received by the broker. @Configuration public class RabbitMQConfig { @Bean public ConnectionFactory connectionFactory() { CachingConnectionFactory connectionFactory = new CachingConnectionFactory(\"localhost\"); connectionFactory.setPublisherConfirms(true); // Enable publisher confirms return connectionFactory; } } Dead Letter Queues (DLQ) : Stores messages that cannot be processed. @Bean public Queue dlq() { return new Queue(\"deadLetterQueue\", true); // Create DLQ } @Bean public Binding dlqBinding() { return BindingBuilder.bind(dlq()).to(new DirectExchange(\"dlxExchange\")).with(\"dlxRoutingKey\"); } @Bean public Queue queue() { Map<String, Object> arguments = new HashMap<>(); arguments.put(\"x-dead-letter-exchange\", \"dlxExchange\"); arguments.put(\"x-dead-letter-routing-key\", \"dlxRoutingKey\"); return new Queue(\"mainQueue\", true, false, false, arguments); } High Availability Queues : Ensures queues are available even in the event of a node failure.","title":"RabbitMQ"},{"location":"other/RabbitMQ/#rabbitmq","text":"RabbitMQ is a message queueing system that follows the Advanced Message Queuing Protocol (AMQP). It is used to send messages between different systems, microservices, or even different parts of an application. It's helpful in distributed applications where reliability and communication between components are critical.","title":"RabbitMQ"},{"location":"other/RabbitMQ/#key-features-of-rabbitmq","text":"","title":"Key features of RabbitMQ:"},{"location":"other/RabbitMQ/#message-queues","text":"RabbitMQ stores messages in queues, which can then be consumed by various services.","title":"Message Queues:"},{"location":"other/RabbitMQ/#routing","text":"It allows messages to be routed to different queues based on routing rules.","title":"Routing:"},{"location":"other/RabbitMQ/#reliability","text":"It ensures message durability (storing messages on disk) and supports message acknowledgment, making sure messages are reliably delivered.","title":"Reliability:"},{"location":"other/RabbitMQ/#scalability","text":"RabbitMQ can scale by clustering multiple instances, allowing for high availability and load balancing.","title":"Scalability:"},{"location":"other/RabbitMQ/#flexible-messaging-patterns","text":"It supports different messaging patterns such as publish/subscribe, request/reply, and point-to-point communication.","title":"Flexible Messaging Patterns:"},{"location":"other/RabbitMQ/#management-and-monitoring","text":"RabbitMQ comes with a web-based management interface for monitoring queues, exchanges, and connections.","title":"Management and Monitoring:"},{"location":"other/RabbitMQ/#key-concepts-in-rabbitmq","text":"Producer: The entity that sends messages to the queue. Queue: A buffer that holds messages until they can be processed by a consumer. Consumer: The entity that receives and processes messages from the queue. Exchange: A routing mechanism that decides how to route messages to one or more queues. Direct Exchange: Routes messages with a specific routing key. Topic Exchange: Routes messages based on routing keys that match patterns. Fanout Exchange: Routes messages to all bound queues. Binding: A link between an exchange and a queue that tells the exchange where to send the message. The pattern might contain wildcards, such as * (matches exactly one word) and # (matches zero or more words). Example of binding key patterns: animals.*.mammal \u2014 Matches any routing key that starts with animals., followed by any word, and ending with .mammal. animals.# \u2014 Matches any routing key that starts with animals. followed by any number of words. .dog. \u2014 Matches any routing key with .dog. as the second word. Message: The actual data being sent between the producer and consumer.","title":"Key Concepts in RabbitMQ:"},{"location":"other/RabbitMQ/#using-rabbitmq-in-spring-boot-application","text":"","title":"Using RabbitMQ in Spring Boot Application"},{"location":"other/RabbitMQ/#step-1-add-dependencies","text":"Add the necessary dependencies to your pom.xml (for Maven) or build.gradle (for Gradle). <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-amqp</artifactId> </dependency>","title":"Step 1: Add Dependencies"},{"location":"other/RabbitMQ/#step-2-configure-rabbitmq-in-applicationproperties","text":"Configure RabbitMQ connection details in the application.properties or application.yml file. # RabbitMQ Configuration spring.rabbitmq.host=localhost spring.rabbitmq.port=5672 spring.rabbitmq.username=guest spring.rabbitmq.password=guest spring.rabbitmq.virtual-host=/","title":"Step 2: Configure RabbitMQ in application.properties"},{"location":"other/RabbitMQ/#step-3-create-a-configuration-class-for-rabbitmq","text":"You can configure RabbitMQ using @Configuration in a separate class. This step involves declaring Queue, Exchange, and Binding. import org.springframework.amqp.core.Queue; import org.springframework.amqp.core.TopicExchange; import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabbitMQConfig { @Bean public Queue queue() { return new Queue(\"testQueue\", true); } @Bean public TopicExchange exchange() { return new TopicExchange(\"testExchange\"); } @Bean public Binding binding(Queue queue, TopicExchange exchange) { return BindingBuilder.bind(queue).to(exchange).with(\"routing.key.#\"); } } This configuration creates: A queue named testQueue. A topic exchange named testExchange. A binding between the queue and exchange with a routing key.","title":"Step 3: Create a Configuration Class for RabbitMQ"},{"location":"other/RabbitMQ/#step-4-create-a-producer-sender-to-send-messages","text":"Create a service that will send messages to RabbitMQ. import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; @Service public class MessageProducer { @Autowired private AmqpTemplate amqpTemplate; @Autowired private TopicExchange exchange; public void sendMessage(String message) { amqpTemplate.convertAndSend(exchange.getName(), \"routing.key.test\", message); System.out.println(\"Sent: \" + message); } } In this code, amqpTemplate.convertAndSend sends the message to the RabbitMQ exchange with the specified routing key.","title":"Step 4: Create a Producer (Sender) to Send Messages"},{"location":"other/RabbitMQ/#step-5-create-a-consumer-listener-to-receive-messages","text":"Create a listener that listens for messages from RabbitMQ. import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Service; @Service public class MessageListener { @RabbitListener(queues = \"testQueue\") public void receiveMessage(String message) { System.out.println(\"Received: \" + message); } } This listener listens on the testQueue and prints the received messages.","title":"Step 5: Create a Consumer (Listener) to Receive Messages"},{"location":"other/RabbitMQ/#step-6-test-the-application","text":"In your main application class or a test class, you can autowire the MessageProducer and send a message to RabbitMQ: import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.CommandLineRunner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class RabbitmqExampleApplication implements CommandLineRunner { @Autowired private MessageProducer messageProducer; public static void main(String[] args) { SpringApplication.run(RabbitmqExampleApplication.class, args); } @Override public void run(String... args) throws Exception { messageProducer.sendMessage(\"Hello, RabbitMQ!\"); } }","title":"Step 6: Test the Application"},{"location":"other/RabbitMQ/#durability-features-in-rabbitmq","text":"Durable Queues : Queues survive broker restarts. @Bean public Queue queue() { return new Queue(QUEUE_NAME, true); // 'true' makes the queue durable } Persistent Messages : Messages are saved to disk and not lost if the broker crashes. public void sendMessage(String message) { // Sending persistent message rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_NAME, RabbitMQConfig.ROUTING_KEY, message, messagePostProcessor -> { messagePostProcessor.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT); // Makes the message persistent return messagePostProcessor; }); } Acknowledgments : Ensures messages are only removed once processed by the consumer. By default, Spring AMQP automatically acknowledges messages once they have been processed by the consumer. Publisher Confirms : Confirms that the message has been successfully received by the broker. @Configuration public class RabbitMQConfig { @Bean public ConnectionFactory connectionFactory() { CachingConnectionFactory connectionFactory = new CachingConnectionFactory(\"localhost\"); connectionFactory.setPublisherConfirms(true); // Enable publisher confirms return connectionFactory; } } Dead Letter Queues (DLQ) : Stores messages that cannot be processed. @Bean public Queue dlq() { return new Queue(\"deadLetterQueue\", true); // Create DLQ } @Bean public Binding dlqBinding() { return BindingBuilder.bind(dlq()).to(new DirectExchange(\"dlxExchange\")).with(\"dlxRoutingKey\"); } @Bean public Queue queue() { Map<String, Object> arguments = new HashMap<>(); arguments.put(\"x-dead-letter-exchange\", \"dlxExchange\"); arguments.put(\"x-dead-letter-routing-key\", \"dlxRoutingKey\"); return new Queue(\"mainQueue\", true, false, false, arguments); } High Availability Queues : Ensures queues are available even in the event of a node failure.","title":"Durability Features in RabbitMQ"},{"location":"other/Redis/","text":"Redis Redis is an open-source, in-memory data structure store that can be used as a database, cache, and message broker. It supports various data structures such as strings, hashes, lists, sets, sorted sets, bitmaps, and hyperloglogs. It is often used for caching and session storage due to its fast in-memory processing and support for data persistence. Redis can be used in Spring Boot applications to enhance performance by caching frequently accessed data, storing session data, and more. How to Use Redis in Spring Boot 1. Add Dependencies You need to add the Spring Data Redis dependency and a Redis client, such as Lettuce or Jedis, to your pom.xml file. <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-redis</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-cache</artifactId> </dependency> </dependencies> 2. Configure Redis Connection In your application.properties or application.yml, configure the Redis server details. spring.redis.host=localhost spring.redis.port=6379 spring.redis.password=yourpassword # Optional 3. Enable Caching To enable caching in your Spring Boot application, you need to add the @EnableCaching annotation to your main class or configuration class. @SpringBootApplication @EnableCaching public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 4. Create a Cache Manager You can configure a RedisCacheManager bean to manage your cache. java Copy code @Configuration public class RedisConfig { @Bean public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) { RedisCacheConfiguration cacheConfig = RedisCacheConfiguration.defaultCacheConfig() .entryTtl(Duration.ofMinutes(10)) // Set the cache expiration time .disableCachingNullValues(); // Optionally disable caching of null values return RedisCacheManager.builder(connectionFactory) .cacheDefaults(cacheConfig) .build(); } } 5. Using Cache Annotations You can use the @Cacheable , @CachePut , and @CacheEvict annotations to interact with the cache. @Cacheable : Caches the result of the method. @CachePut : Updates the cache without interfering with the method execution. @CacheEvict : Evicts (removes) a specific cache entry. Example: @Service public class UserService { @Cacheable(value = \"users\", key = \"#userId\") public User getUserById(String userId) { // Simulate database call return new User(userId, \"John Doe\"); } @CachePut(value = \"users\", key = \"#user.id\") public User updateUser(User user) { // Simulate update in database return user; } @CacheEvict(value = \"users\", key = \"#userId\") public void deleteUser(String userId) { // Simulate delete operation } }","title":"Redis"},{"location":"other/Redis/#redis","text":"Redis is an open-source, in-memory data structure store that can be used as a database, cache, and message broker. It supports various data structures such as strings, hashes, lists, sets, sorted sets, bitmaps, and hyperloglogs. It is often used for caching and session storage due to its fast in-memory processing and support for data persistence. Redis can be used in Spring Boot applications to enhance performance by caching frequently accessed data, storing session data, and more.","title":"Redis"},{"location":"other/Redis/#how-to-use-redis-in-spring-boot","text":"","title":"How to Use Redis in Spring Boot"},{"location":"other/Redis/#1-add-dependencies","text":"You need to add the Spring Data Redis dependency and a Redis client, such as Lettuce or Jedis, to your pom.xml file. <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-redis</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-cache</artifactId> </dependency> </dependencies>","title":"1. Add Dependencies"},{"location":"other/Redis/#2-configure-redis-connection","text":"In your application.properties or application.yml, configure the Redis server details. spring.redis.host=localhost spring.redis.port=6379 spring.redis.password=yourpassword # Optional","title":"2. Configure Redis Connection"},{"location":"other/Redis/#3-enable-caching","text":"To enable caching in your Spring Boot application, you need to add the @EnableCaching annotation to your main class or configuration class. @SpringBootApplication @EnableCaching public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } }","title":"3. Enable Caching"},{"location":"other/Redis/#4-create-a-cache-manager","text":"You can configure a RedisCacheManager bean to manage your cache. java Copy code @Configuration public class RedisConfig { @Bean public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) { RedisCacheConfiguration cacheConfig = RedisCacheConfiguration.defaultCacheConfig() .entryTtl(Duration.ofMinutes(10)) // Set the cache expiration time .disableCachingNullValues(); // Optionally disable caching of null values return RedisCacheManager.builder(connectionFactory) .cacheDefaults(cacheConfig) .build(); } }","title":"4. Create a Cache Manager"},{"location":"other/Redis/#5-using-cache-annotations","text":"You can use the @Cacheable , @CachePut , and @CacheEvict annotations to interact with the cache. @Cacheable : Caches the result of the method. @CachePut : Updates the cache without interfering with the method execution. @CacheEvict : Evicts (removes) a specific cache entry. Example: @Service public class UserService { @Cacheable(value = \"users\", key = \"#userId\") public User getUserById(String userId) { // Simulate database call return new User(userId, \"John Doe\"); } @CachePut(value = \"users\", key = \"#user.id\") public User updateUser(User user) { // Simulate update in database return user; } @CacheEvict(value = \"users\", key = \"#userId\") public void deleteUser(String userId) { // Simulate delete operation } }","title":"5. Using Cache Annotations"},{"location":"postgres/Answer/","text":"Questions Basic Queries Retrieve all records from the customers table. select * from customers; List all products whose stock is less than 20. select * from products where stock<20; Show all orders placed in December 2023. select * from orders where order_date between '2023-12-01' and '2023-12-30'; Find the customer details for those who have not provided a phone number. select * from customers where phone is null; Intermediate Queries Write a query to calculate the total revenue from all orders. select sum(total_amount) from orders; List all customers who have placed orders, along with their order count. select customer_id, count(order_id) as count from orders group by customer_id; Find the total quantity sold for each product. select product_id,count(order_id) as quantity from order_items group by product_id; Write a query to update the stock of a product after a sale. UPDATE products SET stock = stock - ( SELECT SUM(quantity) FROM order_items WHERE order_items.product_id = products.product_id ) WHERE product_id IN ( SELECT product_id FROM order_items ); Joins Retrieve all orders along with the customer names who placed them. select first_name, last_name, order_id from customers inner join orders on customers.customer_id = orders.customer_id; List all order items along with the product name and total price for each item. select order_id, product_name, price from order_items left join products on products.product_id = order_items.product_id; Find the customers who purchased \"Laptop.\" SELECT DISTINCT c.first_name, c.last_name FROM customers c INNER JOIN orders o ON c.customer_id = o.customer_id INNER JOIN order_items oi ON o.order_id = oi.order_id INNER JOIN products p ON oi.product_id = p.product_id WHERE p.product_name = 'Laptop'; Advanced Queries Find the top 3 products by revenue. SELECT p.product_name, SUM(p.price * oi.quantity) AS revenue FROM products p INNER JOIN order_items oi ON p.product_id = oi.product_id GROUP BY p.product_name ORDER BY revenue DESC LIMIT 3; Identify customers who have spent more than $1000 on orders. select c.first_name, c.last_name, o.total_amount from customers c inner join orders o on c.customer_id=o.customer_id where o.total_amount > 1000; Retrieve all customers who placed orders in the last 30 days. select c.first_name, c.last_name from customers c inner join orders o on c.customer_id = o.customer_id where order_date >= current_date - interval '30 days'; Write a query to list customers who haven\u2019t placed any orders. SELECT c.first_name, c.last_name FROM customers c LEFT JOIN orders o ON c.customer_id = o.customer_id WHERE o.customer_id IS NULL;","title":"Answer"},{"location":"postgres/Answer/#questions","text":"","title":"Questions"},{"location":"postgres/Answer/#basic-queries","text":"Retrieve all records from the customers table. select * from customers; List all products whose stock is less than 20. select * from products where stock<20; Show all orders placed in December 2023. select * from orders where order_date between '2023-12-01' and '2023-12-30'; Find the customer details for those who have not provided a phone number. select * from customers where phone is null;","title":"Basic Queries"},{"location":"postgres/Answer/#intermediate-queries","text":"Write a query to calculate the total revenue from all orders. select sum(total_amount) from orders; List all customers who have placed orders, along with their order count. select customer_id, count(order_id) as count from orders group by customer_id; Find the total quantity sold for each product. select product_id,count(order_id) as quantity from order_items group by product_id; Write a query to update the stock of a product after a sale. UPDATE products SET stock = stock - ( SELECT SUM(quantity) FROM order_items WHERE order_items.product_id = products.product_id ) WHERE product_id IN ( SELECT product_id FROM order_items );","title":"Intermediate Queries"},{"location":"postgres/Answer/#joins","text":"Retrieve all orders along with the customer names who placed them. select first_name, last_name, order_id from customers inner join orders on customers.customer_id = orders.customer_id; List all order items along with the product name and total price for each item. select order_id, product_name, price from order_items left join products on products.product_id = order_items.product_id; Find the customers who purchased \"Laptop.\" SELECT DISTINCT c.first_name, c.last_name FROM customers c INNER JOIN orders o ON c.customer_id = o.customer_id INNER JOIN order_items oi ON o.order_id = oi.order_id INNER JOIN products p ON oi.product_id = p.product_id WHERE p.product_name = 'Laptop';","title":"Joins"},{"location":"postgres/Answer/#advanced-queries","text":"Find the top 3 products by revenue. SELECT p.product_name, SUM(p.price * oi.quantity) AS revenue FROM products p INNER JOIN order_items oi ON p.product_id = oi.product_id GROUP BY p.product_name ORDER BY revenue DESC LIMIT 3; Identify customers who have spent more than $1000 on orders. select c.first_name, c.last_name, o.total_amount from customers c inner join orders o on c.customer_id=o.customer_id where o.total_amount > 1000; Retrieve all customers who placed orders in the last 30 days. select c.first_name, c.last_name from customers c inner join orders o on c.customer_id = o.customer_id where order_date >= current_date - interval '30 days'; Write a query to list customers who haven\u2019t placed any orders. SELECT c.first_name, c.last_name FROM customers c LEFT JOIN orders o ON c.customer_id = o.customer_id WHERE o.customer_id IS NULL;","title":"Advanced Queries"},{"location":"postgres/Dataset/","text":"Dataset Create Database Create Tables -- Create tables CREATE TABLE customers ( customer_id SERIAL PRIMARY KEY, first_name VARCHAR(50) NOT NULL, last_name VARCHAR(50) NOT NULL, email VARCHAR(100) UNIQUE NOT NULL, phone VARCHAR(15), join_date DATE DEFAULT CURRENT_DATE ); CREATE TABLE orders ( order_id SERIAL PRIMARY KEY, customer_id INT REFERENCES customers(customer_id), order_date DATE DEFAULT CURRENT_DATE, total_amount NUMERIC(10, 2) ); CREATE TABLE products ( product_id SERIAL PRIMARY KEY, product_name VARCHAR(100) NOT NULL, price NUMERIC(10, 2), stock INT DEFAULT 0 ); CREATE TABLE order_items ( order_item_id SERIAL PRIMARY KEY, order_id INT REFERENCES orders(order_id), product_id INT REFERENCES products(product_id), quantity INT NOT NULL, total_price NUMERIC(10, 2) ); -- Insert sample data INSERT INTO customers (first_name, last_name, email, phone) VALUES ('John', 'Doe', 'john.doe@example.com', '1234567890'), ('Jane', 'Smith', 'jane.smith@example.com', '0987654321'), ('Alice', 'Johnson', 'alice.johnson@example.com', NULL), ('Bob', 'Brown', 'bob.brown@example.com', '1122334455'); INSERT INTO products (product_name, price, stock) VALUES ('Laptop', 800.00, 10), ('Smartphone', 500.00, 20), ('Tablet', 300.00, 15), ('Headphones', 50.00, 50), ('Charger', 25.00, 100); INSERT INTO orders (customer_id, order_date, total_amount) VALUES (1, '2023-12-01', 1300.00), (2, '2023-12-02', 550.00), (3, '2023-12-03', 350.00); INSERT INTO order_items (order_id, product_id, quantity, total_price) VALUES (1, 1, 1, 800.00), (1, 2, 1, 500.00), (2, 2, 1, 500.00), (2, 5, 2, 50.00), (3, 3, 1, 300.00), (3, 4, 1, 50.00);","title":"Dataset"},{"location":"postgres/Dataset/#dataset","text":"","title":"Dataset"},{"location":"postgres/Dataset/#create-database","text":"","title":"Create Database"},{"location":"postgres/Dataset/#create-tables","text":"-- Create tables CREATE TABLE customers ( customer_id SERIAL PRIMARY KEY, first_name VARCHAR(50) NOT NULL, last_name VARCHAR(50) NOT NULL, email VARCHAR(100) UNIQUE NOT NULL, phone VARCHAR(15), join_date DATE DEFAULT CURRENT_DATE ); CREATE TABLE orders ( order_id SERIAL PRIMARY KEY, customer_id INT REFERENCES customers(customer_id), order_date DATE DEFAULT CURRENT_DATE, total_amount NUMERIC(10, 2) ); CREATE TABLE products ( product_id SERIAL PRIMARY KEY, product_name VARCHAR(100) NOT NULL, price NUMERIC(10, 2), stock INT DEFAULT 0 ); CREATE TABLE order_items ( order_item_id SERIAL PRIMARY KEY, order_id INT REFERENCES orders(order_id), product_id INT REFERENCES products(product_id), quantity INT NOT NULL, total_price NUMERIC(10, 2) ); -- Insert sample data INSERT INTO customers (first_name, last_name, email, phone) VALUES ('John', 'Doe', 'john.doe@example.com', '1234567890'), ('Jane', 'Smith', 'jane.smith@example.com', '0987654321'), ('Alice', 'Johnson', 'alice.johnson@example.com', NULL), ('Bob', 'Brown', 'bob.brown@example.com', '1122334455'); INSERT INTO products (product_name, price, stock) VALUES ('Laptop', 800.00, 10), ('Smartphone', 500.00, 20), ('Tablet', 300.00, 15), ('Headphones', 50.00, 50), ('Charger', 25.00, 100); INSERT INTO orders (customer_id, order_date, total_amount) VALUES (1, '2023-12-01', 1300.00), (2, '2023-12-02', 550.00), (3, '2023-12-03', 350.00); INSERT INTO order_items (order_id, product_id, quantity, total_price) VALUES (1, 1, 1, 800.00), (1, 2, 1, 500.00), (2, 2, 1, 500.00), (2, 5, 2, 50.00), (3, 3, 1, 300.00), (3, 4, 1, 50.00);","title":"Create Tables"},{"location":"postgres/Question/","text":"Questions Basic Queries Retrieve all records from the customers table. List all products whose stock is less than 20. Show all orders placed in December 2023. Find the customer details for those who have not provided a phone number. Intermediate Queries Write a query to calculate the total revenue from all orders. List all customers who have placed orders, along with their order count. Find the total quantity sold for each product. Write a query to update the stock of a product after a sale. Joins Retrieve all orders along with the customer names who placed them. List all order items along with the product name and total price for each item. Find the customers who purchased \"Laptop.\" Advanced Queries Find the top 3 products by revenue. Identify customers who have spent more than $1000 on orders. Retrieve all customers who placed orders in the last 30 days. Write a query to list customers who haven\u2019t placed any orders.","title":"Question"},{"location":"postgres/Question/#questions","text":"","title":"Questions"},{"location":"postgres/Question/#basic-queries","text":"Retrieve all records from the customers table. List all products whose stock is less than 20. Show all orders placed in December 2023. Find the customer details for those who have not provided a phone number.","title":"Basic Queries"},{"location":"postgres/Question/#intermediate-queries","text":"Write a query to calculate the total revenue from all orders. List all customers who have placed orders, along with their order count. Find the total quantity sold for each product. Write a query to update the stock of a product after a sale.","title":"Intermediate Queries"},{"location":"postgres/Question/#joins","text":"Retrieve all orders along with the customer names who placed them. List all order items along with the product name and total price for each item. Find the customers who purchased \"Laptop.\"","title":"Joins"},{"location":"postgres/Question/#advanced-queries","text":"Find the top 3 products by revenue. Identify customers who have spent more than $1000 on orders. Retrieve all customers who placed orders in the last 30 days. Write a query to list customers who haven\u2019t placed any orders.","title":"Advanced Queries"},{"location":"spring/Actuator/","text":"Spring Boot Actuator Spring Boot Actuator is a set of tools that helps you monitor and manage your Spring Boot application in production. It provides built-in endpoints that expose useful application information, such as health status, metrics, environment properties, and much more. Key Endpoints: Health Endpoint ( /actuator/health ) Displays the health status of the application (e.g., up, down, etc.). Metrics Endpoint ( /actuator/metrics ) Provides a variety of metrics such as memory usage, garbage collection, and request statistics. Info Endpoint ( /actuator/info ) Shows arbitrary application information (e.g., version, build, or custom info). Environment Endpoint ( /actuator/env ) Exposes environment properties such as system properties, environment variables, etc. Logs Endpoint ( /actuator/loggers ) Allows viewing and changing the logging levels of various application components. How to Enable Spring Boot Actuator: 1. Add Dependency: Add the spring-boot-starter-actuator dependency to your pom.xml or build.gradle file. Maven: <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-actuator</artifactId> </dependency> 2. Enable Actuator Endpoints: By default, only a few endpoints (like /actuator/health) are enabled. You can enable additional endpoints in the application.properties or application.yml file. management.endpoints.web.exposure.include=health,metrics,info 3. Access Endpoints: Once the application is running, you can access the available endpoints through HTTP. For example: Health : http://localhost:8080/actuator/health Metrics : http://localhost:8080/actuator/metrics Info : http://localhost:8080/actuator/info Prometheus with Spring Boot Actuator Prometheus is an open-source monitoring and alerting toolkit widely used for gathering and storing time-series data, primarily focused on metrics. It collects and stores metrics in a time-series format, allowing you to query and analyze these metrics over time. Prometheus is often used for monitoring microservices and infrastructure. 1. Add Dependency: Add the required dependencies for Spring Boot Actuator and the Prometheus metrics endpoint. <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-actuator</artifactId> </dependency> <dependency> <groupId>io.micrometer</groupId> <artifactId>micrometer-registry-prometheus</artifactId> </dependency> 2. Enable Prometheus Endpoint Configure Spring Boot to expose the Prometheus-compatible metrics by adding the following in your application.properties or application.yml : management.endpoints.web.exposure.include=health,metrics,prometheus management.endpoint.prometheus.enabled=true","title":"Spring Actuator"},{"location":"spring/Actuator/#spring-boot-actuator","text":"Spring Boot Actuator is a set of tools that helps you monitor and manage your Spring Boot application in production. It provides built-in endpoints that expose useful application information, such as health status, metrics, environment properties, and much more.","title":"Spring Boot Actuator"},{"location":"spring/Actuator/#key-endpoints","text":"Health Endpoint ( /actuator/health ) Displays the health status of the application (e.g., up, down, etc.). Metrics Endpoint ( /actuator/metrics ) Provides a variety of metrics such as memory usage, garbage collection, and request statistics. Info Endpoint ( /actuator/info ) Shows arbitrary application information (e.g., version, build, or custom info). Environment Endpoint ( /actuator/env ) Exposes environment properties such as system properties, environment variables, etc. Logs Endpoint ( /actuator/loggers ) Allows viewing and changing the logging levels of various application components.","title":"Key Endpoints:"},{"location":"spring/Actuator/#how-to-enable-spring-boot-actuator","text":"","title":"How to Enable Spring Boot Actuator:"},{"location":"spring/Actuator/#1-add-dependency","text":"Add the spring-boot-starter-actuator dependency to your pom.xml or build.gradle file. Maven: <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-actuator</artifactId> </dependency>","title":"1. Add Dependency:"},{"location":"spring/Actuator/#2-enable-actuator-endpoints","text":"By default, only a few endpoints (like /actuator/health) are enabled. You can enable additional endpoints in the application.properties or application.yml file. management.endpoints.web.exposure.include=health,metrics,info","title":"2. Enable Actuator Endpoints:"},{"location":"spring/Actuator/#3-access-endpoints","text":"Once the application is running, you can access the available endpoints through HTTP. For example: Health : http://localhost:8080/actuator/health Metrics : http://localhost:8080/actuator/metrics Info : http://localhost:8080/actuator/info","title":"3. Access Endpoints:"},{"location":"spring/Actuator/#prometheus-with-spring-boot-actuator","text":"Prometheus is an open-source monitoring and alerting toolkit widely used for gathering and storing time-series data, primarily focused on metrics. It collects and stores metrics in a time-series format, allowing you to query and analyze these metrics over time. Prometheus is often used for monitoring microservices and infrastructure.","title":"Prometheus with Spring Boot Actuator"},{"location":"spring/Actuator/#1-add-dependency_1","text":"Add the required dependencies for Spring Boot Actuator and the Prometheus metrics endpoint. <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-actuator</artifactId> </dependency> <dependency> <groupId>io.micrometer</groupId> <artifactId>micrometer-registry-prometheus</artifactId> </dependency>","title":"1. Add Dependency:"},{"location":"spring/Actuator/#2-enable-prometheus-endpoint","text":"Configure Spring Boot to expose the Prometheus-compatible metrics by adding the following in your application.properties or application.yml : management.endpoints.web.exposure.include=health,metrics,prometheus management.endpoint.prometheus.enabled=true","title":"2. Enable Prometheus Endpoint"},{"location":"spring/Bean/","text":"Types of Beans in Spring 1. Singleton Beans This is the default scope for beans in Spring. A single instance of the bean is created, and it is shared across the entire Spring container. The same instance is returned whenever it is injected into any other class. 2. Prototype Beans A new instance of the bean is created every time it is requested. The bean is not shared and is returned as a new object each time it is injected. 3. Request Beans The bean is created once per HTTP request . This scope is typically used in web applications . The bean is destroyed once the request is completed. 4. Session Beans The bean is created once per HTTP session . It is typically used to maintain state across multiple requests in a session. 5. Global Session Beans This scope is used in a portlet-based web application . The bean is created once per global HTTP session . 6. Application Beans This scope means that the bean will be created once per Spring ApplicationContext . It is typically used for application-wide beans that are shared across all requests and sessions. Lifecycle of Beans in the Spring Container Instantiation : Beans are created. Property Setting : Dependencies are injected. Custom Initialization : Initialization methods (e.g., @PostConstruct or init-method ) are executed. Bean Usage : Beans are ready to be used. Destruction : Cleanup methods (e.g., @PreDestroy or destroy-method ) are executed when the container shuts down.","title":"Bean"},{"location":"spring/Bean/#types-of-beans-in-spring","text":"","title":"Types of Beans in Spring"},{"location":"spring/Bean/#1-singleton-beans","text":"This is the default scope for beans in Spring. A single instance of the bean is created, and it is shared across the entire Spring container. The same instance is returned whenever it is injected into any other class.","title":"1. Singleton Beans"},{"location":"spring/Bean/#2-prototype-beans","text":"A new instance of the bean is created every time it is requested. The bean is not shared and is returned as a new object each time it is injected.","title":"2. Prototype Beans"},{"location":"spring/Bean/#3-request-beans","text":"The bean is created once per HTTP request . This scope is typically used in web applications . The bean is destroyed once the request is completed.","title":"3. Request Beans"},{"location":"spring/Bean/#4-session-beans","text":"The bean is created once per HTTP session . It is typically used to maintain state across multiple requests in a session.","title":"4. Session Beans"},{"location":"spring/Bean/#5-global-session-beans","text":"This scope is used in a portlet-based web application . The bean is created once per global HTTP session .","title":"5. Global Session Beans"},{"location":"spring/Bean/#6-application-beans","text":"This scope means that the bean will be created once per Spring ApplicationContext . It is typically used for application-wide beans that are shared across all requests and sessions.","title":"6. Application Beans"},{"location":"spring/Bean/#lifecycle-of-beans-in-the-spring-container","text":"Instantiation : Beans are created. Property Setting : Dependencies are injected. Custom Initialization : Initialization methods (e.g., @PostConstruct or init-method ) are executed. Bean Usage : Beans are ready to be used. Destruction : Cleanup methods (e.g., @PreDestroy or destroy-method ) are executed when the container shuts down.","title":"Lifecycle of Beans in the Spring Container"},{"location":"spring/CorrelationId/","text":"Correlation ID A Correlation ID is a unique identifier used to track and associate related requests or transactions across different services in a distributed system. It helps in tracing requests as they pass through various microservices, enabling better debugging, monitoring, and logging. How Correlation IDs Work: Request Initiation: When a client makes a request, a Correlation ID is generated if one is not provided. Propagation: The Correlation ID is passed along with the request headers as the request flows through multiple services. Logging and Monitoring: Each service logs the request with the Correlation ID, making it easier to trace the entire request flow. Why Use Correlation IDs: Debugging: Identify issues by tracing requests across services. Performance Monitoring: Measure the time taken by each service in a request's lifecycle. Error Tracking: Pinpoint where failures occur. Implementation Tips: Generate a Correlation ID at the start of a request if it doesn't exist. Pass the ID through all internal service calls. Include the ID in logs for all services involved. Use UUIDs or similar globally unique identifiers for Correlation IDs.","title":"Correlation ID"},{"location":"spring/CorrelationId/#correlation-id","text":"A Correlation ID is a unique identifier used to track and associate related requests or transactions across different services in a distributed system. It helps in tracing requests as they pass through various microservices, enabling better debugging, monitoring, and logging.","title":"Correlation ID"},{"location":"spring/CorrelationId/#how-correlation-ids-work","text":"Request Initiation: When a client makes a request, a Correlation ID is generated if one is not provided. Propagation: The Correlation ID is passed along with the request headers as the request flows through multiple services. Logging and Monitoring: Each service logs the request with the Correlation ID, making it easier to trace the entire request flow.","title":"How Correlation IDs Work:"},{"location":"spring/CorrelationId/#why-use-correlation-ids","text":"Debugging: Identify issues by tracing requests across services. Performance Monitoring: Measure the time taken by each service in a request's lifecycle. Error Tracking: Pinpoint where failures occur.","title":"Why Use Correlation IDs:"},{"location":"spring/CorrelationId/#implementation-tips","text":"Generate a Correlation ID at the start of a request if it doesn't exist. Pass the ID through all internal service calls. Include the ID in logs for all services involved. Use UUIDs or similar globally unique identifiers for Correlation IDs.","title":"Implementation Tips:"},{"location":"spring/Introduction/","text":"Spring Framework The Spring Framework is a comprehensive framework for building Java-based applications. It provides a wide variety of features to help developers create scalable, maintainable, and secure applications. Below are the core features of the Spring Framework: Core Features: 1. Inversion of Control (IoC) This is the heart of the Spring Framework. It involves the inversion of the flow of control in an application. Instead of creating dependencies manually, Spring manages the creation and injection of dependencies. 2. Dependency Injection (DI) Dependency Injection is a technique used to implement IoC, where objects are provided with their dependencies by an external container, rather than the objects creating their dependencies. @Component public class Car { private Engine engine; @Autowired public Car(Engine engine) { this.engine = engine; } // Getters and setters }","title":"Introduction"},{"location":"spring/Introduction/#spring-framework","text":"The Spring Framework is a comprehensive framework for building Java-based applications. It provides a wide variety of features to help developers create scalable, maintainable, and secure applications. Below are the core features of the Spring Framework:","title":"Spring Framework"},{"location":"spring/Introduction/#core-features","text":"","title":"Core Features:"},{"location":"spring/Introduction/#1-inversion-of-control-ioc","text":"This is the heart of the Spring Framework. It involves the inversion of the flow of control in an application. Instead of creating dependencies manually, Spring manages the creation and injection of dependencies.","title":"1. Inversion of Control (IoC)"},{"location":"spring/Introduction/#2-dependency-injection-di","text":"Dependency Injection is a technique used to implement IoC, where objects are provided with their dependencies by an external container, rather than the objects creating their dependencies. @Component public class Car { private Engine engine; @Autowired public Car(Engine engine) { this.engine = engine; } // Getters and setters }","title":"2. Dependency Injection (DI)"},{"location":"spring/JPA/","text":"Java Persistence API (JPA) Java Persistence API (JPA) is a specification in Java that allows developers to map Java objects to database tables and manage relational data in Java applications. It provides an abstraction over Object-Relational Mapping (ORM) frameworks like Hibernate, EclipseLink, and others. JPA is used to handle data persistence in an object-oriented way, making it easier to interact with databases. Core Features of JPA Entity Classes Java classes annotated with @Entity represent database tables. Fields in these classes map to columns in the corresponding table. Annotations for Mapping @Entity : Marks the class as an entity. @Table : Specifies the table name. @Id : Defines the primary key. @GeneratedValue : Specifies how primary key values are generated. @Column : Maps a field to a specific column. Relationships Annotations for Relationships : @OneToOne , @OneToMany , @ManyToOne , @ManyToMany for defining relationships between entities. Customizing Relationships : @JoinColumn and @JoinTable . Query Language JPA provides JPQL (Java Persistence Query Language) , a database-agnostic query language. Example: SELECT e FROM Employee e WHERE e.salary > :amount ** EntityManager The core interface for managing the persistence lifecycle of entities. Provides methods like: persist merge remove find Transactions Supports declarative transaction management. Can be managed: Via annotations like @Transactional in Spring. Programmatically. Caching JPA supports: First-level caching (per session). Second-level caching (shared).","title":"JPA"},{"location":"spring/JPA/#java-persistence-api-jpa","text":"Java Persistence API (JPA) is a specification in Java that allows developers to map Java objects to database tables and manage relational data in Java applications. It provides an abstraction over Object-Relational Mapping (ORM) frameworks like Hibernate, EclipseLink, and others. JPA is used to handle data persistence in an object-oriented way, making it easier to interact with databases.","title":"Java Persistence API (JPA)"},{"location":"spring/JPA/#core-features-of-jpa","text":"","title":"Core Features of JPA"},{"location":"spring/JPA/#entity-classes","text":"Java classes annotated with @Entity represent database tables. Fields in these classes map to columns in the corresponding table.","title":"Entity Classes"},{"location":"spring/JPA/#annotations-for-mapping","text":"@Entity : Marks the class as an entity. @Table : Specifies the table name. @Id : Defines the primary key. @GeneratedValue : Specifies how primary key values are generated. @Column : Maps a field to a specific column.","title":"Annotations for Mapping"},{"location":"spring/JPA/#relationships","text":"Annotations for Relationships : @OneToOne , @OneToMany , @ManyToOne , @ManyToMany for defining relationships between entities. Customizing Relationships : @JoinColumn and @JoinTable .","title":"Relationships"},{"location":"spring/JPA/#query-language","text":"JPA provides JPQL (Java Persistence Query Language) , a database-agnostic query language. Example: SELECT e FROM Employee e WHERE e.salary > :amount","title":"Query Language"},{"location":"spring/JPA/#entitymanager","text":"The core interface for managing the persistence lifecycle of entities. Provides methods like: persist merge remove find","title":"** EntityManager"},{"location":"spring/JPA/#transactions","text":"Supports declarative transaction management. Can be managed: Via annotations like @Transactional in Spring. Programmatically.","title":"Transactions"},{"location":"spring/JPA/#caching","text":"JPA supports: First-level caching (per session). Second-level caching (shared).","title":"Caching"},{"location":"spring/JWT/","text":"JSON Web Token (JWT) What is JWT? JWT stands for JSON Web Token , a compact and self-contained way to securely transmit information between parties as a JSON object. It is widely used in authentication and authorization processes, particularly in modern web applications and APIs. Structure of a JWT A JWT is composed of three parts separated by dots ( . ): 1. Header 2. Payload 3. Signature 1. Header The header contains metadata about the token, such as the type of token ( JWT ) and the algorithm used to sign it (e.g., HMAC SHA256 or RSA ). Example: { \"alg\": \"HS256\", \"typ\": \"JWT\" } 2. Payload The payload contains the claims. Claims are statements about an entity (usually the user) and additional data. { \"sub\": \"1234567890\", \"name\": \"John Doe\", \"iat\": 1516239022 } Common claim types: Registered Claims (e.g., iss, sub, aud, exp) Public Claims (custom claims defined by the user) Private Claims (shared between parties) 3. Signature The signature is used to verify that the message wasn\u2019t altered and can be trusted. It is created using the header, payload, a secret key, and the algorithm specified. Signature creation (with HMAC SHA256): HMACSHA256( base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret )","title":"JWT"},{"location":"spring/JWT/#json-web-token-jwt","text":"","title":"JSON Web Token (JWT)"},{"location":"spring/JWT/#what-is-jwt","text":"JWT stands for JSON Web Token , a compact and self-contained way to securely transmit information between parties as a JSON object. It is widely used in authentication and authorization processes, particularly in modern web applications and APIs.","title":"What is JWT?"},{"location":"spring/JWT/#structure-of-a-jwt","text":"A JWT is composed of three parts separated by dots ( . ): 1. Header 2. Payload 3. Signature","title":"Structure of a JWT"},{"location":"spring/JWT/#1-header","text":"The header contains metadata about the token, such as the type of token ( JWT ) and the algorithm used to sign it (e.g., HMAC SHA256 or RSA ). Example: { \"alg\": \"HS256\", \"typ\": \"JWT\" }","title":"1. Header"},{"location":"spring/JWT/#2-payload","text":"The payload contains the claims. Claims are statements about an entity (usually the user) and additional data. { \"sub\": \"1234567890\", \"name\": \"John Doe\", \"iat\": 1516239022 } Common claim types: Registered Claims (e.g., iss, sub, aud, exp) Public Claims (custom claims defined by the user) Private Claims (shared between parties)","title":"2. Payload"},{"location":"spring/JWT/#3-signature","text":"The signature is used to verify that the message wasn\u2019t altered and can be trusted. It is created using the header, payload, a secret key, and the algorithm specified. Signature creation (with HMAC SHA256): HMACSHA256( base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret )","title":"3. Signature"},{"location":"spring/Keycloak%20Implementation/","text":"Keycloak as Resource Server in Spring Boot Application 1. Keycloak Setup Realm: Create a realm in Keycloak for your application (e.g., myapp-realm ). Client: Add a new client in the Keycloak realm (e.g., spring-boot-client ). Configure the client to use public client access. Set the Valid Redirect URI to the correct URL of your Spring Boot app (e.g., http://localhost:8080/* ). Roles: Create roles like ACCOUNTS , CARDS , and LOANS in the Keycloak realm. Assign these roles to users based on their permissions. 2. Spring Boot Security Configuration (Resource Server) In this part, Spring Security is configured to act as a resource server that validates JWT tokens issued by Keycloak. 2.1 Dependencies: Add the following dependencies to your pom.xml to integrate Spring Security and Keycloak: <dependency> <groupId>org.keycloak</groupId> <artifactId>keycloak-spring-boot-starter</artifactId> <version>YOUR_KEYCLOAK_VERSION</version> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-oauth2-resource-server</artifactId> </dependency> 2.2 Application Properties Configuration: In application.properties (or application.yml ), configure Keycloak settings: keycloak.realm=myapp-realm keycloak.auth-server-url=http://localhost:8080/realms/myapp-realm keycloak.public-client=true keycloak.resource=spring-boot-client keycloak.credentials.secret=YOUR_SECRET spring.security.oauth2.resourceserver.jwt.issuer-uri=http://localhost:8080/realms/myapp-realm 3. Security Configuration Class Create a SecurityConfig class to define resource server settings and JWT validation. 3.1 SecurityConfig Class: @Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http .oauth2ResourceServer() .jwt() .and() .authorizeRequests() .antMatchers(\"/accounts/**\").hasRole(\"ACCOUNTS\") .antMatchers(\"/cards/**\").hasRole(\"CARDS\") .antMatchers(\"/loans/**\").hasRole(\"LOANS\") .anyRequest().authenticated(); } } Role-Based Access Control: Here, we restrict access to certain URLs based on the roles (ACCOUNTS, CARDS, LOANS) defined in Keycloak. JWT Converter: JwtAuthenticationConverter is used to extract roles from the JWT token and map them to Spring Security's authorities. 4. JWT Token Validation Spring Security validates the JWT token by using Keycloak\u2019s public key endpoint, typically at: http://localhost:8080/realms/myapp-realm/protocol/openid-connect/certs This URL exposes Keycloak's public keys used for validating the JWT signatures. 5. Role Mapping (Keycloak Role Converter) You need to map the roles from Keycloak's JWT into Spring Security roles. You can do this with a custom Converter . 5.1 KeycloakRoleConverter: public class KeycloakRoleConverter implements Converter<Jwt, AbstractAuthenticationToken> { @Override public AbstractAuthenticationToken convert(Jwt jwt) { List<GrantedAuthority> authorities = extractRoles(jwt); return new JwtAuthenticationToken(jwt, authorities); } private List<GrantedAuthority> extractRoles(Jwt jwt) { Collection<String> roles = (Collection<String>) jwt.getClaims().get(\"realm_access\").get(\"roles\"); return roles.stream() .map(role -> new SimpleGrantedAuthority(\"ROLE_\" + role)) .collect(Collectors.toList()); } } This class maps Keycloak roles from the realm_access claim in the JWT to Spring Security's granted authorities (prefix ROLE_ added). 6. Disabling CSRF Protection Since this is a stateless application using JWT, CSRF protection is not needed and can be disabled: http.csrf().disable(); 7. Security Flow Client Authentication: A client authenticates with Keycloak and obtains a JWT token. JWT Token Transmission: The client includes the JWT token in the Authorization header (Bearer ) in its API requests. JWT Validation: Spring Boot's SecurityConfig class validates the token using the public keys from Keycloak. Role-based Authorization: Based on the roles embedded in the JWT (via realm_access claim), the resource server enforces access control to various APIs. 8. Token Expiry and Refresh Keycloak issues short-lived JWT tokens, and the client may need to refresh the token when expired. This can be done using a refresh token, which is also handled by Keycloak.","title":"Keycloak"},{"location":"spring/Keycloak%20Implementation/#keycloak-as-resource-server-in-spring-boot-application","text":"","title":"Keycloak as Resource Server in Spring Boot Application"},{"location":"spring/Keycloak%20Implementation/#1-keycloak-setup","text":"","title":"1. Keycloak Setup"},{"location":"spring/Keycloak%20Implementation/#realm","text":"Create a realm in Keycloak for your application (e.g., myapp-realm ).","title":"Realm:"},{"location":"spring/Keycloak%20Implementation/#client","text":"Add a new client in the Keycloak realm (e.g., spring-boot-client ). Configure the client to use public client access. Set the Valid Redirect URI to the correct URL of your Spring Boot app (e.g., http://localhost:8080/* ).","title":"Client:"},{"location":"spring/Keycloak%20Implementation/#roles","text":"Create roles like ACCOUNTS , CARDS , and LOANS in the Keycloak realm. Assign these roles to users based on their permissions.","title":"Roles:"},{"location":"spring/Keycloak%20Implementation/#2-spring-boot-security-configuration-resource-server","text":"In this part, Spring Security is configured to act as a resource server that validates JWT tokens issued by Keycloak.","title":"2. Spring Boot Security Configuration (Resource Server)"},{"location":"spring/Keycloak%20Implementation/#21-dependencies","text":"Add the following dependencies to your pom.xml to integrate Spring Security and Keycloak: <dependency> <groupId>org.keycloak</groupId> <artifactId>keycloak-spring-boot-starter</artifactId> <version>YOUR_KEYCLOAK_VERSION</version> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-oauth2-resource-server</artifactId> </dependency>","title":"2.1 Dependencies:"},{"location":"spring/Keycloak%20Implementation/#22-application-properties-configuration","text":"In application.properties (or application.yml ), configure Keycloak settings: keycloak.realm=myapp-realm keycloak.auth-server-url=http://localhost:8080/realms/myapp-realm keycloak.public-client=true keycloak.resource=spring-boot-client keycloak.credentials.secret=YOUR_SECRET spring.security.oauth2.resourceserver.jwt.issuer-uri=http://localhost:8080/realms/myapp-realm","title":"2.2 Application Properties Configuration:"},{"location":"spring/Keycloak%20Implementation/#3-security-configuration-class","text":"Create a SecurityConfig class to define resource server settings and JWT validation.","title":"3. Security Configuration Class"},{"location":"spring/Keycloak%20Implementation/#31-securityconfig-class","text":"@Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http .oauth2ResourceServer() .jwt() .and() .authorizeRequests() .antMatchers(\"/accounts/**\").hasRole(\"ACCOUNTS\") .antMatchers(\"/cards/**\").hasRole(\"CARDS\") .antMatchers(\"/loans/**\").hasRole(\"LOANS\") .anyRequest().authenticated(); } }","title":"3.1 SecurityConfig Class:"},{"location":"spring/Keycloak%20Implementation/#role-based-access-control","text":"Here, we restrict access to certain URLs based on the roles (ACCOUNTS, CARDS, LOANS) defined in Keycloak.","title":"Role-Based Access Control:"},{"location":"spring/Keycloak%20Implementation/#jwt-converter","text":"JwtAuthenticationConverter is used to extract roles from the JWT token and map them to Spring Security's authorities.","title":"JWT Converter:"},{"location":"spring/Keycloak%20Implementation/#4-jwt-token-validation","text":"Spring Security validates the JWT token by using Keycloak\u2019s public key endpoint, typically at: http://localhost:8080/realms/myapp-realm/protocol/openid-connect/certs This URL exposes Keycloak's public keys used for validating the JWT signatures.","title":"4. JWT Token Validation"},{"location":"spring/Keycloak%20Implementation/#5-role-mapping-keycloak-role-converter","text":"You need to map the roles from Keycloak's JWT into Spring Security roles. You can do this with a custom Converter .","title":"5. Role Mapping (Keycloak Role Converter)"},{"location":"spring/Keycloak%20Implementation/#51-keycloakroleconverter","text":"public class KeycloakRoleConverter implements Converter<Jwt, AbstractAuthenticationToken> { @Override public AbstractAuthenticationToken convert(Jwt jwt) { List<GrantedAuthority> authorities = extractRoles(jwt); return new JwtAuthenticationToken(jwt, authorities); } private List<GrantedAuthority> extractRoles(Jwt jwt) { Collection<String> roles = (Collection<String>) jwt.getClaims().get(\"realm_access\").get(\"roles\"); return roles.stream() .map(role -> new SimpleGrantedAuthority(\"ROLE_\" + role)) .collect(Collectors.toList()); } } This class maps Keycloak roles from the realm_access claim in the JWT to Spring Security's granted authorities (prefix ROLE_ added).","title":"5.1 KeycloakRoleConverter:"},{"location":"spring/Keycloak%20Implementation/#6-disabling-csrf-protection","text":"Since this is a stateless application using JWT, CSRF protection is not needed and can be disabled: http.csrf().disable();","title":"6. Disabling CSRF Protection"},{"location":"spring/Keycloak%20Implementation/#7-security-flow","text":"","title":"7. Security Flow"},{"location":"spring/Keycloak%20Implementation/#client-authentication","text":"A client authenticates with Keycloak and obtains a JWT token.","title":"Client Authentication:"},{"location":"spring/Keycloak%20Implementation/#jwt-token-transmission","text":"The client includes the JWT token in the Authorization header (Bearer ) in its API requests.","title":"JWT Token Transmission:"},{"location":"spring/Keycloak%20Implementation/#jwt-validation","text":"Spring Boot's SecurityConfig class validates the token using the public keys from Keycloak.","title":"JWT Validation:"},{"location":"spring/Keycloak%20Implementation/#role-based-authorization","text":"Based on the roles embedded in the JWT (via realm_access claim), the resource server enforces access control to various APIs.","title":"Role-based Authorization:"},{"location":"spring/Keycloak%20Implementation/#8-token-expiry-and-refresh","text":"Keycloak issues short-lived JWT tokens, and the client may need to refresh the token when expired. This can be done using a refresh token, which is also handled by Keycloak.","title":"8. Token Expiry and Refresh"},{"location":"spring/ORM/","text":"Object-Relational Mapping (ORM) ORM stands for Object-Relational Mapping , a programming technique used to map objects in your code (like classes and their instances) to relational database tables. It enables developers to interact with databases using high-level, object-oriented syntax rather than writing SQL queries. Key Features of ORM 1. Abstraction Hides the complexity of database operations. Allows developers to focus on application logic rather than database-specific syntax. 2. Object Mapping Maps database tables to classes. Maps table rows to class instances and table columns to object attributes. 3. Automatic Query Generation Automatically generates SQL queries for common operations like INSERT , UPDATE , DELETE , and SELECT . 4. Database Independence Abstracts the underlying database. Enables application portability across different database systems. Benefits of Using ORM 1. Productivity Reduces the amount of boilerplate code needed for database operations. 2. Maintainability Makes code easier to read and maintain by aligning it with object-oriented design principles. 3. Security Reduces the risk of SQL injection by using parameterized queries or prepared statements under the hood. 4. Flexibility Provides tools to migrate between different database systems with minimal code changes. 5. Relationships Simplifies handling of database relationships like: One-to-One One-to-Many Many-to-Many","title":"ORM"},{"location":"spring/ORM/#object-relational-mapping-orm","text":"ORM stands for Object-Relational Mapping , a programming technique used to map objects in your code (like classes and their instances) to relational database tables. It enables developers to interact with databases using high-level, object-oriented syntax rather than writing SQL queries.","title":"Object-Relational Mapping (ORM)"},{"location":"spring/ORM/#key-features-of-orm","text":"","title":"Key Features of ORM"},{"location":"spring/ORM/#1-abstraction","text":"Hides the complexity of database operations. Allows developers to focus on application logic rather than database-specific syntax.","title":"1. Abstraction"},{"location":"spring/ORM/#2-object-mapping","text":"Maps database tables to classes. Maps table rows to class instances and table columns to object attributes.","title":"2. Object Mapping"},{"location":"spring/ORM/#3-automatic-query-generation","text":"Automatically generates SQL queries for common operations like INSERT , UPDATE , DELETE , and SELECT .","title":"3. Automatic Query Generation"},{"location":"spring/ORM/#4-database-independence","text":"Abstracts the underlying database. Enables application portability across different database systems.","title":"4. Database Independence"},{"location":"spring/ORM/#benefits-of-using-orm","text":"","title":"Benefits of Using ORM"},{"location":"spring/ORM/#1-productivity","text":"Reduces the amount of boilerplate code needed for database operations.","title":"1. Productivity"},{"location":"spring/ORM/#2-maintainability","text":"Makes code easier to read and maintain by aligning it with object-oriented design principles.","title":"2. Maintainability"},{"location":"spring/ORM/#3-security","text":"Reduces the risk of SQL injection by using parameterized queries or prepared statements under the hood.","title":"3. Security"},{"location":"spring/ORM/#4-flexibility","text":"Provides tools to migrate between different database systems with minimal code changes.","title":"4. Flexibility"},{"location":"spring/ORM/#5-relationships","text":"Simplifies handling of database relationships like: One-to-One One-to-Many Many-to-Many","title":"5. Relationships"},{"location":"spring/Oauth/","text":"OAuth 2.0 Overview OAuth 2.0 is an authorization framework that enables applications to obtain limited access to user accounts on an HTTP service without exposing the user's credentials. It allows third-party applications to act on behalf of users through a delegated access mechanism. Key Roles in OAuth 2.0 Resource Owner : The user who owns the data or resources being accessed. Client : The application requesting access to the resource owner's data. Authorization Server : The server that authenticates the resource owner and issues access tokens to the client. Resource Server : The API or server hosting the resource owner's data. It uses the access token to validate requests. OAuth 2.0 Grant Types Authorization Code Grant Used for server-side applications. The client exchanges an authorization code for an access token. Secure because the token is never exposed to the user. Flow : - The user logs in and authorizes the client. - The client receives an authorization code. - The client exchanges the code for an access token at the authorization server. Implicit Grant Used for single-page or client-side applications. The access token is returned directly to the client in the URL fragment. Less secure because tokens are exposed in the browser. Resource Owner Password Credentials Grant The user provides their username and password to the client, which exchanges them for an access token. Not recommended unless the client is highly trusted. Client Credentials Grant Used for machine-to-machine communication. The client authenticates itself with the authorization server to obtain an access token. Refresh Token Grant Enables the client to obtain a new access token without requiring the user to log in again. This is done by exchanging a refresh token for a new access token. Key Components Access Token A short-lived token that grants access to the resource server. Refresh Token A long-lived token that can be used to renew the access token. Scopes Define the level of access the client has (e.g., read-only or full access to the resource).","title":"OAuth2"},{"location":"spring/Oauth/#oauth-20-overview","text":"OAuth 2.0 is an authorization framework that enables applications to obtain limited access to user accounts on an HTTP service without exposing the user's credentials. It allows third-party applications to act on behalf of users through a delegated access mechanism.","title":"OAuth 2.0 Overview"},{"location":"spring/Oauth/#key-roles-in-oauth-20","text":"Resource Owner : The user who owns the data or resources being accessed. Client : The application requesting access to the resource owner's data. Authorization Server : The server that authenticates the resource owner and issues access tokens to the client. Resource Server : The API or server hosting the resource owner's data. It uses the access token to validate requests.","title":"Key Roles in OAuth 2.0"},{"location":"spring/Oauth/#oauth-20-grant-types","text":"Authorization Code Grant Used for server-side applications. The client exchanges an authorization code for an access token. Secure because the token is never exposed to the user. Flow : - The user logs in and authorizes the client. - The client receives an authorization code. - The client exchanges the code for an access token at the authorization server. Implicit Grant Used for single-page or client-side applications. The access token is returned directly to the client in the URL fragment. Less secure because tokens are exposed in the browser. Resource Owner Password Credentials Grant The user provides their username and password to the client, which exchanges them for an access token. Not recommended unless the client is highly trusted. Client Credentials Grant Used for machine-to-machine communication. The client authenticates itself with the authorization server to obtain an access token. Refresh Token Grant Enables the client to obtain a new access token without requiring the user to log in again. This is done by exchanging a refresh token for a new access token.","title":"OAuth 2.0 Grant Types"},{"location":"spring/Oauth/#key-components","text":"Access Token A short-lived token that grants access to the resource server. Refresh Token A long-lived token that can be used to renew the access token. Scopes Define the level of access the client has (e.g., read-only or full access to the resource).","title":"Key Components"},{"location":"spring/RestTemplate/","text":"RestTemplate in Spring RestTemplate is a synchronous HTTP client provided by Spring for communicating with RESTful web services. It allows your application to consume REST APIs easily and efficiently. Although it is widely used in Spring applications, it is considered a legacy tool as of Spring 5. WebClient (from the Spring WebFlux module) is recommended for new development due to its support for asynchronous and reactive programming. Key Features of RestTemplate Simplifies interaction with HTTP servers : Makes it easier to work with RESTful APIs. Supports various HTTP methods : Includes methods like GET , POST , PUT , DELETE , etc. Automatic data conversion : Converts Java objects to and from JSON or XML when interacting with RESTful services. Customization : Interceptors : To modify requests and responses. Error Handlers : To handle HTTP errors. Message Converters : For customizing data formats (e.g., JSON, XML). 1. Add Dependency in pom.xml <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> 2. Creating a RestTemplate Bean You can configure RestTemplate as a Spring Bean so that it can be injected into any component. import org.springframework.boot.web.client.RestTemplateBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.client.RestTemplate; @Configuration public class AppConfig { @Bean public RestTemplate restTemplate() { return new RestTemplate(); } } 3. Using RestTemplate in a Service Here\u2019s how you can use RestTemplate to make a GET request: import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.web.client.RestTemplate; @Service public class MyService { @Autowired private RestTemplate restTemplate; public String getDataFromApi() { String url = \"https://api.example.com/data\"; return restTemplate.getForObject(url, String.class); } } 4. Handling JSON Responses If you're working with JSON data, you can use RestTemplate with HttpEntity and HttpHeaders to send and receive JSON. import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.*; import org.springframework.stereotype.Service; import org.springframework.web.client.RestTemplate; @Service public class MyService { @Autowired private RestTemplate restTemplate; public ResponseDTO sendDataToApi(Object data) { String url = \"https://api.example.com/submit\"; // URL of the API // Create HttpHeaders and set Content-Type HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); // Create HttpEntity with request body and headers HttpEntity<Object> entity = new HttpEntity<>(data, headers); // Make the POST request ResponseEntity<ResponseDTO> responseEntity = restTemplate.exchange( url, // URL HttpMethod.POST, // HTTP Method (POST) entity, // HttpEntity containing request body and headers ResponseDTO.class // Expected response type ); // Return the response body (ResponseDTO) return responseEntity.getBody(); } } Recommended Alternative With the introduction of Spring WebFlux , the WebClient is preferred for new applications as it supports asynchronous and reactive programming paradigms, offering better performance and scalability in reactive systems.","title":"RestTemplate"},{"location":"spring/RestTemplate/#resttemplate-in-spring","text":"RestTemplate is a synchronous HTTP client provided by Spring for communicating with RESTful web services. It allows your application to consume REST APIs easily and efficiently. Although it is widely used in Spring applications, it is considered a legacy tool as of Spring 5. WebClient (from the Spring WebFlux module) is recommended for new development due to its support for asynchronous and reactive programming.","title":"RestTemplate in Spring"},{"location":"spring/RestTemplate/#key-features-of-resttemplate","text":"Simplifies interaction with HTTP servers : Makes it easier to work with RESTful APIs. Supports various HTTP methods : Includes methods like GET , POST , PUT , DELETE , etc. Automatic data conversion : Converts Java objects to and from JSON or XML when interacting with RESTful services. Customization : Interceptors : To modify requests and responses. Error Handlers : To handle HTTP errors. Message Converters : For customizing data formats (e.g., JSON, XML).","title":"Key Features of RestTemplate"},{"location":"spring/RestTemplate/#1-add-dependency-in-pomxml","text":"<dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency>","title":"1. Add Dependency in pom.xml"},{"location":"spring/RestTemplate/#2-creating-a-resttemplate-bean","text":"You can configure RestTemplate as a Spring Bean so that it can be injected into any component. import org.springframework.boot.web.client.RestTemplateBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.client.RestTemplate; @Configuration public class AppConfig { @Bean public RestTemplate restTemplate() { return new RestTemplate(); } }","title":"2. Creating a RestTemplate Bean"},{"location":"spring/RestTemplate/#3-using-resttemplate-in-a-service","text":"Here\u2019s how you can use RestTemplate to make a GET request: import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.web.client.RestTemplate; @Service public class MyService { @Autowired private RestTemplate restTemplate; public String getDataFromApi() { String url = \"https://api.example.com/data\"; return restTemplate.getForObject(url, String.class); } }","title":"3. Using RestTemplate in a Service"},{"location":"spring/RestTemplate/#4-handling-json-responses","text":"If you're working with JSON data, you can use RestTemplate with HttpEntity and HttpHeaders to send and receive JSON. import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.*; import org.springframework.stereotype.Service; import org.springframework.web.client.RestTemplate; @Service public class MyService { @Autowired private RestTemplate restTemplate; public ResponseDTO sendDataToApi(Object data) { String url = \"https://api.example.com/submit\"; // URL of the API // Create HttpHeaders and set Content-Type HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); // Create HttpEntity with request body and headers HttpEntity<Object> entity = new HttpEntity<>(data, headers); // Make the POST request ResponseEntity<ResponseDTO> responseEntity = restTemplate.exchange( url, // URL HttpMethod.POST, // HTTP Method (POST) entity, // HttpEntity containing request body and headers ResponseDTO.class // Expected response type ); // Return the response body (ResponseDTO) return responseEntity.getBody(); } }","title":"4. Handling JSON Responses"},{"location":"spring/RestTemplate/#recommended-alternative","text":"With the introduction of Spring WebFlux , the WebClient is preferred for new applications as it supports asynchronous and reactive programming paradigms, offering better performance and scalability in reactive systems.","title":"Recommended Alternative"},{"location":"spring/Scheduling/","text":"Spring Boot Scheduler A scheduler in Spring Boot is a feature that allows you to execute tasks at specific intervals or times without manual intervention. This is useful for tasks like periodic data processing, sending emails, generating reports, and any other background job that needs to run at fixed times or intervals. Key Concepts 1. Scheduling in Spring Boot: Scheduling refers to the process of automating the execution of tasks at specific times or intervals. Spring Boot provides a way to configure and manage such tasks using the @Scheduled annotation, which allows the developer to define when a task should run. 2. Types of Scheduling in Spring Boot: Fixed Rate Scheduling : Executes the task repeatedly at fixed intervals, regardless of the execution time of the task. It is defined by the fixedRate attribute. Fixed Delay Scheduling : Executes the task after a fixed amount of time, but the time is measured from the completion of the previous execution. It is defined by the fixedDelay attribute. Cron Expression Scheduling : This provides a more flexible approach, allowing you to define more complex schedules using cron expressions (like running at a specific time of day, day of the week, etc.). It is defined by the cron attribute. 3. Enabling Scheduling: @EnableScheduling : This annotation is required to enable Spring's scheduling functionality in your application. It is typically added to the main application class to globally enable scheduled tasks. 4. Scheduled Task Execution: The @Scheduled annotation is used to mark methods as scheduled tasks. Spring will execute these methods based on the configured schedule (fixed rate, fixed delay, or cron expression). 5. Customizing Task Execution: The default behavior of scheduled tasks is to execute in a single-threaded manner. However, this can be customized by providing a ThreadPoolTaskScheduler to control the number of threads used to execute scheduled tasks. 6. Task Scheduler: Spring Boot uses a TaskScheduler to handle the execution of scheduled tasks. By default, it uses a SimpleAsyncTaskExecutor , but a custom ThreadPoolTaskScheduler can be configured for more control, such as setting the number of threads or customizing task behavior. 7. Profiles and Scheduling: Scheduling tasks can be environment-specific, meaning you may want certain tasks to run only in specific environments (e.g., production but not development). Spring Boot supports defining scheduled tasks within specific profiles. 8. Error Handling: Scheduled tasks should be designed to handle failures. If a task fails, Spring doesn't automatically retry it. You should handle errors gracefully and ensure tasks don't break other processes. Use Cases Data Cleanup : Periodically deleting old records from a database to maintain performance and data consistency. Email Notifications : Sending periodic reminders, newsletters, or promotional emails. Report Generation : Generating daily or weekly reports at specific times (e.g., midnight every day). System Monitoring : Running health checks or monitoring system status at regular intervals. Backup Jobs : Automating backups at specific times (e.g., every Sunday at 3:00 AM). Summary A scheduler in Spring Boot allows tasks to be executed automatically at specific intervals or times using the @Scheduled annotation. It can be configured with fixed rate, fixed delay, or cron expressions, and is essential for automating background processes like data cleanup, report generation, and system monitoring.","title":"Scheduling"},{"location":"spring/Scheduling/#spring-boot-scheduler","text":"A scheduler in Spring Boot is a feature that allows you to execute tasks at specific intervals or times without manual intervention. This is useful for tasks like periodic data processing, sending emails, generating reports, and any other background job that needs to run at fixed times or intervals.","title":"Spring Boot Scheduler"},{"location":"spring/Scheduling/#key-concepts","text":"","title":"Key Concepts"},{"location":"spring/Scheduling/#1-scheduling-in-spring-boot","text":"Scheduling refers to the process of automating the execution of tasks at specific times or intervals. Spring Boot provides a way to configure and manage such tasks using the @Scheduled annotation, which allows the developer to define when a task should run.","title":"1. Scheduling in Spring Boot:"},{"location":"spring/Scheduling/#2-types-of-scheduling-in-spring-boot","text":"Fixed Rate Scheduling : Executes the task repeatedly at fixed intervals, regardless of the execution time of the task. It is defined by the fixedRate attribute. Fixed Delay Scheduling : Executes the task after a fixed amount of time, but the time is measured from the completion of the previous execution. It is defined by the fixedDelay attribute. Cron Expression Scheduling : This provides a more flexible approach, allowing you to define more complex schedules using cron expressions (like running at a specific time of day, day of the week, etc.). It is defined by the cron attribute.","title":"2. Types of Scheduling in Spring Boot:"},{"location":"spring/Scheduling/#3-enabling-scheduling","text":"@EnableScheduling : This annotation is required to enable Spring's scheduling functionality in your application. It is typically added to the main application class to globally enable scheduled tasks.","title":"3. Enabling Scheduling:"},{"location":"spring/Scheduling/#4-scheduled-task-execution","text":"The @Scheduled annotation is used to mark methods as scheduled tasks. Spring will execute these methods based on the configured schedule (fixed rate, fixed delay, or cron expression).","title":"4. Scheduled Task Execution:"},{"location":"spring/Scheduling/#5-customizing-task-execution","text":"The default behavior of scheduled tasks is to execute in a single-threaded manner. However, this can be customized by providing a ThreadPoolTaskScheduler to control the number of threads used to execute scheduled tasks.","title":"5. Customizing Task Execution:"},{"location":"spring/Scheduling/#6-task-scheduler","text":"Spring Boot uses a TaskScheduler to handle the execution of scheduled tasks. By default, it uses a SimpleAsyncTaskExecutor , but a custom ThreadPoolTaskScheduler can be configured for more control, such as setting the number of threads or customizing task behavior.","title":"6. Task Scheduler:"},{"location":"spring/Scheduling/#7-profiles-and-scheduling","text":"Scheduling tasks can be environment-specific, meaning you may want certain tasks to run only in specific environments (e.g., production but not development). Spring Boot supports defining scheduled tasks within specific profiles.","title":"7. Profiles and Scheduling:"},{"location":"spring/Scheduling/#8-error-handling","text":"Scheduled tasks should be designed to handle failures. If a task fails, Spring doesn't automatically retry it. You should handle errors gracefully and ensure tasks don't break other processes.","title":"8. Error Handling:"},{"location":"spring/Scheduling/#use-cases","text":"Data Cleanup : Periodically deleting old records from a database to maintain performance and data consistency. Email Notifications : Sending periodic reminders, newsletters, or promotional emails. Report Generation : Generating daily or weekly reports at specific times (e.g., midnight every day). System Monitoring : Running health checks or monitoring system status at regular intervals. Backup Jobs : Automating backups at specific times (e.g., every Sunday at 3:00 AM).","title":"Use Cases"},{"location":"spring/Scheduling/#summary","text":"A scheduler in Spring Boot allows tasks to be executed automatically at specific intervals or times using the @Scheduled annotation. It can be configured with fixed rate, fixed delay, or cron expressions, and is essential for automating background processes like data cleanup, report generation, and system monitoring.","title":"Summary"},{"location":"spring/Spring%20Boot/","text":"Spring Boot 1. Auto-Configuration: Automatically configures the application based on the libraries in the classpath. 2. Standalone Applications: No need for an external application server; Spring Boot applications can run as standalone JARs with an embedded server like Tomcat, Jetty, or Undertow. 3. Production-Ready Features: Built-in metrics, health checks, and externalized configuration make it easier to deploy and monitor applications in production. 4. Spring Boot Starters: Pre-configured dependencies for various functionalities, e.g., spring-boot-starter-web , spring-boot-starter-data-jpa , etc. 5. Externalized Configuration: Use .properties or .yaml files for application settings, allowing easy configuration management across environments. 6. Embedded Server: Built-in support for embedded servers like Tomcat and Jetty. 7. DevTools: Offers hot-swapping, automatic restart, and live reload during development. 8. Spring Initializr: A web-based tool to bootstrap new Spring Boot projects with dependencies and configurations.","title":"Spring Boot"},{"location":"spring/Spring%20Boot/#spring-boot","text":"","title":"Spring Boot"},{"location":"spring/Spring%20Boot/#1-auto-configuration","text":"Automatically configures the application based on the libraries in the classpath.","title":"1. Auto-Configuration:"},{"location":"spring/Spring%20Boot/#2-standalone-applications","text":"No need for an external application server; Spring Boot applications can run as standalone JARs with an embedded server like Tomcat, Jetty, or Undertow.","title":"2. Standalone Applications:"},{"location":"spring/Spring%20Boot/#3-production-ready-features","text":"Built-in metrics, health checks, and externalized configuration make it easier to deploy and monitor applications in production.","title":"3. Production-Ready Features:"},{"location":"spring/Spring%20Boot/#4-spring-boot-starters","text":"Pre-configured dependencies for various functionalities, e.g., spring-boot-starter-web , spring-boot-starter-data-jpa , etc.","title":"4. Spring Boot Starters:"},{"location":"spring/Spring%20Boot/#5-externalized-configuration","text":"Use .properties or .yaml files for application settings, allowing easy configuration management across environments.","title":"5. Externalized Configuration:"},{"location":"spring/Spring%20Boot/#6-embedded-server","text":"Built-in support for embedded servers like Tomcat and Jetty.","title":"6. Embedded Server:"},{"location":"spring/Spring%20Boot/#7-devtools","text":"Offers hot-swapping, automatic restart, and live reload during development.","title":"7. DevTools:"},{"location":"spring/Spring%20Boot/#8-spring-initializr","text":"A web-based tool to bootstrap new Spring Boot projects with dependencies and configurations.","title":"8. Spring Initializr:"},{"location":"spring/Spring%20Container/","text":"Spring Container Spring Container is a core concept responsible for managing the lifecycle, configuration, and dependency injection of the beans in a Spring application. It is the backbone of the Spring Framework, enabling the implementation of the Inversion of Control (IoC) principle. Key Components of the Spring Container BeanFactory The simplest and most basic container in Spring. Provides basic support for Dependency Injection . Does not support advanced features like event propagation, AOP, or annotation-based configuration. Usage : org.springframework.beans.factory.BeanFactory . ApplicationContext A more advanced container than BeanFactory . Extends BeanFactory to provide additional features like event propagation, declarative mechanisms, and internationalization. Common Implementations: ClassPathXmlApplicationContext : Loads context definition from an XML file in the classpath. FileSystemXmlApplicationContext : Loads context definition from an XML file in the file system. AnnotationConfigApplicationContext : Loads context definition using Java-based configuration classes. Usage : org.springframework.context.ApplicationContext . Responsibilities of the Spring Container Bean Creation Instantiates beans as defined in the configuration file (XML, Java, or annotations). Dependency Injection Resolves and injects dependencies specified in the bean definitions. Bean Lifecycle Management Manages the lifecycle of beans from initialization to destruction. Configuration Reads metadata from configuration files or annotations to determine how to configure and manage beans. Advanced Features (only in ApplicationContext ) : Event handling : Via ApplicationEvent and ApplicationListener . MessageSource : Supports internationalization (i18n). Spring AOP : Supports aspect-oriented programming and declarative transaction management.","title":"Spring Container"},{"location":"spring/Spring%20Container/#spring-container","text":"Spring Container is a core concept responsible for managing the lifecycle, configuration, and dependency injection of the beans in a Spring application. It is the backbone of the Spring Framework, enabling the implementation of the Inversion of Control (IoC) principle.","title":"Spring Container"},{"location":"spring/Spring%20Container/#key-components-of-the-spring-container","text":"","title":"Key Components of the Spring Container"},{"location":"spring/Spring%20Container/#beanfactory","text":"The simplest and most basic container in Spring. Provides basic support for Dependency Injection . Does not support advanced features like event propagation, AOP, or annotation-based configuration. Usage : org.springframework.beans.factory.BeanFactory .","title":"BeanFactory"},{"location":"spring/Spring%20Container/#applicationcontext","text":"A more advanced container than BeanFactory . Extends BeanFactory to provide additional features like event propagation, declarative mechanisms, and internationalization.","title":"ApplicationContext"},{"location":"spring/Spring%20Container/#common-implementations","text":"ClassPathXmlApplicationContext : Loads context definition from an XML file in the classpath. FileSystemXmlApplicationContext : Loads context definition from an XML file in the file system. AnnotationConfigApplicationContext : Loads context definition using Java-based configuration classes. Usage : org.springframework.context.ApplicationContext .","title":"Common Implementations:"},{"location":"spring/Spring%20Container/#responsibilities-of-the-spring-container","text":"","title":"Responsibilities of the Spring Container"},{"location":"spring/Spring%20Container/#bean-creation","text":"Instantiates beans as defined in the configuration file (XML, Java, or annotations).","title":"Bean Creation"},{"location":"spring/Spring%20Container/#dependency-injection","text":"Resolves and injects dependencies specified in the bean definitions.","title":"Dependency Injection"},{"location":"spring/Spring%20Container/#bean-lifecycle-management","text":"Manages the lifecycle of beans from initialization to destruction.","title":"Bean Lifecycle Management"},{"location":"spring/Spring%20Container/#configuration","text":"Reads metadata from configuration files or annotations to determine how to configure and manage beans.","title":"Configuration"},{"location":"spring/Spring%20Container/#advanced-features-only-in-applicationcontext","text":"Event handling : Via ApplicationEvent and ApplicationListener . MessageSource : Supports internationalization (i18n). Spring AOP : Supports aspect-oriented programming and declarative transaction management.","title":"Advanced Features (only in ApplicationContext):"},{"location":"spring/Spring%20Profiles/","text":"Spring Boot Profiles Spring Boot profiles allow you to configure settings for different environments (e.g., development, testing, production) without changing the code. Profiles can have specific configuration properties, beans, or components active only in that profile. 1. Defining Profiles in application.properties or application.yml You can define profile-specific properties in the application.properties or application.yml file. Below is an example of configurations for dev , test , and prod profiles: Default Configuration ( application.properties ) # Default configuration spring.datasource.url=jdbc:mysql://localhost:3306/mydb spring.datasource.username=root spring.datasource.password=root Development Profile (application-dev.properties) # dev-specific configuration spring.datasource.url=jdbc:mysql://localhost:3306/devdb spring.datasource.username=devuser spring.datasource.password=devpassword Production Profile (application-prod.properties) # prod-specific configuration spring.datasource.url=jdbc:mysql://prod-db-host:3306/proddb spring.datasource.username=produser spring.datasource.password=prodpassword 2. Activating Profiles You can activate a profile using the following methods: a. Using spring.profiles.active in application.properties spring.profiles.active=dev b. Using Command Line Parameters java -jar myapp.jar --spring.profiles.active=dev c. Using Environment Variables export SPRING_PROFILES_ACTIVE=dev","title":"Spring Profiles"},{"location":"spring/Spring%20Profiles/#spring-boot-profiles","text":"Spring Boot profiles allow you to configure settings for different environments (e.g., development, testing, production) without changing the code. Profiles can have specific configuration properties, beans, or components active only in that profile.","title":"Spring Boot Profiles"},{"location":"spring/Spring%20Profiles/#1-defining-profiles-in-applicationproperties-or-applicationyml","text":"You can define profile-specific properties in the application.properties or application.yml file. Below is an example of configurations for dev , test , and prod profiles:","title":"1. Defining Profiles in application.properties or application.yml"},{"location":"spring/Spring%20Profiles/#default-configuration-applicationproperties","text":"# Default configuration spring.datasource.url=jdbc:mysql://localhost:3306/mydb spring.datasource.username=root spring.datasource.password=root","title":"Default Configuration (application.properties)"},{"location":"spring/Spring%20Profiles/#development-profile-application-devproperties","text":"# dev-specific configuration spring.datasource.url=jdbc:mysql://localhost:3306/devdb spring.datasource.username=devuser spring.datasource.password=devpassword","title":"Development Profile (application-dev.properties)"},{"location":"spring/Spring%20Profiles/#production-profile-application-prodproperties","text":"# prod-specific configuration spring.datasource.url=jdbc:mysql://prod-db-host:3306/proddb spring.datasource.username=produser spring.datasource.password=prodpassword","title":"Production Profile (application-prod.properties)"},{"location":"spring/Spring%20Profiles/#2-activating-profiles","text":"You can activate a profile using the following methods:","title":"2. Activating Profiles"},{"location":"spring/Spring%20Profiles/#a-using-springprofilesactive-in-applicationproperties","text":"spring.profiles.active=dev","title":"a. Using spring.profiles.active in application.properties"},{"location":"spring/Spring%20Profiles/#b-using-command-line-parameters","text":"java -jar myapp.jar --spring.profiles.active=dev","title":"b. Using Command Line Parameters"},{"location":"spring/Spring%20Profiles/#c-using-environment-variables","text":"export SPRING_PROFILES_ACTIVE=dev","title":"c. Using Environment Variables"},{"location":"spring/Spring%20Security/","text":"Implementing a Resource Server with Keycloak in Spring Boot 1. Keycloak Setup Realm : A realm is a boundary for managing authentication and authorization in Keycloak. It contains clients, users, roles, and other security-related configurations. Client : A client represents an application that interacts with Keycloak. When configuring a Spring Boot application, the client must be set up to authenticate using OAuth2 with Keycloak. Roles : Keycloak uses roles to control access to resources. Roles are assigned to users and define their permissions. In the resource server, you use these roles to enforce access control on specific endpoints. 2. Spring Boot Security Configuration OAuth2 Resource Server : In the context of Spring Boot, a resource server is an application that serves resources (like APIs or data) and enforces authorization by validating access tokens. In this case, the resource server validates JWT (JSON Web Tokens) issued by Keycloak. JWT Authentication : JWT tokens are used for secure authentication between the client (e.g., frontend or mobile app) and the resource server. The resource server needs to verify the authenticity of the JWT to grant or deny access to protected resources. Role-based Access Control (RBAC) : The resource server uses roles assigned in Keycloak to control access to various resources. A user with a specific role can be granted or denied access to certain endpoints of the resource server. 3. JWT Token Validation When a client requests a resource from the resource server, it includes a JWT token in the Authorization header. The resource server validates this token to ensure its authenticity by checking its signature, issuer, and audience. The JWT is typically signed by Keycloak using a private key. The resource server uses a public key or a JWK (JSON Web Key) set to validate the token. 4. Spring Security Integration Spring Security integrates with OAuth2 and JWT to automatically handle the security aspects of the resource server. The SecurityWebFilterChain is configured to authorize HTTP requests based on the roles defined in Keycloak. For example, only users with specific roles (e.g., ACCOUNTS, CARDS, LOANS) can access certain endpoints. The JwtAuthenticationConverter in Spring Security extracts the roles from the JWT token and maps them to Spring Security authorities, allowing the application to apply role-based access control (RBAC). 5. Keycloak Role Conversion Keycloak uses its own role system to define permissions, and these roles need to be mapped to Spring Security roles to enforce access control. This conversion can be done via a custom converter that extracts roles from the JWT token and assigns them to the security context. 6. Security Flow The client first authenticates with Keycloak, obtains a JWT token, and then includes the token in subsequent API requests to the resource server. The resource server validates the JWT token using the configured public key or JWK endpoint from Keycloak. If the token is valid, the resource server checks the user's roles to determine if they have permission to access the requested resource. Access control is enforced based on the roles defined in both Keycloak and the application. 7. Disabling CSRF Protection In the context of a stateless resource server using JWT authentication, CSRF protection is typically disabled since the server is not maintaining session state, and the token in the header is sufficient for authentication and authorization. 8. Advantages of Using Keycloak with Spring Boot Centralized Identity Management : Keycloak provides a centralized service for handling authentication and authorization, which reduces the complexity of implementing security in each individual service. Scalability and Flexibility : Keycloak supports OAuth2 and OpenID Connect, which are industry-standard protocols for handling authentication and authorization, making it easy to scale your authentication system across multiple services. Role-based Access Control : Keycloak simplifies the management of user roles and permissions, and Spring Security integrates seamlessly to enforce access policies. 9. Token Expiry and Refresh JWT tokens have an expiry time, and after the token expires, the client needs to re-authenticate or use a refresh token (if configured in Keycloak) to obtain a new JWT token.","title":"Spring Security"},{"location":"spring/Spring%20Security/#implementing-a-resource-server-with-keycloak-in-spring-boot","text":"","title":"Implementing a Resource Server with Keycloak in Spring Boot"},{"location":"spring/Spring%20Security/#1-keycloak-setup","text":"Realm : A realm is a boundary for managing authentication and authorization in Keycloak. It contains clients, users, roles, and other security-related configurations. Client : A client represents an application that interacts with Keycloak. When configuring a Spring Boot application, the client must be set up to authenticate using OAuth2 with Keycloak. Roles : Keycloak uses roles to control access to resources. Roles are assigned to users and define their permissions. In the resource server, you use these roles to enforce access control on specific endpoints.","title":"1. Keycloak Setup"},{"location":"spring/Spring%20Security/#2-spring-boot-security-configuration","text":"OAuth2 Resource Server : In the context of Spring Boot, a resource server is an application that serves resources (like APIs or data) and enforces authorization by validating access tokens. In this case, the resource server validates JWT (JSON Web Tokens) issued by Keycloak. JWT Authentication : JWT tokens are used for secure authentication between the client (e.g., frontend or mobile app) and the resource server. The resource server needs to verify the authenticity of the JWT to grant or deny access to protected resources. Role-based Access Control (RBAC) : The resource server uses roles assigned in Keycloak to control access to various resources. A user with a specific role can be granted or denied access to certain endpoints of the resource server.","title":"2. Spring Boot Security Configuration"},{"location":"spring/Spring%20Security/#3-jwt-token-validation","text":"When a client requests a resource from the resource server, it includes a JWT token in the Authorization header. The resource server validates this token to ensure its authenticity by checking its signature, issuer, and audience. The JWT is typically signed by Keycloak using a private key. The resource server uses a public key or a JWK (JSON Web Key) set to validate the token.","title":"3. JWT Token Validation"},{"location":"spring/Spring%20Security/#4-spring-security-integration","text":"Spring Security integrates with OAuth2 and JWT to automatically handle the security aspects of the resource server. The SecurityWebFilterChain is configured to authorize HTTP requests based on the roles defined in Keycloak. For example, only users with specific roles (e.g., ACCOUNTS, CARDS, LOANS) can access certain endpoints. The JwtAuthenticationConverter in Spring Security extracts the roles from the JWT token and maps them to Spring Security authorities, allowing the application to apply role-based access control (RBAC).","title":"4. Spring Security Integration"},{"location":"spring/Spring%20Security/#5-keycloak-role-conversion","text":"Keycloak uses its own role system to define permissions, and these roles need to be mapped to Spring Security roles to enforce access control. This conversion can be done via a custom converter that extracts roles from the JWT token and assigns them to the security context.","title":"5. Keycloak Role Conversion"},{"location":"spring/Spring%20Security/#6-security-flow","text":"The client first authenticates with Keycloak, obtains a JWT token, and then includes the token in subsequent API requests to the resource server. The resource server validates the JWT token using the configured public key or JWK endpoint from Keycloak. If the token is valid, the resource server checks the user's roles to determine if they have permission to access the requested resource. Access control is enforced based on the roles defined in both Keycloak and the application.","title":"6. Security Flow"},{"location":"spring/Spring%20Security/#7-disabling-csrf-protection","text":"In the context of a stateless resource server using JWT authentication, CSRF protection is typically disabled since the server is not maintaining session state, and the token in the header is sufficient for authentication and authorization.","title":"7. Disabling CSRF Protection"},{"location":"spring/Spring%20Security/#8-advantages-of-using-keycloak-with-spring-boot","text":"Centralized Identity Management : Keycloak provides a centralized service for handling authentication and authorization, which reduces the complexity of implementing security in each individual service. Scalability and Flexibility : Keycloak supports OAuth2 and OpenID Connect, which are industry-standard protocols for handling authentication and authorization, making it easy to scale your authentication system across multiple services. Role-based Access Control : Keycloak simplifies the management of user roles and permissions, and Spring Security integrates seamlessly to enforce access policies.","title":"8. Advantages of Using Keycloak with Spring Boot"},{"location":"spring/Spring%20Security/#9-token-expiry-and-refresh","text":"JWT tokens have an expiry time, and after the token expires, the client needs to re-authenticate or use a refresh token (if configured in Keycloak) to obtain a new JWT token.","title":"9. Token Expiry and Refresh"},{"location":"spring/Spring%20boot%20annotations/","text":"@SpringBootApplication Marks the main class of a Spring Boot application. Combines @Configuration , @EnableAutoConfiguration , and @ComponentScan . @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } @Component Marks a class as a Spring component, enabling it to be managed by Spring's container. @Component public class MyComponent { // component logic } @Configuration Indicates that the class contains Spring bean definitions and that it can be processed by the Spring container to create and manage beans. @Configuration public class AppConfig { @Bean public SomeBean someBean() { return new SomeBean(); } } @Bean Defines a bean to be managed by the Spring container. @Bean public SomeService someService() { return new SomeService(); } @Lazy Indicates that a bean should be lazily initialized. @Lazy @Bean public SomeBean someBean() { return new SomeBean(); } @Autowired Injects a bean into the class. @Autowired private UserService userService; @Value It is used to inject values into fields, methods, or constructor parameters from property file. import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; @Component public class MyComponent { @Value(\"${app.name}\") private String appName; @Value(\"${app.version}\") private String appVersion; @Value(\"#{2 * T(Math).PI}\") private double circleConstant; public void printAppDetails() { System.out.println(\"App Name: \" + appName); System.out.println(\"App Version: \" + appVersion); System.out.println(\"Circle Constant: \" + circleConstant); } } application.properties: app.name=MySpringApp app.version=1.0 @Primary Indicates that a bean should be the default bean to autowire when multiple candidates exist. @Primary @Bean public SomeService defaultService() { return new DefaultService(); } @EnableConfigurationProperties Enables support for @ConfigurationProperties beans. @EnableConfigurationProperties(SomeProperties.class) @Configuration public class Config { // configuration } @SpringBootTest Indicates that the class should run as a Spring Boot test. @SpringBootTest public class ApplicationTests { @Test public void contextLoads() { } } @RestController Combines @Controller and @ResponseBody, used for RESTful APIs. @RestController public class UserController { @GetMapping(\"/users\") public List<User> getUsers() { return userService.getUsers(); } } @Controller Indicates that a class is a Spring MVC controller. @Controller public class WebController { @RequestMapping(\"/home\") public String home() { return \"home\"; } } @RequestMapping Maps HTTP requests to handler methods of MVC and REST controllers. @RequestMapping(\"/users\") public String getUsers() { return \"users\"; } @GetMapping Maps HTTP GET requests to handler methods. @GetMapping(\"/users\") public List<User> getUsers() { return userService.getUsers(); } @PostMapping Maps HTTP POST requests to handler methods. @PostMapping(\"/users\") public User createUser(@RequestBody User user) { return userService.createUser(user); } @PutMapping Maps HTTP PUT requests to handler methods. @PutMapping(\"/users/{id}\") public User updateUser(@PathVariable Long id, @RequestBody User user) { return userService.updateUser(id, user); } @DeleteMapping Maps HTTP DELETE requests to handler methods. @DeleteMapping(\"/users/{id}\") public void deleteUser(@PathVariable Long id) { userService.deleteUser(id); } @PatchMapping Maps HTTP PATCH requests to handler methods. @PatchMapping(\"/users/{id}\") public User partialUpdateUser(@PathVariable Long id, @RequestBody User user) { return userService.partialUpdateUser(id, user); } @ResponseBody Indicates that the return value of a method should be bound to the web response body. @ResponseBody public String getMessage() { return \"Hello, World!\"; } @PathVariable Binds a method parameter to a URI template variable. @GetMapping(\"/users/{id}\") public User getUser(@PathVariable Long id) { return userService.getUser(id); } @RequestParam Binds request parameters to method parameters. @GetMapping(\"/users\") public List<User> getUsers(@RequestParam int page) { return userService.getUsers(page); } @RequestBody Binds the request body to a method parameter. @PostMapping(\"/users\") public User createUser(@RequestBody User user) { return userService.createUser(user); } @ResponseStatus Sets the status code for a method or exception. @ResponseStatus(HttpStatus.NOT_FOUND) public class UserNotFoundException extends RuntimeException { // exception details } @CrossOrigin Enables Cross-Origin Resource Sharing (CORS) support. @CrossOrigin(origins = \"http://example.com\") public class MyController { // controller methods } @Service Marks a class as a service, a specialization of @Component. @Service public class UserService { // service logic } @Repository Marks a class as a repository, a specialization of @Component. @Repository public class UserRepository { // repository logic } @Validated It is a used to trigger validation for Spring beans, such as method parameters or class fields, to ensure they meet specified constraints. @Validated public class UserController { @PostMapping(\"/addUser\") public ResponseEntity<String> addUser(@Valid @RequestBody User user) { // User object will be validated based on annotations like @NotNull, @Size, etc. return ResponseEntity.ok(\"User added successfully\"); } } @Valid Validates the annotated field or method parameter. public void createUser(@Valid User user) { // validation logic } @NotNull Ensures the annotated element is not null. @NotNull private String name; @NotEmpty Ensures the annotated element is not empty. @NotEmpty private List<String> tags; @NotBlank Ensures the annotated element is not blank (not null or not empty). @NotBlank private String username; @Size Specifies the size constraints for the annotated field or method parameter. @Size(min = 2, max = 10) private String name; @Min / @Max Specifies the minimum/maximum value for numeric fields. @Min(18) private int age; @Pattern Specifies a regular expression that the annotated field must match. @Pattern(regexp = \"[A-Za-z0-9]+\") private String code; @ControllerAdvice It is used to handle exceptions globally and provide centralized exception handling across all controllers public class GlobalExceptionHandler extends ResponseEntityExceptionHandler { @Override protected ResponseEntity<Object> handleMethodArgumentNotValid(MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) { Map<String, String> validationErrors = new HashMap<>(); List<ObjectError> validationErrorList = ex.getBindingResult().getAllErrors(); validationErrorList.forEach((error) -> { String fieldName = ((FieldError) error).getField(); String validationMsg = error.getDefaultMessage(); validationErrors.put(fieldName, validationMsg); }); return super.handleMethodArgumentNotValid(ex, headers, status, request); } } @ExceptionHandler Handles exceptions thrown by methods in the controller. @ExceptionHandler(Exception.class) public String handleException(Exception e) { return \"Error: \" + e.getMessage(); } @Transactional Specifies that a method or class should be executed within a transaction context. @Transactional public void processOrder(Order order) { orderRepository.save(order); inventoryService.updateStock(order); } @Modifying Indicates that a query method is modifying the data (insert, update, delete). @Modifying @Query(\"UPDATE User u SET u.name = :name WHERE u.id = :id\") public int updateUserName(@Param(\"id\") Long id, @Param(\"name\") String name); @Query Defines custom queries for Spring Data repositories. It can be used to define complex JPQL or native SQL queries. @Query(\"SELECT u FROM User u WHERE u.name = :name\") public User findByName(@Param(\"name\") String name); @EnableMethodSecurity Enables method-level security in a Spring application, allowing annotations like @PreAuthorize, @Secured, and @RolesAllowed. @EnableMethodSecurity @Configuration public class SecurityConfig { // security configuration }","title":"Spring boot annotations"},{"location":"spring/Spring%20boot%20annotations/#springbootapplication","text":"Marks the main class of a Spring Boot application. Combines @Configuration , @EnableAutoConfiguration , and @ComponentScan . @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } }","title":"@SpringBootApplication"},{"location":"spring/Spring%20boot%20annotations/#component","text":"Marks a class as a Spring component, enabling it to be managed by Spring's container. @Component public class MyComponent { // component logic }","title":"@Component"},{"location":"spring/Spring%20boot%20annotations/#configuration","text":"Indicates that the class contains Spring bean definitions and that it can be processed by the Spring container to create and manage beans. @Configuration public class AppConfig { @Bean public SomeBean someBean() { return new SomeBean(); } }","title":"@Configuration"},{"location":"spring/Spring%20boot%20annotations/#bean","text":"Defines a bean to be managed by the Spring container. @Bean public SomeService someService() { return new SomeService(); }","title":"@Bean"},{"location":"spring/Spring%20boot%20annotations/#lazy","text":"Indicates that a bean should be lazily initialized. @Lazy @Bean public SomeBean someBean() { return new SomeBean(); }","title":"@Lazy"},{"location":"spring/Spring%20boot%20annotations/#autowired","text":"Injects a bean into the class. @Autowired private UserService userService;","title":"@Autowired"},{"location":"spring/Spring%20boot%20annotations/#value","text":"It is used to inject values into fields, methods, or constructor parameters from property file. import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; @Component public class MyComponent { @Value(\"${app.name}\") private String appName; @Value(\"${app.version}\") private String appVersion; @Value(\"#{2 * T(Math).PI}\") private double circleConstant; public void printAppDetails() { System.out.println(\"App Name: \" + appName); System.out.println(\"App Version: \" + appVersion); System.out.println(\"Circle Constant: \" + circleConstant); } }","title":"@Value"},{"location":"spring/Spring%20boot%20annotations/#applicationproperties","text":"app.name=MySpringApp app.version=1.0","title":"application.properties:"},{"location":"spring/Spring%20boot%20annotations/#primary","text":"Indicates that a bean should be the default bean to autowire when multiple candidates exist. @Primary @Bean public SomeService defaultService() { return new DefaultService(); }","title":"@Primary"},{"location":"spring/Spring%20boot%20annotations/#enableconfigurationproperties","text":"Enables support for @ConfigurationProperties beans. @EnableConfigurationProperties(SomeProperties.class) @Configuration public class Config { // configuration }","title":"@EnableConfigurationProperties"},{"location":"spring/Spring%20boot%20annotations/#springboottest","text":"Indicates that the class should run as a Spring Boot test. @SpringBootTest public class ApplicationTests { @Test public void contextLoads() { } }","title":"@SpringBootTest"},{"location":"spring/Spring%20boot%20annotations/#restcontroller","text":"Combines @Controller and @ResponseBody, used for RESTful APIs. @RestController public class UserController { @GetMapping(\"/users\") public List<User> getUsers() { return userService.getUsers(); } }","title":"@RestController"},{"location":"spring/Spring%20boot%20annotations/#controller","text":"Indicates that a class is a Spring MVC controller. @Controller public class WebController { @RequestMapping(\"/home\") public String home() { return \"home\"; } }","title":"@Controller"},{"location":"spring/Spring%20boot%20annotations/#requestmapping","text":"Maps HTTP requests to handler methods of MVC and REST controllers. @RequestMapping(\"/users\") public String getUsers() { return \"users\"; }","title":"@RequestMapping"},{"location":"spring/Spring%20boot%20annotations/#getmapping","text":"Maps HTTP GET requests to handler methods. @GetMapping(\"/users\") public List<User> getUsers() { return userService.getUsers(); }","title":"@GetMapping"},{"location":"spring/Spring%20boot%20annotations/#postmapping","text":"Maps HTTP POST requests to handler methods. @PostMapping(\"/users\") public User createUser(@RequestBody User user) { return userService.createUser(user); }","title":"@PostMapping"},{"location":"spring/Spring%20boot%20annotations/#putmapping","text":"Maps HTTP PUT requests to handler methods. @PutMapping(\"/users/{id}\") public User updateUser(@PathVariable Long id, @RequestBody User user) { return userService.updateUser(id, user); }","title":"@PutMapping"},{"location":"spring/Spring%20boot%20annotations/#deletemapping","text":"Maps HTTP DELETE requests to handler methods. @DeleteMapping(\"/users/{id}\") public void deleteUser(@PathVariable Long id) { userService.deleteUser(id); }","title":"@DeleteMapping"},{"location":"spring/Spring%20boot%20annotations/#patchmapping","text":"Maps HTTP PATCH requests to handler methods. @PatchMapping(\"/users/{id}\") public User partialUpdateUser(@PathVariable Long id, @RequestBody User user) { return userService.partialUpdateUser(id, user); }","title":"@PatchMapping"},{"location":"spring/Spring%20boot%20annotations/#responsebody","text":"Indicates that the return value of a method should be bound to the web response body. @ResponseBody public String getMessage() { return \"Hello, World!\"; }","title":"@ResponseBody"},{"location":"spring/Spring%20boot%20annotations/#pathvariable","text":"Binds a method parameter to a URI template variable. @GetMapping(\"/users/{id}\") public User getUser(@PathVariable Long id) { return userService.getUser(id); }","title":"@PathVariable"},{"location":"spring/Spring%20boot%20annotations/#requestparam","text":"Binds request parameters to method parameters. @GetMapping(\"/users\") public List<User> getUsers(@RequestParam int page) { return userService.getUsers(page); }","title":"@RequestParam"},{"location":"spring/Spring%20boot%20annotations/#requestbody","text":"Binds the request body to a method parameter. @PostMapping(\"/users\") public User createUser(@RequestBody User user) { return userService.createUser(user); }","title":"@RequestBody"},{"location":"spring/Spring%20boot%20annotations/#responsestatus","text":"Sets the status code for a method or exception. @ResponseStatus(HttpStatus.NOT_FOUND) public class UserNotFoundException extends RuntimeException { // exception details }","title":"@ResponseStatus"},{"location":"spring/Spring%20boot%20annotations/#crossorigin","text":"Enables Cross-Origin Resource Sharing (CORS) support. @CrossOrigin(origins = \"http://example.com\") public class MyController { // controller methods }","title":"@CrossOrigin"},{"location":"spring/Spring%20boot%20annotations/#service","text":"Marks a class as a service, a specialization of @Component. @Service public class UserService { // service logic }","title":"@Service"},{"location":"spring/Spring%20boot%20annotations/#repository","text":"Marks a class as a repository, a specialization of @Component. @Repository public class UserRepository { // repository logic }","title":"@Repository"},{"location":"spring/Spring%20boot%20annotations/#validated","text":"It is a used to trigger validation for Spring beans, such as method parameters or class fields, to ensure they meet specified constraints. @Validated public class UserController { @PostMapping(\"/addUser\") public ResponseEntity<String> addUser(@Valid @RequestBody User user) { // User object will be validated based on annotations like @NotNull, @Size, etc. return ResponseEntity.ok(\"User added successfully\"); } }","title":"@Validated"},{"location":"spring/Spring%20boot%20annotations/#valid","text":"Validates the annotated field or method parameter. public void createUser(@Valid User user) { // validation logic }","title":"@Valid"},{"location":"spring/Spring%20boot%20annotations/#notnull","text":"Ensures the annotated element is not null. @NotNull private String name;","title":"@NotNull"},{"location":"spring/Spring%20boot%20annotations/#notempty","text":"Ensures the annotated element is not empty. @NotEmpty private List<String> tags;","title":"@NotEmpty"},{"location":"spring/Spring%20boot%20annotations/#notblank","text":"Ensures the annotated element is not blank (not null or not empty). @NotBlank private String username;","title":"@NotBlank"},{"location":"spring/Spring%20boot%20annotations/#size","text":"Specifies the size constraints for the annotated field or method parameter. @Size(min = 2, max = 10) private String name;","title":"@Size"},{"location":"spring/Spring%20boot%20annotations/#min-max","text":"Specifies the minimum/maximum value for numeric fields. @Min(18) private int age;","title":"@Min / @Max"},{"location":"spring/Spring%20boot%20annotations/#pattern","text":"Specifies a regular expression that the annotated field must match. @Pattern(regexp = \"[A-Za-z0-9]+\") private String code;","title":"@Pattern"},{"location":"spring/Spring%20boot%20annotations/#controlleradvice","text":"It is used to handle exceptions globally and provide centralized exception handling across all controllers public class GlobalExceptionHandler extends ResponseEntityExceptionHandler { @Override protected ResponseEntity<Object> handleMethodArgumentNotValid(MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) { Map<String, String> validationErrors = new HashMap<>(); List<ObjectError> validationErrorList = ex.getBindingResult().getAllErrors(); validationErrorList.forEach((error) -> { String fieldName = ((FieldError) error).getField(); String validationMsg = error.getDefaultMessage(); validationErrors.put(fieldName, validationMsg); }); return super.handleMethodArgumentNotValid(ex, headers, status, request); } }","title":"@ControllerAdvice"},{"location":"spring/Spring%20boot%20annotations/#exceptionhandler","text":"Handles exceptions thrown by methods in the controller. @ExceptionHandler(Exception.class) public String handleException(Exception e) { return \"Error: \" + e.getMessage(); }","title":"@ExceptionHandler"},{"location":"spring/Spring%20boot%20annotations/#transactional","text":"Specifies that a method or class should be executed within a transaction context. @Transactional public void processOrder(Order order) { orderRepository.save(order); inventoryService.updateStock(order); }","title":"@Transactional"},{"location":"spring/Spring%20boot%20annotations/#modifying","text":"Indicates that a query method is modifying the data (insert, update, delete). @Modifying @Query(\"UPDATE User u SET u.name = :name WHERE u.id = :id\") public int updateUserName(@Param(\"id\") Long id, @Param(\"name\") String name);","title":"@Modifying"},{"location":"spring/Spring%20boot%20annotations/#query","text":"Defines custom queries for Spring Data repositories. It can be used to define complex JPQL or native SQL queries. @Query(\"SELECT u FROM User u WHERE u.name = :name\") public User findByName(@Param(\"name\") String name);","title":"@Query"},{"location":"spring/Spring%20boot%20annotations/#enablemethodsecurity","text":"Enables method-level security in a Spring application, allowing annotations like @PreAuthorize, @Secured, and @RolesAllowed. @EnableMethodSecurity @Configuration public class SecurityConfig { // security configuration }","title":"@EnableMethodSecurity"},{"location":"spring/WebClient/","text":"WebClient WebClient is a non-blocking, reactive web client provided by Spring WebFlux, which is part of the Spring Framework. It is designed to perform HTTP requests and consume RESTful web services asynchronously. WebClient is a better alternative to RestTemplate when dealing with reactive applications. Here\u2019s an example of how to use WebClient in a Spring Boot application: 1. Add dependency in pom.xml You need to add the Spring WebFlux dependency if it's not already in your project: <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-webflux</artifactId> </dependency> 2. Configure WebClient Bean You can define a WebClient bean in your configuration class: import org.springframework.boot.web.client.RestTemplateBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.reactive.function.client.WebClient; @Configuration public class WebClientConfig { @Bean public WebClient.Builder webClientBuilder() { return WebClient.builder(); } } 3. Using WebClient to make a request Here\u2019s how you can use WebClient to make an HTTP GET request: import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.web.reactive.function.client.WebClient; import reactor.core.publisher.Mono; @Service public class WebClientService { @Autowired private WebClient.Builder webClientBuilder; public Mono<String> fetchData(String url) { return webClientBuilder.baseUrl(url) .build() .get() .retrieve() .bodyToMono(String.class); } } 4. Example Controller You can inject the WebClientService into your controller to use it: import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import reactor.core.publisher.Mono; @RestController public class WebClientController { @Autowired private WebClientService webClientService; @GetMapping(\"/fetch-data\") public Mono<String> fetchData() { return webClientService.fetchData(\"https://api.example.com/data\"); } } 5. Handling Error Responses WebClient has powerful error handling capabilities. You can customize error handling by using onStatus(): public Mono<String> fetchDataWithErrorHandling(String url) { return webClientBuilder.baseUrl(url) .build() .get() .retrieve() .onStatus(status -> status.is4xxClientError(), response -> Mono.error(new RuntimeException(\"Client error\"))) .onStatus(status -> status.is5xxServerError(), response -> Mono.error(new RuntimeException(\"Server error\"))) .bodyToMono(String.class); } WebClient is highly useful for handling asynchronous, non-blocking HTTP requests, especially in reactive systems built using Spring WebFlux. Example of a Blocking WebClient Call import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.web.reactive.function.client.WebClient; @Service public class WebClientBlockingService { @Autowired private WebClient.Builder webClientBuilder; public String fetchDataBlocking(String url) { return webClientBuilder.baseUrl(url) .build() .get() .retrieve() .bodyToMono(String.class) .block(); // This makes it a blocking call } } Mono and Flux are two core classes in Project Reactor, the reactive library used in Spring WebFlux to represent asynchronous and non-blocking sequences of data. 1. Mono Mono represents a sequence that contains at most one item or is empty. It is similar to a Future or Optional, but it is reactive and can be used to represent a single value or a potential error. Use cases for Mono: - Returning a single value or no value (empty). - Performing operations that complete with one result. Example: import reactor.core.publisher.Mono; public class MonoExample { public static void main(String[] args) { Mono<String> mono = Mono.just(\"Hello, World!\"); // Subscribe to the Mono and print the value mono.subscribe(value -> System.out.println(value)); // Output: Hello, World! } } 2. Flux Flux represents a sequence of 0 to N items and can be thought of as a stream of data over time. It is used when you expect multiple values or an indefinite sequence, like reading multiple records from a database, consuming a stream of events, etc. Use cases for Flux: - Returning multiple items in a stream-like fashion. - Handling collections or lists asynchronously. Example: import reactor.core.publisher.Flux; public class FluxExample { public static void main(String[] args) { Flux<String> flux = Flux.just(\"Apple\", \"Banana\", \"Cherry\"); // Subscribe to the Flux and print each value flux.subscribe(value -> System.out.println(value)); // Output: // Apple // Banana // Cherry } }","title":"WebClient"},{"location":"spring/WebClient/#webclient","text":"WebClient is a non-blocking, reactive web client provided by Spring WebFlux, which is part of the Spring Framework. It is designed to perform HTTP requests and consume RESTful web services asynchronously. WebClient is a better alternative to RestTemplate when dealing with reactive applications. Here\u2019s an example of how to use WebClient in a Spring Boot application:","title":"WebClient"},{"location":"spring/WebClient/#1-add-dependency-in-pomxml","text":"You need to add the Spring WebFlux dependency if it's not already in your project: <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-webflux</artifactId> </dependency>","title":"1. Add dependency in pom.xml"},{"location":"spring/WebClient/#2-configure-webclient-bean","text":"You can define a WebClient bean in your configuration class: import org.springframework.boot.web.client.RestTemplateBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.reactive.function.client.WebClient; @Configuration public class WebClientConfig { @Bean public WebClient.Builder webClientBuilder() { return WebClient.builder(); } }","title":"2. Configure WebClient Bean"},{"location":"spring/WebClient/#3-using-webclient-to-make-a-request","text":"Here\u2019s how you can use WebClient to make an HTTP GET request: import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.web.reactive.function.client.WebClient; import reactor.core.publisher.Mono; @Service public class WebClientService { @Autowired private WebClient.Builder webClientBuilder; public Mono<String> fetchData(String url) { return webClientBuilder.baseUrl(url) .build() .get() .retrieve() .bodyToMono(String.class); } }","title":"3. Using WebClient to make a request"},{"location":"spring/WebClient/#4-example-controller","text":"You can inject the WebClientService into your controller to use it: import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import reactor.core.publisher.Mono; @RestController public class WebClientController { @Autowired private WebClientService webClientService; @GetMapping(\"/fetch-data\") public Mono<String> fetchData() { return webClientService.fetchData(\"https://api.example.com/data\"); } }","title":"4. Example Controller"},{"location":"spring/WebClient/#5-handling-error-responses","text":"WebClient has powerful error handling capabilities. You can customize error handling by using onStatus(): public Mono<String> fetchDataWithErrorHandling(String url) { return webClientBuilder.baseUrl(url) .build() .get() .retrieve() .onStatus(status -> status.is4xxClientError(), response -> Mono.error(new RuntimeException(\"Client error\"))) .onStatus(status -> status.is5xxServerError(), response -> Mono.error(new RuntimeException(\"Server error\"))) .bodyToMono(String.class); } WebClient is highly useful for handling asynchronous, non-blocking HTTP requests, especially in reactive systems built using Spring WebFlux. Example of a Blocking WebClient Call import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.web.reactive.function.client.WebClient; @Service public class WebClientBlockingService { @Autowired private WebClient.Builder webClientBuilder; public String fetchDataBlocking(String url) { return webClientBuilder.baseUrl(url) .build() .get() .retrieve() .bodyToMono(String.class) .block(); // This makes it a blocking call } } Mono and Flux are two core classes in Project Reactor, the reactive library used in Spring WebFlux to represent asynchronous and non-blocking sequences of data.","title":"5. Handling Error Responses"},{"location":"spring/WebClient/#1-mono","text":"Mono represents a sequence that contains at most one item or is empty. It is similar to a Future or Optional, but it is reactive and can be used to represent a single value or a potential error. Use cases for Mono: - Returning a single value or no value (empty). - Performing operations that complete with one result. Example: import reactor.core.publisher.Mono; public class MonoExample { public static void main(String[] args) { Mono<String> mono = Mono.just(\"Hello, World!\"); // Subscribe to the Mono and print the value mono.subscribe(value -> System.out.println(value)); // Output: Hello, World! } }","title":"1. Mono"},{"location":"spring/WebClient/#2-flux","text":"Flux represents a sequence of 0 to N items and can be thought of as a stream of data over time. It is used when you expect multiple values or an indefinite sequence, like reading multiple records from a database, consuming a stream of events, etc. Use cases for Flux: - Returning multiple items in a stream-like fashion. - Handling collections or lists asynchronously. Example: import reactor.core.publisher.Flux; public class FluxExample { public static void main(String[] args) { Flux<String> flux = Flux.just(\"Apple\", \"Banana\", \"Cherry\"); // Subscribe to the Flux and print each value flux.subscribe(value -> System.out.println(value)); // Output: // Apple // Banana // Cherry } }","title":"2. Flux"}]}